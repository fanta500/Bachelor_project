{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/p4.js/flexgl/index.js","webpack:///./node_modules/p4.js/flexgl/src/attribute.js","webpack:///./node_modules/p4.js/flexgl/src/framebuffer.js","webpack:///./node_modules/p4.js/flexgl/src/main.js","webpack:///./node_modules/p4.js/flexgl/src/program.js","webpack:///./node_modules/p4.js/flexgl/src/resource.js","webpack:///./node_modules/p4.js/flexgl/src/shader.js","webpack:///./node_modules/p4.js/flexgl/src/subroutine.js","webpack:///./node_modules/p4.js/flexgl/src/texture.js","webpack:///./node_modules/p4.js/flexgl/src/uniform.js","webpack:///./node_modules/p4.js/flexgl/src/varying.js","webpack:///./node_modules/p4.js/index.js","webpack:///./node_modules/p4.js/src/allocate.js","webpack:///./node_modules/p4.js/src/arrays.js","webpack:///./node_modules/p4.js/src/compile.js","webpack:///./node_modules/p4.js/src/control.js","webpack:///./node_modules/p4.js/src/cstore.js","webpack:///./node_modules/p4.js/src/ctypes.js","webpack:///./node_modules/p4.js/src/extensions.js","webpack:///./node_modules/p4.js/src/gljs/Aggregation.gl.js","webpack:///./node_modules/p4.js/src/gljs/Match.gl.js","webpack:///./node_modules/p4.js/src/gljs/datetime.gl.js","webpack:///./node_modules/p4.js/src/grid.js","webpack:///./node_modules/p4.js/src/initialize.js","webpack:///./node_modules/p4.js/src/interact.js","webpack:///./node_modules/p4.js/src/io/ajax.js","webpack:///./node_modules/p4.js/src/io/input.js","webpack:///./node_modules/p4.js/src/io/output.js","webpack:///./node_modules/p4.js/src/io/parse.js","webpack:///./node_modules/p4.js/src/kernels.js","webpack:///./node_modules/p4.js/src/main.js","webpack:///./node_modules/p4.js/src/operate.js","webpack:///./node_modules/p4.js/src/ops/aggregate.js","webpack:///./node_modules/p4.js/src/ops/cache.gl.js","webpack:///./node_modules/p4.js/src/ops/derive.js","webpack:///./node_modules/p4.js/src/ops/extent.gl.js","webpack:///./node_modules/p4.js/src/ops/match.js","webpack:///./node_modules/p4.js/src/pipeline.js","webpack:///./node_modules/p4.js/src/utils.js","webpack:///./node_modules/p4.js/src/vis/axis.js","webpack:///./node_modules/p4.js/src/vis/brush.js","webpack:///./node_modules/p4.js/src/vis/chart.js","webpack:///./node_modules/p4.js/src/vis/color.js","webpack:///./node_modules/p4.js/src/vis/colorhex.js","webpack:///./node_modules/p4.js/src/vis/encode.js","webpack:///./node_modules/p4.js/src/vis/extend.js","webpack:///./node_modules/p4.js/src/vis/format.js","webpack:///./node_modules/p4.js/src/vis/gradients.js","webpack:///./node_modules/p4.js/src/vis/layout.js","webpack:///./node_modules/p4.js/src/vis/legend.js","webpack:///./node_modules/p4.js/src/vis/reveal.js","webpack:///./node_modules/p4.js/src/vis/scale.js","webpack:///./node_modules/p4.js/src/vis/shaders/Instanced.gl.js","webpack:///./node_modules/p4.js/src/vis/shaders/Interleaved.gl.js","webpack:///./node_modules/p4.js/src/vis/shaders/Polygon.gl.js","webpack:///./node_modules/p4.js/src/vis/shaders/Renderer.gl.js","webpack:///./node_modules/p4.js/src/vis/shaders/interpolate.gl.js","webpack:///./node_modules/p4.js/src/vis/svg.js","webpack:///./node_modules/p4.js/src/vis/visualize.js","webpack:///./node_modules/p4.js/test/data-babies.js","webpack:///./node_modules/p4.js/test/data-kepler.js","webpack:///./node_modules/p4.js/test/data-timeseries.js","webpack:///./node_modules/p4.js/test/utils.js","webpack:///(webpack)/buildin/harmony-module.js","webpack:///./src/loaders/Csv.js","webpack:///./src/loaders/Model.js","webpack:///./src/loaders/Mysql.js","webpack:///./src/server.js","webpack:///external \"chai\"","webpack:///external \"express\"","webpack:///external \"fs\"","webpack:///external \"http\"","webpack:///external \"jStat\"","webpack:///external \"mysql\"","webpack:///external \"p3.js\"","webpack:///external \"ws\""],"names":["Csv","constructor","path","chunkSize","offset","delimiter","filePath","leftOver","rows","fetch","nrows","length","loadFromFile","then","concat","Promise","resolve","reject","slice","data","console","log","fs","open","err","fd","buffer","Buffer","read","nread","close","text","toString","split","pop","map","row","dataModels","TimeSeries","timesteps","series","interval","props","name","dtype","dist","min","max","mean","std","Babies","Models","prop","Object","keys","indexOf","Error","model","modelProps","assign","size","type","dataset","datasets","Rdb","host","user","password","database","query","source","loaded","numRows","db","mysql","createConnection","start","connect","join","error","results","fields","end","app","express","server","http","Server","port","process","env","PORT","HOST","WebSocketServer","require","wss","use","static","on","connection","ws","incoming","msg","Dataset","dsName","schema","Mysql","Model","selectedDataset","get","req","res","params","result","json","listen"],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAA+B;;AAE/B;AACA;AACA,WAAW,SAAI;;AAEf,cAAc,iDAAM;;AAEL,gHAAM,EAAC;;AAEtB,GAAG,KAA4B;AAC/B,qBAAqB,iDAAM,C;;;;;;;;;;;;;ACX3B;AAAA;AAAe;;AAEf,2DAA2D;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kEAAkE;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA,8D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC7DA;AAAA;AAAA;AAAgC;;AAEjB;;AAEf,+DAA+D;AAC/D;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,wDAAO;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACtEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACK;AACT;AACU;;AAEzB;;AAEf,qDAAqD;AACrD,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oBAAoB;AACpB;AACA,yCAAyC;AACzC;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;;AAE7B,wBAAwB,iDAAQ;AAChC,2BAA2B,oDAAW;AACtC,6BAA6B,gDAAc;AAC3C,sBAAsB,+CAAM;;AAE5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,MAAM;AACtB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qCAAqC;;AAErC;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,MAAM;AACtB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,MAAM;AACtB,gBAAgB,MAAM;AACtB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,MAAM;AACtB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;;;;;ACpSA;AAAA;AAAA;AAA8B;;AAEf;;AAEf;AACA;AACA,eAAe;AACf,oBAAoB;AACpB,sBAAsB,+CAAM;;AAE5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACtFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgC;AACI;AACJ;AACA;AACM;;AAEvB;AACf,yDAAyD;AACzD;;AAEA,2BAA2B,gDAAO;AAClC,6BAA6B,kDAAS;AACtC,2BAA2B,gDAAO;AAClC,2BAA2B,gDAAO;AAClC,8BAA8B,mDAAU;;AAExC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;;;;;ACrDA;AAAA;AAAe;;AAEf,qDAAqD;AACrD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;;AAEA;AACA,uEAAuE,OAAO;AAC9E,SAAS;AACT;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA,+DAA+D;;AAE/D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,a;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;;;;AAIb,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC5OA;AAAA;AAAe;;AAEf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AAAgC;;AAEjB;;AAEf,uDAAuD;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oCAAoC,wDAAO;AAC3C,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACpIA;AAAA;AAAe;;AAEf,uDAAuD;AACvD;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,mDAAmD,yBAAyB;AAC5E;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD,yBAAyB;AAC5E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mDAAmD,yBAAyB;AAC5E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClHA;AAAA;AAAe;;AAEf,uDAAuD;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACM;AACO;AACH;AACH;;AAEK;AACQ;AACR;;AAExC;AACA;AACA,WAAW,SAAI;;AAEf,iDAAE,QAAQ,yCAAI;AACd,iDAAE,UAAU,mDAAM;AAClB,iDAAE,UAAU,wCAAM;AAClB,iDAAE,SAAS,qDAAK;AAChB,iDAAE,aAAa,iEAAM,EAAE,iEAAM,EAAE,yEAAU;;AAEzC,UAAU,iDAAE;AACG,sEAAO,EAAC;AAChB,kBAAkB,iEAAM,EAAE,iEAAM,EAAE,yEAAU;;;;;;;;;;;;;ACtBnD;AAAA;AAAA;AAAiC;AACD;AAChC;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yC;AACA;AACA,uB;AACA;;AAEA;AACA,0CAA0C,uDAAQ;AAClD,0CAA0C,uDAAQ;AAClD,2CAA2C,uDAAQ;AACnD,2CAA2C,uDAAQ;AACnD,KAAK;AACL;AACA,gCAAgC,sDAAM;AACtC;AACA,wDAAwD,uDAAQ;AAChE;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,4BAA4B,YAAY;AACxC;AACA;;AAEA,6BAA6B,YAAY;AACzC;AACA;;AAEA,sBAAsB,sCAAsC;AAC5D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,kDAAkD;AAClF;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;;;;;;;;;;;ACxND;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,yCAAyC,sBAAsB;AAC/D;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEO;AACP;AACA;;AAEA,uBAAuB,UAAU;AACjC;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;;AAEO;AACP;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEO;AACP;AACA,iDAAiD;AACjD;AACA;AACA,KAAK;AACL;;AAEO;AACP;AACA;AACA;AACA,KAAK;AACL;;AAEO;AACP;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;AACA;;AAEA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEO;AACP;AACA;;AAEA,mBAAmB,qBAAqB;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEO;AACP;AACA;;AAEA,mBAAmB,qBAAqB;AACxC;AACA;;AAEA;AACA;;;;;;;;;;;;;ACvOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyC;AACD;AACF;AACG;AACJ;AACI;AACH;;AAEvB;;AAEf;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,8DAAS;AAC7B,oBAAoB,6DAAK;AACzB,oBAAoB,0DAAK;AACzB,oBAAoB,8DAAM;AAC1B,oBAAoB,8DAAS;AAC7B;AACA;;;;;;;;;;;;;ACvBA;AAAe;;AAEf;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;AClHD;AAAA;AAAA;AAAA;AAAmC;AACH;;AAEhC;;AAEe;AACf,8DAA8D;AAC9D,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,4CAA4C;AAC5C,uBAAuB;AACvB,0CAA0C;AAC1C,uBAAuB;AACvB,uBAAuB;AACvB,uBAAuB;AACvB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mBAAmB;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,S;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,oCAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,0CAA0C,6BAA6B;AACvE,SAAS;AACT,0CAA0C,iCAAiC;AAC3E,SAAS;AACT,0C;AACA;AACA,uF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;;AAEA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD,aAAa;AACb;;AAEA,iCAAiC,oCAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA,2BAA2B,WAAW;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,uBAAuB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,eAAe,oCAAM;AACrB;;AAEA;;AAEA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA,S;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA,S;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,sDAAM;AAC9B;AACA,SAAS;AACT;AACA,sBAAsB,SAAS;AAC/B,uE;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;AChXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAcE;;;;;;;;;;;;;ACxBF;AAAA;AAAA;AAA4B;AAC5B;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAG;AACrB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAG;AACrB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAG;AACrB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;AC5CD;AAAA;AAAA;AAAA;AAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;;;;;;;;;;;;AC3GA;AAAA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mCAAmC;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;;;;AClEA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,UAAU;AACV;;;AAGO,kBAAkB,aAAa;AACtC;AACA;AACA;;AAEO,kBAAkB,aAAa;AACtC;AACA;AACA;AACA;;AAEO,mBAAmB,yBAAyB;AACnD;AACA;;AAEA,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;;AAEO,uBAAuB,aAAa;AAC3C;AACA;AACA,C;;AAEO,mBAAmB,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC9HA;AAAA;AAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qCAAqC;AACxD,qBAAqB;AACrB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC9CA;AAAA;AAAA;AAA+B;;AAEhB;AACf;AACA;AACA;AACA,eAAe,mCAAmC;AAClD,mBAAmB;AACnB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,yBAAyB,yCAAyC;AAClE;AACA;AACA;AACA;AACA,iBAAiB,+CAAM;AACvB;AACA;AACA;AACA,sBAAsB,mCAAmC;AACzD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChCgC;AACjB;AACf;;AAEA;;AAEA;AACA,uCAAuC;AACvC;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,e;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,qC;AACA;AACA;AACA;AACA;AACA,a;AACA;;AAEA,cAAc,kDAAK;AACnB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kDAAK;AACvB,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX;;AAEA,OAAO;AACP;AACA;AACA;AACA,O;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;;;;;;;;;;;;ACjPA;AAAA;AAAA;AAAA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEO;;AAEA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;;AAEL;AACA;;AAEO;AACP;AACA;AACA;;;;;;;;;;;;;AC3DA;AAAA;AAAA;AAAA;AAAA;AAA+B;AACA;AACH;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,cAAc,uDAAM,EAAE,aAAa;AACnC,oBAAoB,wDAAwD;AAC5E;AACA;AACA,KAAK;AACL;AACA,iBAAiB,sDAAK;AACtB;AACA,yBAAyB,+CAA+C;AACxE,cAAc,uDAAM,EAAE,aAAa;AACnC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,WAAW,yCAAQ,EAAE,sCAAsC;AAC3D,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;AC/FA;AAAe;AACf;AACA,4BAA4B,4CAA4C;AACxE;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,yBAAyB,S;;AAE7C;AACA,4C;AACA;AACA;AACA,oCAAoC,oDAAoD;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,2BAA2B;AACpD,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;;AAEA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA,S;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,gBAAgB;AACxD,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA,CAAC;;;;;;;;;;;;;AChGD;AAAA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;;;;;;;;;;;AC5DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyC;AACD;AACF;AACG;AACJ;AACI;;AAE1B;AACf,IAAI,iEAAS;AACb,IAAI,4DAAK;AACT,IAAI,2DAAM;AACV,IAAI,8DAAM;AACV,IAAI,yDAAK;AACT,IAAI,iEAAS;AACb,C;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACH;AACE;AACK;AACJ;AACF;AACE;AACF;AACA;AACM;AACZ;AACI;;AAEf;AACf,WAAW,2DAAU;AACrB;AACA;AACA;AACA;AACA,kBAAkB,mDAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAY,yDAAQ;AACpB;AACA,gBAAgB,gDAAO;AACvB,oBAAoB,kDAAM;AAC1B;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA,GAAG;;AAEH,aAAa;AACb;AACA;AACA;AACA,K;AACA,kBAAkB,8CAAI;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,qCAAqC;AACpE;AACA;;AAEA;AACA,gBAAgB,gDAAO;AACvB;AACA,qBAAqB,wDAAO;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,wDAAM;AAC1B;AACA;AACA,SAAS;AACT,iBAAiB,yBAAyB;;AAE1C,MAAM,yDAAQ;AACd,KAAK;AACL,MAAM,yDAAQ;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2DAA2D,gDAAO;AAClE;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,yDAAK;AAClB;AACA;AACA,S;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,yDAAQ;AACd;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL,kBAAkB,wDAAM;AACxB;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,GAAG,qBAAqB;AACxB;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;AC7YA;AAAA;AAAA;AAAA;AAAiC;AACD;AACK;;AAEtB;AACf;AACA,kBAAkB,wDAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,gCAAgC,gDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,gDAAQ;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,gDAAQ;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,gDAAQ;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oCAAQ;AAC7C;AACA;AACA,+BAA+B,oCAAQ;AACvC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,4B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,oCAAoC,gDAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,C;;;;;;;;;;;;ACjMA;AAAA;AAAA;AAAA;AAAkC;AACqC;;AAEvE;AACA;;AAEe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,8DAAS;AAClC,2BAA2B,8DAAS;AACpC;;AAEA;AACA;AACA,yBAAyB,6DAAQ;AACjC,2BAA2B,6DAAQ;AACnC;AACA;AACA;AACA,yBAAyB,+DAAU;AACnC,2BAA2B,+DAAU;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA,gDAAgD,uDAAQ;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,oD;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA,mCAAmC,uDAAQ;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD,uDAAQ;AAC3D;AACA;AACA;AACA,oDAAoD,uDAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8CAA8C;AACtF;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC1SA;AAAA;AAAe;AACf,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iBAAiB;;AAE/D;AACA;;AAEA;AACA;;;;;;;;;;;;;ACtDA;AAAA;AAAA;AAA4E;;AAE7D;;AAEf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iCAAiC,yDAAO;AACxC,kCAAkC,0DAAQ;AAC1C,iCAAiC,yDAAO;AACxC,sCAAsC,8DAAY;;AAElD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,6DAA6D;AAC7D,GAAG;;AAEH,uDAAuD;;AAEvD;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,iBAAiB,GAAG;AAC5D;;AAEA;AACA;;;;;;;;;;;;;;;;AC/KA;AACe;;AAEf;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;ACrFA;AAAA;AAAA;AAA6D;;AAE9C;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,4DAAa;AAC1C,+BAA+B,4DAAa;AAC5C;;AAEA;AACA,6BAA6B,4DAAa;AAC1C,+BAA+B,4DAAa;AAC5C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2BAA2B,EAAE;AACvE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,SAAS;;AAET;AACA,6D;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,SAAS;;AAET;AACA;AACA,2BAA2B;AAC3B;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC5NA;AAAA;AAAe,uB;AACf;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,S;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;ACnFA;AAAA;AAAA;AAAA;AAAA;AAAmC;;AAE5B;AACP;AACA;AACA;;AAEA,cAAc,oCAAM;AACpB,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;;AAEO;AACA;;;;;;;;;;;;;ACfP;AAAA;AAAA;AAA4B;;AAEb;;AAEf,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,KAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,KAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA,aAAa;AACb,uCAAuC,eAAe;AACtD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,sDAAK;AACtB,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;;AAGb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,E;;;;;;;;;;;;ACpRA;AAAA;AAAe;;AAEf,0BAA0B;AAC1B;AACA;AACA;AACA,yBAAyB,SAAS;AAClC,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,uDAAuD;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;ACxIA;AAAA;AAAA;AAAA;AAAA;AAA0B;AACI;AACA;;AAEf;AACf,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,qCAAqC;AAC3E;AACA;AACA,0CAA0C,mBAAmB;AAC7D;;AAEA,kCAAkC,yBAAyB;AAC3D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAM;AAC1B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA,oBAAoB,uDAAM;AAC1B;AACA;;AAEA;AACA;AACA,sBAAsB,uDAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB,qDAAI;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA,gBAAgB,qDAAI;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,6DAA6D,qDAAI;AACjE,8DAA8D,qDAAI;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,qDAAI;AAChB;AACA;AACA;AACA;AACA;AACA,YAAY,qDAAI;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC3QA;AAAA;AAAA;AAAA;AAAsD;AAClB;;AAEpC;AACA;AACA,2BAA2B,oDAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,oDAAY;AACvD,uBAAuB,oDAAY;AACnC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,kDAAQ;AACvB,eAAe,kDAAQ;AACvB,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,sBAAsB,iCAAiC;AACvD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA,4DAA4D;;AAE5D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpKA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7IA;AAAA;AAAA;AAAO;;AAEA;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9HA;AAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,kCAAkC;AACvE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,S;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,C;;;;;;;;;;;;AC9DA;AAAA;AAAA;AAA8B;;AAEf;AACf;AACA;AACA;AACA;AACA;AACA,gBAAgB,mDAAG;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sEAAsE,IAAI;AAC1E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvCA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAwB;AACI;;AAE5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,cAAc,qCAAqC;AACnD;;AAEe;AACf;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA,mBAAmB,4CAAG;AACtB;AACA;AACA;AACA,oBAAoB;AACpB,SAAS;AACT;;AAEA;AACA;AACA;AACA,wCAAwC,qCAAqC;AAC7E,mCAAmC,wBAAwB;AAC3D,mCAAmC;;AAEnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,sDAAK;AACpB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iDAAiD,qBAAqB,eAAe;AACrF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;;;;;;;;;;;;ACvLA;AAAA;AAAA;AAAA;AAAA;AAAwB;AACE;AACS;;AAEnC;AACA;AACA;;AAEe;AACf;;AAEA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,iCAAiC,qCAAqC;AACtE;AACA;AACA;AACA,8BAA8B,uDAAW;;;AAGzC;AACA;AACA;;AAEA;AACA,UAAU,4CAAG,EAAE,+CAA+C;AAC9D;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA,GAAG;AACH,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAW;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAW;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,6CAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA,KAAK;AACL,GAAG;AACH,QAAQ,6CAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA,KAAK;AACL;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACxJA;AAAA;AAAA;AAAkC;AACnB;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,0CAA0C;;AAE1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,uDAAQ;AAC1C,kCAAkC,uDAAQ;AAC1C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnIA;AAAA;AAAe;AACf,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC,SAAS;AACT;AACA;AACA,gCAAgC;AAChC,SAAS;AACT;AACA;AACA;;AAEA,gCAAgC;;AAEhC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gCAAgC;AAChC;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC7EA;AAAA;AAAA;AAAoC;;AAErB,wBAAwB,oDAAQ;AAC/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;AC9EA;AAAA;AAAA;AAAoC;;AAErB,wBAAwB,oDAAQ;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACzDA;AAAA;AAAA;AAAoC;;AAErB,sBAAsB,oDAAQ;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACxFA;AAAA;AAAe;AACf,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AChCA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACpDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe;;AAEf,+CAA+C;AAC/C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,kCAAkC;AAClC,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC3IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6B;AACC;AACoB;AACpB;AACoB;;AAEpB;AACgB;AACJ;AACQ;;AAElD;AACA;;AAEe;;AAEf,uBAAuB,sDAAM;AAC7B,sCAAsC;AACtC;;AAEA,kBAAkB,+CAAM;AACxB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,uDAAuD,wDAAgB;AACvE,yDAAyD,wDAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,uDAAM;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+DAAW;AAChD,mDAAmD,+DAAW;;AAE9D;AACA,uBAAuB,6DAAS,EAAE,+BAA+B;AACjE,qBAAqB,2DAAO,EAAE,6BAA6B;AAC3D,wBAAwB,+DAAW,EAAE,gCAAgC;AACrE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sDAAM;;AAE/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,a;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mE;AACA;AACA;;AAEA;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,QAAQ,uDAAM;;AAEd;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,sCAAsC,wCAAwC;;AAE9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;;;;;;;;;;;;;ACrPA;AAAA;AAAoD;;AAEpD;AACA;;AAEA;AACA,KAAK,kEAAkE;AACvE,KAAK,wDAAwD;AAC7D,KAAK,qFAAqF;AAC1F,KAAK,qFAAqF;AAC1F,KAAK,mDAAmD;AACxD,KAAK,wEAAwE;AAC7E,KAAK,uDAAuD;AAC5D,KAAK,2FAA2F;AAChG,KAAK,4FAA4F;AACjG,KAAK,2FAA2F;AAChG,KAAK,qFAAqF;AAC1F,KAAK,mDAAmD;AACxD,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,0DAAW,EAAE,6BAA6B,GAAG,2DAAY,EAAE,6BAA6B;AAC3H,YAAY;AACZ;;AAEA;;AAEe,qEAAM,E;;;;;;;;;;;;ACpCrB;AAAA;AAAoD;;AAEpD;AACA,KAAK,+FAA+F;AACpG,KAAK,gFAAgF;AACrF,KAAK,6EAA6E;AAClF,KAAK,wFAAwF;AAC7F,KAAK,+EAA+E;AACpF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,0DAAW,EAAE,6BAA6B,GAAG,2DAAY,EAAE,6BAA6B;AAC3H,YAAY;AACZ;;AAEA;;AAEe,qEAAM,E;;;;;;;;;;;;ACzBrB;AAAA;AAAsC;;AAEvB;AACf;AACA;AACA;AACA;AACA,WAAW;AACX,CAAC;AACD;AACA;AACA,gBAAgB,eAAe;AAC/B,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,0BAA0B,4DAAa;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;;;;;;;;;;;ACvC4B;AACC;AACK;AACK;;AAEvC,YAAY,2CAAM;AAClB,cAAc,2CAAM;AACpB,iBAAiB,2CAAM;AACvB,iBAAiB,4CAAM;;AAEhB;AACP;AACA;AACA;AACA;AACA,sBAAsB,kCAAkC;AACxD,sBAAsB,0CAA0C;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,aAAa,2DAAM,GAAG;AACtB;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,wCAAM;AAC/B,sBAAsB,UAAU;AAChC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEO;AACP;AACA,8B;;AAEA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,C;;;;;;;;;;;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AACe,MAAMA,GAAN,CAAU;AACvBC,cAAY;AACVC,QADU;AAEVC,gBAAY,IAAI,IAAJ,GAAW,IAFb;AAGVC,aAAS,CAHC;AAIVC,gBAAY;AAJF,GAAZ,EAKG;AACD,SAAKC,QAAL,GAAgBJ,IAAhB;AACA,SAAKE,MAAL,GAAcA,MAAd;AACA,SAAKD,SAAL,GAAiBA,SAAjB;AACA,SAAKE,SAAL,GAAiBA,SAAjB;AACA,SAAKE,QAAL,GAAgB,EAAhB;AACA,SAAKC,IAAL,GAAY,EAAZ;AACD;;AAEDC,QAAOC,QAAQ,IAAf,EAAqB;AACnB,QAAIA,QAAQ,KAAKF,IAAL,CAAUG,MAAtB,EAA8B;AAC5B,aAAO,KAAKC,YAAL,GAAoBC,IAApB,CAAyBL,QAAQ;AACtC,aAAKA,IAAL,GAAY,KAAKA,IAAL,CAAUM,MAAV,CAAiBN,IAAjB,CAAZ;AACA,eAAO,KAAKC,KAAL,CAAWC,KAAX,CAAP;AACD,OAHM,CAAP;AAID,KALD,MAKO;AACL,WAAKH,QAAL,GAAgB,EAAhB;AACA,aAAO,IAAIQ,OAAJ,CAAa,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACvCD,gBAAQ,KAAKR,IAAL,CAAUU,KAAV,CAAgB,CAAhB,EAAmBR,KAAnB,CAAR;AACA,aAAKF,IAAL,GAAY,KAAKA,IAAL,CAAUU,KAAV,CAAgBR,KAAhB,CAAZ;AACD,OAHM,CAAP;AAID;AACF;;AAEDE,iBAAiB;AACf,QAAIO,OAAO,EAAX;AACA,SAAKZ,QAAL,GAAgB,EAAhB;AACAa,YAAQC,GAAR,CAAY,KAAKjB,MAAjB;AACA,WAAO,IAAIW,OAAJ,CAAa,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACvCK,+CAAEA,CAACC,IAAH,CAAQ,KAAKjB,QAAb,EAAuB,GAAvB,EAA4B,CAACkB,GAAD,EAAMC,EAAN,KAAa;AACvC,YAAIC,SAAS,IAAIC,MAAJ,CAAW,KAAKxB,SAAhB,CAAb;AACAmB,iDAAEA,CAACM,IAAH,CAAQH,EAAR,EAAYC,MAAZ,EAAoB,CAApB,EAAuB,KAAKvB,SAA5B,EAAuC,KAAKC,MAA5C,EAAoD,CAACoB,GAAD,EAAMK,KAAN,KAAgB;AAClE,cAAIL,GAAJ,EAAS;AACPP,mBAAOO,GAAP;AACAF,qDAAEA,CAACQ,KAAH;AACD;AACD,cAAID,UAAU,CAAd,EAAiBP,yCAAEA,CAACQ,KAAH;;AAEjB,cAAID,QAAQ,KAAK1B,SAAjB,EAA4B;AACxBgB,mBAAOO,OAAOR,KAAP,CAAa,CAAb,EAAgBW,KAAhB,CAAP;AACH,WAFD,MAEO;AACHV,mBAAOO,MAAP;AACH;AACD,cAAIK,OAAO,KAAKxB,QAAL,GAAgBY,KAAKa,QAAL,CAAc,MAAd,CAA3B;AACA,cAAIxB,OAAOuB,KAAKE,KAAL,CAAW,IAAX,CAAX;AACA,eAAK1B,QAAL,GAAgBC,KAAK0B,GAAL,EAAhB;AACAf,iBAAOX,KAAK2B,GAAL,CAASC,OAAOA,IAAIH,KAAJ,CAAU,KAAK5B,SAAf,CAAhB,CAAP;AACA,eAAKD,MAAL,IAAe,KAAKD,SAApB;;AAEAa,kBAAQG,IAAR;AACD,SAnBD;AAoBD,OAtBD;AAuBD,KAxBM,CAAP;AAyBD;AA3DsB,C;;;;;;;;;;;;ACDzB;AAAA;AAAA;AAAA;;AAEA,IAAIkB,aAAa;AACfC,cAAY;AACVC,eAAW,CADD;AAEVC,YAAQ,GAFE;AAGVC,cAAU,GAHA;AAIVC,WAAO,CACH,EAACC,MAAM,SAAP,EAAkBC,OAAO,KAAzB,EAAiCC,MAAM,QAAvC,EAAiDC,KAAK,CAAtD,EAAyDC,KAAK,KAA9D,EAAqEC,MAAM,GAA3E,EAAgFC,KAAK,GAArF,EADG,EAEH,EAACN,MAAM,SAAP,EAAkBC,OAAO,OAAzB,EAAmCC,MAAM,QAAzC,EAAmDC,KAAK,CAAxD,EAA2DC,KAAK,KAAhE,EAAuEC,MAAM,GAA7E,EAAkFC,KAAK,GAAvF,EAFG;AAJG,GADG;AAUfC,UAAQ;AAVO,CAAjB;;AAae,MAAMC,MAAN,CAAa;AAC1BlD,cAAY;AACV0C,WAAO,QADG;AAEVS,WAAO;AAFG,GAAZ,EAGG;AACD,QAAIC,OAAOC,IAAP,CAAYjB,UAAZ,EAAwBkB,OAAxB,CAAgCZ,IAAhC,MAA0C,CAAC,CAA/C,EAAkD;AAChD,YAAMa,MAAM,6BAA6Bb,IAAnC,CAAN;AACD;AACD,SAAKc,KAAL,GAAad,IAAb;AACA,SAAKS,IAAL,GAAYA,IAAZ;AACD;;AAED3C,QAAOC,QAAQ,IAAf,EAAqB;AACnB,QAAIgD,aAAaL,OAAOM,MAAP,CAAc,KAAKP,IAAnB,EAAyBf,WAAW,KAAKoB,KAAhB,CAAzB,CAAjB;AACAC,eAAWE,IAAX,GAAkBlD,KAAlB;AACAgD,eAAWnB,SAAX,GAAuB7B,KAAvB;AACAgD,eAAWG,IAAX,GAAkB,OAAlB;AACA,QAAIC,UAAUC,2CAAQA,CAAC,KAAKN,KAAd,EAAqBC,UAArB,CAAd;AACA,WAAO,IAAI3C,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtCD,cAAQ8C,QAAQ3C,IAAhB;AACD,KAFM,CAAP;AAGD;AArByB,C;;;;;;;;;;;;ACf5B;AAAA;AAAA;AAAA;AAAA;;AAEe,MAAM6C,GAAN,CAAU;AACrB/D,gBAAY;AACRgE,eAAO,WADC;AAERC,YAFQ;AAGRC,gBAHQ;AAIRC,gBAJQ;AAKRC;AALQ,KAAZ,EAMG;AACC,aAAKC,MAAL,GAAc,EAAEL,IAAF,EAAQC,IAAR,EAAcC,QAAd,EAAwBC,QAAxB,EAAd;AACA,aAAKC,KAAL,GAAaA,SAAS,mBAAmBD,QAAzC;AACA,aAAKG,MAAL,GAAc,CAAd;AACH;;AAED9D,UAAO+D,UAAU,IAAjB,EAAuBpE,MAAvB,EAA+B;AAC3B,YAAIqE,KAAKC,4CAAKA,CAACC,gBAAN,CAAuB,KAAKL,MAA5B,CAAT;AACA,YAAIM,QAAQxE,UAAU,KAAKmE,MAA3B;AACAE,WAAGI,OAAH;AACA,eAAO,IAAI9D,OAAJ,CAAa,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACrCwD,eAAGJ,KAAH,CAAS,KAAKA,KAAL,GAAa,SAAb,GAAyB,CAACO,KAAD,EAAQJ,OAAR,EAAiBM,IAAjB,CAAsB,GAAtB,CAAlC,EAA8D,CAACC,KAAD,EAAQC,OAAR,EAAiBC,MAAjB,KAA4B;AACtF,oBAAIF,KAAJ,EAAW9D,OAAO8D,KAAP;AACX/D,wBAAQgE,OAAR;AACAP,mBAAGS,GAAH;AACA,qBAAKX,MAAL,IAAeC,OAAf;AACH,aALD;AAMH,SAPM,CAAP;AAQH;AAzBoB,C;;;;;;;;;;;;ACFzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA,IAAIW,MAAMC,8CAAOA,EAAjB;AACA,IAAIC,SAASC,2CAAIA,CAACC,MAAL,CAAYJ,GAAZ,CAAb;AACA,IAAIK,OAAOC,QAAQC,GAAR,CAAYC,IAAZ,IAAoB,IAA/B;AACA,IAAI1B,OAAOwB,QAAQC,GAAR,CAAYE,IAAZ,IAAoB,WAA/B;AACA,IAAIC,kBAAkBC,mBAAOA,CAAC,cAAR,EAAcP,MAApC;AACA,IAAIQ,MAAM,IAAIF,eAAJ,CAAoB,EAAER,MAAF,EAApB,CAAV;;AAEAF,IAAIa,GAAJ,CAAQ,OAAR,EAAiBZ,8CAAOA,CAACa,MAAR,CAAe,MAAf,CAAjB;AACAd,IAAIa,GAAJ,CAAQ,OAAR,EAAiBZ,8CAAOA,CAACa,MAAR,CAAe,MAAf,CAAjB;AACAd,IAAIa,GAAJ,CAAQ,QAAR,EAAkBZ,8CAAOA,CAACa,MAAR,CAAe,OAAf,CAAlB;;AAEAF,IAAIG,EAAJ,CAAO,YAAP,EAAqB,SAASC,UAAT,CAAqBC,EAArB,EAAyB;AAC5ChF,UAAQC,GAAR,CAAY,gBAAZ;AACA+E,KAAGF,EAAH,CAAM,SAAN,EAAiB,SAASG,QAAT,CAAmBC,GAAnB,EAAwB;AACvClF,YAAQC,GAAR,CAAYiF,GAAZ;AACD,GAFD;AAGD,CALD;;AAOA;AACA;AACA;AACA;;AAEA,SAASC,OAAT,CAAkBC,MAAlB,EAA0B;AACxB,MAAI1C,UAAUC,gDAAQA,CAACyC,MAAT,CAAd;AACA,MAAG1C,QAAQD,IAAR,KAAiB,OAApB,EAA6B;AAC3B,WAAO;AACL4C,cAAQ3C,QAAQ2C,MADX;AAELnC,cAAQ,IAAIoC,sDAAJ,CAAU5C,QAAQQ,MAAlB;AAFH,KAAP;AAID,GALD,MAKO,IAAGR,QAAQD,IAAR,KAAiB,MAApB,EAA4B;AACjC,WAAO;AACL4C,cAAQ3C,QAAQ2C,MADX;AAELnC,cAAQ,IAAItE,oDAAJ,CAAQ8D,QAAQQ,MAAhB;AAFH,KAAP;AAID,GALM,MAKA,IAAGR,QAAQD,IAAR,KAAiB,WAAjB,IAAgCC,QAAQD,IAAR,KAAiB,OAApD,EAA6D;AAClE,WAAO;AACL4C,cAAQ3C,QAAQ2C,MADX;AAELnC,cAAQ,IAAIqC,sDAAJ,CAAU7C,QAAQQ,MAAlB;AAFH,KAAP;AAID;AACF;;AAED,IAAIsC,kBAAkB,IAAtB;;AAEAzB,IAAI0B,GAAJ,CAAQ,gBAAR,EAA0B,UAAUC,GAAV,EAAeC,GAAf,EAAoB;AAC5C,MAAIjD,UAAUgD,IAAIE,MAAJ,CAAWlD,OAAzB;AACA,MAAIc,QAAQkC,IAAIzC,KAAJ,CAAUO,KAAtB;AACA,MAAIlE,QAAQoG,IAAIzC,KAAJ,CAAU3D,KAAV,IAAmB,KAA/B;AACA,MAAIkG,oBAAoB,IAAxB,EAA8BA,kBAAkBL,QAAQzC,OAAR,CAAlB;;AAE9B8C,kBAAgBtC,MAAhB,CAAuB7D,KAAvB,CAA6BC,KAA7B,EAAoCkE,KAApC,EAA2C/D,IAA3C,CAAgDoG,UAAU;AACxDF,QAAIG,IAAJ,CAAS;AACPT,cAAQG,gBAAgBH,MADjB;AAEPtF,YAAM8F;AAFC,KAAT;AAID,GALD;AAMD,CAZD;;AAcA9B,IAAI0B,GAAJ,CAAQ,WAAR,EAAqB,UAAUC,GAAV,EAAeC,GAAf,EAAoB;AACvCA,MAAIG,IAAJ,CAAS,EAAC/F,MAAM,MAAP,EAAT;AACD,CAFD;;AAIAkE,OAAO8B,MAAP,CAAc3B,IAAd,EAAoBvB,IAApB,EAA0B,YAAW;AACnC7C,UAAQC,GAAR,CAAY,2BAAZ,EAAyC4C,IAAzC,EAA+CuB,IAA/C;AACD,CAFD,E;;;;;;;;;;;;;;;;;;;;;;AClEA,iC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,+B;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,kC;;;;;;;;;;;ACAA,kC;;;;;;;;;;;ACAA,kC;;;;;;;;;;;ACAA,+B","file":"server.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/server.js\");\n","import flexgl from './src/main'\r\n\r\nvar root = typeof self == 'object' && self.self === self && self ||\r\n           typeof global == 'object' && global.global === global && global ||\r\n           this;\r\n\r\nroot.flexgl = flexgl;\r\n\r\nexport default flexgl;\r\n\r\nif(typeof module != 'undefined' && module.exports)\r\n    module.exports = flexgl;","export default function Attribute(glContext) {\n    \n    var attribute = (this instanceof Attribute) ? this : {},\n        ctx = glContext,\n        attributeID = 0;\n\n    function setAttribute(name, data) {\n        if(Array.isArray(data) || ArrayBuffer.isView(data)){\n            if(!ArrayBuffer.isView(data)) {\n                data = new Float32Array(data);\n            }\n            attribute[name].data = data;\n            ctx.bindBuffer(ctx.ARRAY_BUFFER, attribute[name].ptr);\n            ctx.bufferData(ctx.ARRAY_BUFFER, data, ctx.STATIC_DRAW);\n        }\n    }\n    attribute.create = function(name, type, data) {\n        attribute[name] = {\n            name: name,\n            type: type || 'float',\n            data: null,\n            location: attributeID++,\n            ptr: ctx.createBuffer(),\n            size: parseInt(type.slice(3,4)) || 1\n        };\n\n        if(data !== null && data.length) setAttribute(name, data);\n\n        attribute[name].link = function(program) {\n            ctx.bindBuffer(ctx.ARRAY_BUFFER, this.ptr);\n            this.location = ctx.getAttribLocation(program, this.name);\n            ctx.vertexAttribPointer(this.location, this.size, ctx.FLOAT, false, 0, 0);\n            ctx.enableVertexAttribArray(this.location);\n            return this;\n        }\n\n        attribute[name].load = function(arrayBuffer) {\n            setAttribute(this.name, arrayBuffer);\n            return this;\n        }\n\n        attribute[name].header = function() {\n            return 'attribute ' + this.type + ' ' + this.name + ';\\n';\n        }\n\n        attribute[name].update = function(offset, data) {\n            if(!ArrayBuffer.isView(data)) {\n                data = new Float32Array(data);\n            }\n            ctx.bindBuffer(ctx.ARRAY_BUFFER, this.ptr);\n            ctx.bufferSubData(ctx.ARRAY_BUFFER, offset, data);   \n        }\n\n        attribute[name].delete = function() {\n            ctx.deleteBuffer(this.ptr);\n        }\n\n        return attribute[name];\n    };\n\n    return attribute;\n}\n","import Texture from './texture';\n\nexport default function Framebuffer(glContext) {\n\n    var framebuffer = (this instanceof Framebuffer) ? this : {},\n        ctx = glContext;\n\n    framebuffer.create = function(name, type, dim, texture) {\n\n        framebuffer[name] = {\n            ptr: ctx.createFramebuffer(),\n            name: name,\n            type: type || \"float\",\n            width: dim[0] || 1024,\n            height: dim[1] || 1024,\n            texture: texture || null,\n            renderbuffer: ctx.createRenderbuffer(),\n        }\n\n        if (framebuffer[name].texture === null) {\n            var buf = (type == 'float') ?\n                new Float32Array(dim[0] * dim[1] * 4) :\n                new Uint8Array(dim[0] * dim[1] * 4);\n            framebuffer[name].texture = Texture(ctx).create(name, type, dim, \"rgba\", buf);\n        }\n\n        var renderbuffer = framebuffer[name].renderbuffer;\n        ctx.bindFramebuffer(ctx.FRAMEBUFFER, framebuffer[name].ptr);\n        ctx.bindRenderbuffer(ctx.RENDERBUFFER, renderbuffer);\n        ctx.renderbufferStorage(\n            ctx.RENDERBUFFER,\n            ctx.DEPTH_COMPONENT16,\n            framebuffer[name].width,\n            framebuffer[name].height\n        );\n        ctx.framebufferTexture2D(\n            ctx.FRAMEBUFFER,\n            ctx.COLOR_ATTACHMENT0,\n            ctx.TEXTURE_2D,\n            framebuffer[name].texture.ptr,\n            0\n        );\n        ctx.framebufferRenderbuffer(\n            ctx.FRAMEBUFFER,\n            ctx.DEPTH_ATTACHMENT,\n            ctx.RENDERBUFFER,\n            renderbuffer\n        );\n        ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);\n        ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);\n\n        framebuffer[name].enableRead = function(program) {\n            ctx.activeTexture(ctx.TEXTURE0 + this.texture.index);\n            ctx.bindTexture(ctx.TEXTURE_2D, this.texture.ptr);\n            this.texture.location = ctx.getUniformLocation(program, this.texture.name);\n            ctx.uniform1i(this.texture.location, this.texture.index);\n        };\n\n        framebuffer[name].delete = function() {\n            ctx.bindRenderbuffer(gl.RENDERBUFFER, null);\n            ctx.bindFramebuffer(gl.FRAMEBUFFER, null);\n            ctx.deleteRenderbuffer(this.renderbuffer);\n            ctx.deleteTexture(this.texture.ptr)\n            ctx.deleteFramebuffer(this.ptr);\n        };\n\n        return framebuffer[name];\n    }\n\n    return framebuffer;\n}\n","import Resource from './resource';\nimport ProgramManager from './program';\nimport Shader from './shader';\nimport Framebuffer from './framebuffer';\n\nexport default function FlexGL(arg) {\n\n    var flexgl = (this instanceof FlexGL) ? this : {},\n        options = arg || {},\n        container = options.container || null,\n        canvas = options.canvas || document.createElement(\"canvas\"),\n        viewport = options.viewport || [0, 0],\n        width = options.width || viewport[0] || null,\n        height = options.height || viewport[1] || null,\n        padding = options.padding || {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        },\n        ctx = options.context || options.ctx || null,\n        kernels = {},\n        program = null,\n        glAttr = options.attributes || {},\n        sharedFunction = options.sharedFunction || {};\n\n    \n    if (typeof(canvas) == \"string\") {\n        if (canvas[0] == \"#\") canvas = document.getElementById(cavnas.substring(1));\n        else canvas = document.getElementById(cavnas);\n    }\n    if (container) {\n        container = (typeof(container) == \"string\") ? document.getElementById(container) : container;\n        if (width === null) width = container.clientWidth;\n        if (height === null) height = container.clientHeight;\n    }\n    // width -= padding.left + padding.right;\n    // height -= padding.top + padding.bottom;\n    canvas.width = width;\n    canvas.height = height;\n    canvas.style.position = \"absolute\";\n    canvas.style.marginLeft = padding.left + \"px\";\n    canvas.style.marginTop = padding.top + \"px\";\n\n    if (ctx === null)\n        ctx = setupWebGL(canvas);\n    flexgl.ctx = ctx;\n    flexgl.canvas = canvas;\n\n    ctx._dict = options.env || options.dict || options.dictionary || {};\n    ctx.subroutineNames = []; // save all subroutines' names \n\n    var resources = new Resource(ctx),\n        framebuffers = new Framebuffer(ctx),\n        programManager = new ProgramManager(ctx, resources),\n        shaders = new Shader(ctx, resources);\n\n    var blendExt = ctx.getExtension(\"EXT_blend_minmax\");\n    if (blendExt) {\n        ctx.MAX_EXT = blendExt.MAX_EXT;\n        ctx.MIN_EXT = blendExt.MIN_EXT;\n    }\n\n    ctx.ext = ctx.getExtension(\"ANGLE_instanced_arrays\");\n    enableExtension([\n        \"OES_texture_float\",\n        \"OES_texture_float_linear\",\n        // \"OES_texture_half_float\",\n        // \"OES_texture_half_float_linear\"\n    ]);\n\n    if (container)\n        container.appendChild(canvas);\n\n    function setupWebGL(canvas) {\n        var names = [\"webgl\", \"experimental-webgl\"];\n        var gl = null;\n        for (var i = 0; i < names.length; ++i) {\n            try {\n                gl = canvas.getContext(names[i], glAttr);\n            } catch (e) {}\n            if (gl) break;\n        }\n        return gl;\n    }\n\n    function enableExtension(extensions) {\n        if (!Array.isArray(extensions)) extensions = [extensions];\n        extensions.forEach(function(extension) {\n            var extProps = ctx.getExtension(extension);\n            if (extProps !== null) {\n                Object.keys(extProps).forEach(function(ep) {\n                    if (!ext.hasOwnProperty(ep)) {\n                        ctx.ext[ep] = extProps[ep];\n                    }\n                })\n            }\n        });\n    };\n\n    flexgl.enableExtension = enableExtension;\n\n    /**\n     * Allocate Attributes in vertex buffer array stored in GPU memory\n     * @param  {String} name attribute name\n     * @param  {String} type attribute type: float, vec2, ...\n     * @param  {Array} data data values\n     * @return {Object}      FLexGL object\n     */\n    flexgl.attribute = function(name, type, data) {\n        resources.allocate(\"attribute\", name, type, data);\n        Object.defineProperty(flexgl.attribute, name, {\n            get: function() {\n                return resources.attribute[name];\n            },\n            set: function(data) {\n                resources.attribute[name].load(data);\n            }\n        });\n        return flexgl;\n    };\n    flexgl.buffer = flexgl.attribute; //alias\n\n    /**\n     * Create a Uniform variable for WebGL shader programs\n     * @param  {String} name attribute name\n     * @param  {String} type uniform variable type: float, vec2, ...\n     * @param  {Array} data data values\n     * @return {Object}      FLexGL object\n     */\n    flexgl.uniform = function(name, type, data) {\n        resources.allocate(\"uniform\", name, type, data);\n        if (!flexgl.uniform.hasOwnProperty(name)) {\n            Object.defineProperty(flexgl.uniform, name, {\n                get: function() {\n                    return resources.uniform[name];\n                },\n                set: function(data) {\n                    resources.uniform[name].load(data);\n                    if (ctx.isProgram(program))\n                        resources.uniform[name].link(program);\n                }\n            });\n        }\n        return flexgl;\n    };\n\n    flexgl.uniform.serialize = function(aoa) {\n        var sa = [];\n        aoa.forEach(function(a) {\n            sa = sa.concat(a);\n        })\n        return sa;\n    }\n\n    /**\n     * Create a Uniform variable for WebGL shader programs\n     * @param  {String} name attribute name\n     * @param  {String} type texture type: unsigned_byte or float, ...\n     * @param  {Array} data data values\n     * @param  {Array} dim [width, height]\n     * @param  {String} [channel='alpha'] WebGL formats (rgba, alpha)\n     * @param  {Object} [sampler=null] FLexGL Uniform Object\n     * @return {Object}      FLexGL object\n     */\n    flexgl.texture = function(name, type, data, dim, channel, sampler) {\n        resources.allocate(\"texture\", name, type, dim, channel, data, sampler);\n        Object.defineProperty(flexgl.texture, name, {\n            get: function() {\n                return resources.texture[name];\n            },\n            set: function(data) {\n                resources.texture[name].load(data);\n            }\n        });\n        return flexgl;\n    }\n\n    flexgl.texture.update = function(name, data, offset, dim) {\n        resources.texture[name].update(data, offset, dim);\n    }\n\n    /**\n     * Create a Uniform variable for WebGL shader programs\n     * @param  {String} name attribute name\n     * @param  {String} [type] Varying variable type: float, vec2, ...\n     * @param  {Number} [size=1] data array\n     * @return {Object}      FLexGL object\n     */\n    flexgl.varying = function(name, type, size) {\n        resources.allocate(\"varying\", name, type, size);\n        return flexgl;\n    };\n\n    /**\n     * Create a Uniform variable for WebGL shader programs\n     * @param  {String} name attribute name\n     * @param  {String} type attribute type: float, vec2, ...\n     * @param  {Array} dim [width, height]\n     * @param  {Object} [texture=null] FLexGL Texture Object\n     * @return {Object}      FLexGL object\n     */\n    flexgl.framebuffer = function(name, type, dim, texture) {\n        var texture = texture || resources.allocate('texture', name, type, dim, 'rgba', null);\n\n        framebuffers.create(name, type, dim, texture);\n        if (!flexgl.framebuffer.hasOwnProperty(name)) {\n            Object.defineProperty(flexgl.framebuffer, name, {\n                get: function() {\n                    return framebuffers[name];\n                }\n            });\n        }\n        return flexgl;\n    }\n\n    flexgl.framebuffer.enableRead = function(name) {\n        framebuffers[name].enableRead(program);\n    }\n\n    flexgl.bindFramebuffer = function(fbName) {\n        if (framebuffers.hasOwnProperty(fbName)) {\n            ctx.bindFramebuffer(ctx.FRAMEBUFFER, framebuffers[fbName].ptr);\n        } else {\n            ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);\n        }\n    }\n\n    flexgl.subroutine = function(name, type, fn) {\n        ctx.subroutineNames.push(name);\n        resources.allocate(\"subroutine\", name, type, fn);\n        return flexgl;\n    }\n\n    flexgl.parameter = function(keyValuePairs) {\n        Object.keys(keyValuePairs).forEach(function(key) {\n            ctx._dict[key] = keyValuePairs[key];\n            if (Array.isArray(ctx._dict[key])) {\n                var i = 0;\n                Object.defineProperty(ctx._dict, key, {\n                    get: function() {\n                        return keyValuePairs[key][i++];\n                    },\n                    set: function(newArray) {\n                        i = 0;\n                        ctx._dict[key] = newArray;\n                    }\n                });\n            } else if(typeof(ctx._dict[key]) == 'object') {\n                var dictKeys = Object.keys(ctx._dict[key]);\n                fxgl.uniform('dict'+key, 'float', dictKeys.map(d=>ctx._dict[key][d]));\n            }\n        })\n        return flexgl;\n    }\n\n    flexgl.dictionary = flexgl.parameter;\n\n    flexgl.shader = programManager.shader;\n\n    flexgl.program = function(name, vs, fs) {\n        program = programManager.program(name, vs, fs);\n        return ctx;\n    }\n\n    flexgl.createProgram = function(name, vs, fs) {\n        program = programManager.create(name, vs, fs);\n        return ctx;\n    }\n\n    flexgl.app = function(name, props) {\n        var vs = flexgl.shader.vertex(props.vs),\n            fs = flexgl.shader.fragment(props.fs),\n            fb = props.framebuffer || null;\n\n        flexgl.program(name, vs, fs);\n\n        var draw = props.render || props.draw;\n\n        return function(args) {\n            var gl = flexgl.program(name);\n            return draw.call(gl, args);\n        }\n    }\n\n    flexgl.dimension = function() {\n        return [canvas.width, canvas.height];\n    }\n\n    flexgl.resources = resources;\n\n    return flexgl;\n}\n","import Shader from './shader';\n\nexport default function Program(glContext, resources) {\n\n    var program,\n        ctx = glContext,\n        pm = {},\n        kernels = {},\n        shaders = new Shader(glContext, resources);\n\n    pm.create = function(name, vs, fs) {\n        var name = name || \"default\",\n            vs = vs || \"default\",\n            fs = fs || \"default\",\n            deps = [];\n\n        if (kernels.hasOwnProperty(name)) {\n            pm.delete(name);\n        }\n\n        kernels[name] = ctx.createProgram();\n\n        kernels[name].vs = (typeof vs == \"object\") ? vs : shaders.vertex[vs];\n        kernels[name].fs = (typeof fs == \"object\") ? fs : shaders.fragment[fs];\n\n        ctx.attachShader(kernels[name], kernels[name].vs);\n        ctx.attachShader(kernels[name], kernels[name].fs);\n        ctx.linkProgram(kernels[name]);\n        var linked = ctx.getProgramParameter(kernels[name], ctx.LINK_STATUS);\n        if (!linked) {\n            var lastError = ctx.getProgramInfoLog(kernels[name]);\n            throw (\"Error in program linking:\" + lastError);\n            ctx.deleteProgram(kernels[name]);\n            return null;\n        }\n\n        deps = deps.concat(kernels[name].vs.deps);\n        deps = deps.concat(kernels[name].fs.deps);\n        kernels[name].deps = deps;\n\n        return kernels[name];\n    }\n\n    pm.use = pm.program = function(name, vs, fs) {\n        if (kernels.hasOwnProperty(name)) {\n            program = kernels[name];\n            ctx.useProgram(program);\n            resources.link(program, program.deps);\n            return program;\n        } else {\n            return pm.create(name, vs, fs);\n        }\n    }\n\n    pm.delete = function(name) {\n        if (kernels.hasOwnProperty(name)) {\n            ctx.detachShader(kernels[name], kernels[name].vs);\n            ctx.detachShader(kernels[name], kernels[name].fs);\n            ctx.deleteProgram(kernels[name]);\n            delete kernels[name];\n        }\n    }\n\n    pm.shader = function(arg, fn) {\n        var options = arg;\n        shaders.create(options, fn);\n        return pm;\n    }\n\n    pm.shader.vertex = function(fn) {\n        var options = {\n            type: \"vertex\"\n        };\n        if (fn.name) options.name = fn.name;\n        return shaders.create(options, fn);\n    }\n\n    pm.shader.fragment = function(fn) {\n        var options = {\n            type: \"fragment\"\n        };\n        if (fn.name) options.name = fn.name;\n        return shaders.create(options, fn);\n    }\n\n    return pm;\n}\n","import Uniform from './uniform';\nimport Attribute from './attribute';\nimport Texture from './texture';\nimport Varying from './varying';\nimport Subroutine from './subroutine';\n\nexport default function Resource(glContext) {\n    var resource = (this instanceof Resource) ? this : {},\n        gpuResources = {};\n\n    resource.uniform = new Uniform(glContext);\n    resource.attribute = new Attribute(glContext);\n    resource.texture = new Texture(glContext);\n    resource.varying = new Varying(glContext);\n    resource.subroutine = new Subroutine();\n\n    var resourceTypes = ['uniform', 'attribute', 'texture', 'varying', 'subroutine'];\n\n    resource.allocate = function(type, props) {\n        if (resourceTypes.indexOf(type) === -1) {\n            throw Error(\"Error: Invalid resource type: \" + type);\n        }\n        var res = resource[type].create.apply(null, Array.prototype.slice.call(arguments, 1));\n        res.resourceType = type;\n        gpuResources[res.name] = res;\n        if (!gpuResources.hasOwnProperty(res.name)) {\n            Object.defineProperty(gpuResources, res.name, {\n                get: function() {\n                    return gpuResources[res.name];\n                },\n                set: function(data) {\n                    gpuResources[res.name].load(data);\n                }\n            });\n        }\n        return res;\n    };\n\n    resource.link = function(program, resources) {\n        var requiredResources = (Array.isArray(resources)) ? resources : Object.keys(gpuResources);\n        requiredResources.forEach(function(resourceName) {\n            if (gpuResources.hasOwnProperty(resourceName))\n                gpuResources[resourceName].link(program);\n        })\n    };\n\n    resource.get = function(name) {\n        return gpuResources[name];\n    }\n\n    resource.create = resource.allocate;\n\n    return resource;\n};\n","export default function Shader(glContext, glResource) {\n    \n    var shader = (this instanceof Shader) ? this : {},\n        ctx = glContext,\n        resource = glResource,\n        parameters = ctx._dict || {};\n\n    shader.vertex = {};\n    shader.fragment = {};\n\n    var shaderType = {\n        vertex: ctx.VERTEX_SHADER,\n        fragment: ctx.FRAGMENT_SHADER\n    };\n\n    // Convert JS functions to GLSL codes\n    function toGLSL(returnType, name, fn){\n\n        var glsl = returnType + ' ' +\n            name + '(' + applyEnvParameters(fn.toString())\n            .replace(\n                /var\\s+([\\w|\\d]+)\\s*=\\s*new\\s+([\\w|\\d]+)\\((.*)\\)/g,\n                function(expr, name, dtype, value){\n                    var parts;\n                    if(value)\n                        parts = [dtype.toLowerCase(), name, '=', value];\n                    else\n                        parts = [dtype.toLowerCase(), name];\n\n                    return parts.join(' ')\n                }\n            )\n            .replace(/for\\s*\\(\\s*var\\s+/g, 'for(int ')\n            .replace(/(var|let)\\s/g, 'float ')\n            // .replace(/(\\.0)([^\\d])/g, '$10000000001 $2 ')\n            .replace(/this./g, '')\n            .replace(/\\$(.*)\\((.*)\\)\\s*(=|;)/g, \"$1 $2 $3\");\n            // .replace(/\\$(.*?)\\./g, \"$1 \")\n\n        if(name == \"main\") {\n            glsl = glsl.replace(/\\(.*(function|\\w).*\\(\\s*([\\s\\S]*?)\\s*{/, '(){') + \"\\n\";\n        } else {\n            var args = glsl.match(/function|\\w.*\\(\\s*([\\s\\S]*?)\\s*\\)/)[1];\n            var isObject = args.match(/{([\\s\\S]*)}/);\n            if(isObject) {\n                args = isObject[1].split(',')\n                    .map(d=>d.split('='))\n                    .map(d=> d[1].replace(/(\\'|\\\")/g, '') + ' ' + d[0])\n                    .join(', ')\n            } else if(args != \"\") {\n                args = args.replace(/\\$([\\w|\\d]+)_/g, \"$1 \");\n            }\n           \n            glsl = glsl.replace(/\\(.*(function|\\w).*\\(\\s*([\\s\\S]*?)\\s*\\)/, '(' + args+')') + \"\\n\";\n        }\n        return glsl;\n    }\n\n    //set parameters in JS functions before converting to GLSL codes\n    function applyEnvParameters(str){\n        //find all $(...) and replace them with parameters\n        var envParam = Object.keys(parameters);\n        if(envParam.length > 0){\n            var re = new RegExp(\"\\\\$\\\\((\"+envParam.join(\"|\")+\")\\\\)\",\"g\");\n            str = str.replace(re, function(matched){\n                return parameters[matched.slice(2,matched.length-1)];\n            });\n        }\n\n        // Make uniforms to be used as parameters in shaders, like $(uniformName)\n        // var envUniforms = Object.keys(resource.uniform);\n        // re = new RegExp(\"\\\\$\\\\((\"+envUniforms.join(\"|\")+\")\\\\)\",\"g\");\n        // str = str.replace(re, function(matched){\n        //     return resource.uniform[matched.slice(2,matched.length-1)].data;\n        // });\n\n        return str;\n    }\n\n    function compile(shaderType, shaderSource) {\n        if (shaderType !== ctx.VERTEX_SHADER && shaderType !== ctx.FRAGMENT_SHADER) {\n            throw (\"Error: unknown shader type\");\n        }\n        var _shader = ctx.createShader(shaderType);\n        ctx.shaderSource(_shader, shaderSource);\n        ctx.compileShader(_shader);\n\n        // Check the compile status, get compile error if any\n        var compiled = ctx.getShaderParameter(_shader, ctx.COMPILE_STATUS);\n        if (!compiled) {\n            var lastError = ctx.getShaderInfoLog(_shader);\n            console.log(shaderSource + '\\n ====================================================');\n            throw new Error(\"Error compiling shader '\" + _shader + \"':\" + lastError);\n\n            ctx.deleteShader(_shader);\n            return null;\n        }\n\n        return _shader;\n    }\n\n    function getDeps(fn) {\n        var deps = [],\n            sourceCode = fn.toString(),\n            shaderArgs = sourceCode.match(/function\\s.*?\\(([^)]*)\\)/),\n            args = (shaderArgs !== null && shaderArgs.length) ? shaderArgs[1] : [];\n        // args = args.replace(/(?:\\r\\n|\\r|\\n|\\s)/g, '');\n        //\n        if(args.length) {\n            deps = args.split(',').map(function(arg) {\n                return arg.replace(/\\/\\*.*\\*\\//, '').trim();\n            }).filter(function(arg) {\n                return arg;\n            });\n        }\n\n        var extraDeps = getExtraDeps(sourceCode);\n        if(extraDeps.length) {\n            deps = deps.concat(extraDeps\n            .filter(function(d){\n                return deps.indexOf(d) === -1;\n            }))\n        }\n\n        return deps;\n    }\n\n    function getExtraDeps(fnString) {\n        var extraDeps = fnString.match(/this\\.(\\w+)/g);\n        if(extraDeps !== null) {\n            extraDeps = extraDeps.map(function(d){\n                return d.slice(5);\n            });\n        }\n        if(extraDeps != null && extraDeps.length) {\n            extraDeps.forEach(function(sdep){\n                var sres = resource.get(sdep);\n                if(sres && sres.resourceType == 'subroutine') {\n                    extraDeps = extraDeps.concat(getExtraDeps(sres.fn.toString()));\n                }\n            });\n        }\n        return extraDeps || [];\n    }\n\n    function declareDep(dep) {\n        var res = resource.get(dep);\n        if(typeof res === 'undefined')\n            throw new Error('Resource/dependence \"' + dep + '\" is not found.');\n        if(res.resourceType == 'subroutine')\n            return toGLSL(res.type, res.name, res.fn);\n        else\n            return res.header();\n    }\n\n    function uniqueDeps(deps) {\n        var names = {};\n        deps.forEach(function(d, i){\n            names[d] = i;\n        });\n\n        return Object.keys(names);\n    }\n\n    shader.create = function(arg, fn){\n        var option = arg || {},\n            name = option.name || \"default\",\n            type = option.type || \"vertex\",\n            deps = option.require || option.deps || [],\n            precision = option.precision || \"medium\",\n            debug = option.debug || false,\n            main = option.main || fn || function() {};\n\n        var shaderSource = 'precision ' + precision + 'p float;\\n';\n\n        if(deps.length === 0) deps = uniqueDeps(getDeps(main));\n\n        //get dependence from subroutines if any\n        var extraDeps = [];\n\n        deps.forEach(function(dep){\n            var res = resource.get(dep);\n            if(typeof res == 'undefined') {\n                console.log(dep);\n                throw Error ('Error! Undefined variable in shader: '+  dep.name);\n            }\n            if(res.resourceType == 'subroutine') {\n                // subRoutines.push(res.name);\n                extraDeps  = getExtraDeps(res.fn.toString());\n                \n            }   \n        })\n\n        if(extraDeps.length) {\n            var allDeps = extraDeps.concat(deps);\n            deps = uniqueDeps(allDeps);\n        }\n\n        if(Array.isArray(deps)){\n            deps.filter(function(d){\n                return ctx.subroutineNames.indexOf(d) === -1;\n            })\n            .forEach(function(dep){\n                shaderSource += declareDep(dep);\n            });\n            var t = deps.filter(function(d){\n                return ctx.subroutineNames.indexOf(d) !== -1;\n            })\n            .reverse()\n            .forEach(function(dep){\n                shaderSource += declareDep(dep);\n            });\n\n\n\n        } else if(typeof(deps) == 'object') {\n            console.log(deps)\n            Object.keys(deps).forEach(function(resourceType){\n                deps[resourceType].forEach(function(dep){\n                    shaderSource += declareDep(dep);\n                });\n            })\n        }\n\n        shaderSource += toGLSL('void', 'main', main);\n        if(debug)\n            console.log(shaderSource);\n        var _shader = compile(shaderType[type], shaderSource);\n        _shader._shaderType = shaderType[type];\n        _shader.deps = deps;\n        _shader.source = shaderSource;\n        shader[type][name] = _shader;\n        return _shader;\n    }\n\n    return shader;\n}\n","export default function Subroutine() {\n\n    var subroutine = (this instanceof Subroutine) ? this : {};\n\n    subroutine.create = function(name, type, fn) {\n        subroutine[name] = {\n            name: name,\n            type: type || 'float',\n            fn: fn,\n            resourceType: \"subroutine\"\n        };\n\n        subroutine[name].link = function(program) {\n            return this;\n        }\n\n        subroutine[name].load = function(fn) {\n            subroutine[name].fn = fn;\n            return this;\n        }\n\n        subroutine[name].header = function() {\n            return this.fn.toString();\n        }\n\n        return subroutine[name];\n    };\n\n    return subroutine;\n}\n","import Uniform from \"./uniform\";\n\nexport default function Texture(glContext) {\n\n    var texture = (this instanceof Texture) ? this : {},\n        ctx = glContext,\n        textureID = 0;\n\n    function setTexture(name, texData) {\n        var type = ctx[texture[name].type.toUpperCase()],\n            format = ctx[texture[name].channel.toUpperCase()],\n            width = texture[name].dim[0],\n            height = texture[name].dim[1];\n\n        texture[name].data = texData;\n\n        ctx.bindTexture(ctx.TEXTURE_2D, texture[name].ptr);\n        ctx.texImage2D(ctx.TEXTURE_2D, 0, format, width, height, 0, format, type, texData);\n        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.NEAREST);\n        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.NEAREST);\n        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);\n        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);\n        ctx.bindTexture(ctx.TEXTURE_2D, null);\n    }\n\n    function updateTexture(name, texData, offset = [0, 0], dim = [texture[name].dim[0], texture[name].dim[1]] ) {\n        var type = ctx[texture[name].type.toUpperCase()],\n            format = ctx[texture[name].channel.toUpperCase()],\n            width = dim[0],\n            height = dim[1];\n\n        ctx.bindTexture(ctx.TEXTURE_2D, texture[name].ptr);\n        ctx.texSubImage2D(ctx.TEXTURE_2D, 0, offset[0], offset[1], width, height, format, type, texData);\n        ctx.bindTexture(ctx.TEXTURE_2D, null);\n    }\n\n    // TODO: Add support for texture compression\n    // function compressTexture(texData) {\n    //\n    //     var ext = (\n    //       ctx.getExtension(\"WEBGL_compressed_texture_s3tc\") ||\n    //       ctx.getExtension(\"MOZ_WEBGL_compressed_texture_s3tc\") ||\n    //       ctx.getExtension(\"WEBKIT_WEBGL_compressed_texture_s3tc\")\n    //     );\n    //\n    //     ctx.compressedTexImage2D(ctx.TEXTURE_2D, 0, ext.COMPRESSED_RGBA_S3TC_DXT3_EXT, texture[name].dim[0], texture[name].dim[1], 0, texData);\n    //     ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);\n    //     ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR);\n    // }\n\n    texture.create = function(name, type, dim, channel, data, sampler) {\n        var texIndex = (texture.hasOwnProperty(name)) ? texture[name].index : textureID++;\n        texture[name] = {\n            name: name,\n            index: texIndex,\n            type: type || \"float\",\n            dim: dim || [512, 512],\n            channel: channel || \"alpha\",\n            data: null,\n            location: null,\n            sampler: sampler || null,\n            ptr: ctx.createTexture()\n        };\n\n        // if(data !== null && data.length)\n        setTexture(name, data);\n\n        if (texture[name].sampler === null) {\n            texture[name].sampler = Uniform(ctx).create(name, 'sampler2D', texture[name]);\n        } else {\n            texture[name].sampler.data = texture[name];\n        }\n\n        texture[name].link = function(program) {\n            if (this.data !== null) {\n                // ctx.activeTexture(ctx.TEXTURE0 + this.index);\n                // ctx.bindTexture(ctx.TEXTURE_2D, this.ptr);\n                // this.location = ctx.getUniformLocation(program, this.name);\n                // ctx.uniform1i(this.location, this.index);\n                if (typeof(this.sampler.data) == 'undefined' || this.sampler.data === null)\n                    this.sampler.data = texture[name];\n\n                this.sampler.link(program);\n            }\n            return this;\n        }\n\n        texture[name].load = function(texData) {\n            setTexture(this.name, texData);\n            return this;\n        }\n\n        texture[name].copyFromFBO = function() {\n            ctx.bindTexture(ctx.TEXTURE_2D, this.ptr);\n            ctx.copyTexImage2D(\n                ctx.TEXTURE_2D,\n                0,\n                ctx.RGBA,\n                0,\n                0,\n                this.dim[0],\n                this.dim[1],\n                0\n            );\n            ctx.bindTexture(ctx.TEXTURE_2D, null);\n        }\n\n        texture[name].update = function(texData, offset, dim) {\n            updateTexture(this.name, texData, offset, dim);\n            return this;\n        }\n\n        texture[name].resize = function(dim, data) {\n            this.dim = dim;\n            setTexture(this.name, data);\n        }\n\n        texture[name].delete = function() {\n            glContext.deleteTexture(this.ptr);\n        }\n\n        texture[name].header = function() {\n            if (this.name == this.sampler.name)\n                return 'uniform sampler2D ' + this.sampler.name + ';\\n';\n            else\n                return '';\n        }\n\n        return texture[name];\n    }\n\n    return texture;\n}\n","export default function Uniform(glContext, name, type, data) {\n\n    var uniform = (this instanceof Uniform) ? this : {},\n        ctx = glContext;\n\n    function serializeArray(arrayOfArray) {\n        var sa = [];\n        arrayOfArray.forEach(function(a){\n            sa = sa.concat(a);\n        })\n        return sa;\n    }\n\n    function sanitize(data) {\n        if(Array.isArray(data)) {\n            var hasArray = data.filter(function(d){return Array.isArray(d);});\n            if(hasArray.length > 0) {\n               return serializeArray(data);\n            } else {\n                return data;\n            }\n        } else {\n            return data\n        }\n    }\n\n    function setUniform() {\n        var type = this.type,\n            location = this.location,\n            size = this.size,\n            data = this.data;\n            \n        if(Array.isArray(data)) {\n            var hasArray = data.filter(function(d){return Array.isArray(d);});\n            if(hasArray)\n                data = serializeArray(data);\n        }\n\n        if((type == 'float' || type == 'int') && !Array.isArray(data) && !ArrayBuffer.isView(data))\n            data = [data];\n\n        var buf;\n        if (type.slice(0,3) == 'vec' || type == 'float') {\n            buf = new Float32Array(data);\n            ctx['uniform' + size + 'fv'](location, buf);\n        } else if(type.slice(0,4) == 'ivec' || type == 'int'){\n            buf = new Int32Array(data);\n            ctx['uniform' + size + 'iv'](location, buf);\n        } else if(type.slice(0,3) == 'mat') {\n            buf = new Float32Array(data);\n            ctx['uniformMatrix' + size + 'fv'](location, false, buf);\n        } else if(type == 'sampler2D') {\n            if(data.hasOwnProperty('resourceType') && data.resourceType == 'texture') {\n                ctx.activeTexture(ctx.TEXTURE0 + data.index);\n                ctx.bindTexture(ctx.TEXTURE_2D, data.ptr);\n                ctx.uniform1i(location, data.index);\n            }\n        }\n    }\n\n    uniform.create = function(name, type, data) {\n\n        if(Array.isArray(data)) {\n            var hasArray = data.filter(function(d){return Array.isArray(d);});\n            if(hasArray.length > 0) {\n                data = serializeArray(data);\n            }\n        }\n\n        uniform[name] = {\n            type: type,\n            name: name,\n            data: data,\n            location: null,\n            size: parseInt(type.slice(3,4)) || parseInt(type.slice(4,5)) || 1\n        };\n\n        uniform[name].link = function(program) {\n            if(typeof this.data !== 'undefined' && this.data !== null) {\n                this.location = ctx.getUniformLocation(program, this.name);\n                setUniform.call(this);\n            }\n            return this;\n        };\n\n        uniform[name].value = function(val) {\n           this.data = sanitize(val);\n        }\n\n        uniform[name].load = function(data) {\n            this.data = data;\n            return this;\n        };\n\n        uniform[name].header = function() {\n            var header = 'uniform ' + this.type + ' ' + this.name,\n                len = 0;\n            \n            if(this.type != 'sampler2D') {\n                len = this.data.length / this.size;\n            }\n\n            //TODO: fix declaration for matrix\n            if(len > 1 && type != 'mat4') {\n                header += '[' + len + ']';\n            }\n            return header + ';\\n';\n        };\n\n        return uniform[name];\n    }\n\n\n    return uniform;\n}\n","export default function Varying(glContext) {\n\n    var varying = (this instanceof Varying) ? this : {},\n        ctx = glContext;\n\n    varying.create = function(name, type, size) {\n        varying[name] = {\n            name: name,\n            type: type || 'float',\n            size: size || 1,\n        };\n\n        varying[name].link = function() {};\n\n        varying[name].header = function() {\n            var header = 'varying ' + this.type + ' ' + this.name;\n            if(this.size > 1)\n                header += '[' + this.size + ']';\n            return header + ';\\n';\n        }\n\n        return varying[name];\n    }\n\n    return varying;\n}\n","import p4 from './src/main';\nimport cstore from './src/cstore';\nimport  * as ctypes  from './src/ctypes';\nimport * as ajax from './src/io/ajax';\nimport parse from './src/io/parse';\n\nimport Babies from './test/data-babies';\nimport TimeSeries from './test/data-timeseries';\nimport Kepler from './test/data-kepler';\n\nvar root = typeof self == 'object' && self.self === self && self ||\n           typeof global == 'object' && global.global === global && global ||\n           this;\n\np4.ajax = ajax;\np4.cstore = cstore;\np4.ctypes = ctypes;\np4.parse = parse;\np4.datasets = {Kepler, Babies, TimeSeries};\n\nroot.p4 = p4;\nexport default root.p4;\nexport const datasets = {Kepler, Babies, TimeSeries}\n","import {seqFloat} from './utils';\nimport {unique} from './arrays';\nconst vecId = ['x', 'y', 'z'];\nexport default function($p, dataProps) {\n    let data = dataProps || [];\n    $p.indexes = data.indexes || [];\n    $p.categoryIndex = data.strValues || {};\n    $p.strValues = data.strValues || {};\n    $p.strLists = data.strLists || {};\n    $p.dkeys =  data.keys || [];\n    $p.dtypes =  data.dtypes || data.types || [];\n    $p.intervals =  data.intervals || {};\n    $p.uniqueValues = data.uniqueValues;\n    $p.dataSchema = data.struct;\n\n    let dkeys = $p.dkeys;\n    let dtypes = $p.dtypes;\n    let stats =  data.stats || null;\n    \n    if (Number.isInteger(data.size)) {\n        $p.dataSize = data.size;\n    } else if (Array.isArray(data)) {\n        $p.dataSize = Math.max(...data.map(d => d.length));\n    }\n\n    let rowSize = Math.min($p.dataSize, $p.rowSize);\n    let colSize = Math.ceil($p.dataSize / rowSize);\n\n    $p.dataDimension = [rowSize, colSize];\n    $p.resultDimension = [rowSize, colSize];\n    $p.fields = $p.indexes.concat(dkeys.filter(function(k) {\n        return $p.indexes.indexOf(k) === -1;\n    }));\n    $p.fieldWidths = new Array($p.fields.length).concat(new Array($p.deriveMax).fill(1));\n    $p.fieldCount = $p.fields.length - $p.indexes.length;\n   \n    function getDataWidth(fid, range) {\n        var range = Math.abs(range[1] - range[0]);\n        if (dtypes[fid] == \"index\" || dtypes[fid] == \"int\" || dtypes[fid] == \"string\") {\n            return range + 1;\n        } else if (dtypes[fid] == \"histogram\") {\n            return range + 1;\n        } else if ([\"nominal\", \"ordinal\", \"categorical\"].indexOf(dtypes[fid]) > -1) {\n            return data.TLB.length;\n        } else if (dtypes[fid] in [\"float\", \"double\", \"numeric\"]) {\n            return 10;\n        } else {\n            return range + 1;\n        }\n    }\n    $p.fields.forEach(function(field) {\n        var min = stats[field].min,\n            max = stats[field].max,\n            fi = dkeys.indexOf(field);\n        $p.fieldWidths[fi] = getDataWidth(fi, [min, max]);\n    });\n    $p.getDataWidth = getDataWidth;\n    $p.deriveDomains = new Array($p.deriveMax).fill([0, 1]);\n    $p.deriveWidths = new Array($p.deriveMax).fill(1);\n    $p.deriveFieldCount = 0;\n\n    $p.getFieldId = function (fieldName) {\n        let fieldId = $p.fields.indexOf(fieldName);\n        if($p.indexes.length > 0 && fieldId >= $p.indexes.length) {\n            fieldId -= $p.indexes.length; \n        }\n        return fieldId; \n    }\n\n    if ($p.indexes.length === 0) {\n        $p.attribute(\"aDataIdx\", \"float\", seqFloat(0, $p.dataDimension[0] - 1));\n        $p.attribute(\"aDataIdy\", \"float\", seqFloat(0, $p.dataDimension[1] - 1));\n        $p.attribute(\"aDataValx\", \"float\", seqFloat(0, $p.dataDimension[0] - 1));\n        $p.attribute(\"aDataValy\", \"float\", seqFloat(0, $p.dataDimension[1] - 1));\n    } else {\n        $p.indexes.forEach(function(id, i) {\n            let indexAttrData = unique(data[id]).sort( (a, b) => b - a );\n            $p.attribute(\"aDataVal\" + vecId[i], \"float\", new Float32Array(indexAttrData));\n            $p.attribute(\"aDataId\" + vecId[i], \"float\", seqFloat(0, indexAttrData.length - 1));\n            $p.fieldWidths[i] = indexAttrData.length;\n            $p.dataDimension[i] = indexAttrData.length;\n        });\n    }\n\n    $p.attribute(\"aDataItemVal0\", \"float\", null);\n    $p.attribute(\"aDataItemVal1\", \"float\", null);\n    $p.attribute(\"aDataItemId\", \"float\", new Float32Array($p.dataSize).map((d,i)=>i));\n    $p.attribute(\"aDataFieldId\", \"vec2\", new Float32Array($p.fields.length * 2).map((d,i)=>i));\n    $p.attribute(\"aVertexId\", \"float\", [0, 1, 2, 3, 4, 5]);\n    $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aVertexId.location, 0);\n    $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataFieldId.location, 0);\n    $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataItemId.location, 1);\n\n    $p.attribute(\n        \"_square\",\n        \"vec2\",\n        new Float32Array([\n            -1.0, -1.0, 1.0, -1.0, \n            -1.0, 1.0, -1.0, 1.0,\n            1.0, -1.0, 1.0, 1.0\n        ])\n    );\n    $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute._square.location, 1);\n\n    //TODO: get data statistics using the GPU\n    if(stats !== null) {\n        $p.fieldDomains = $p.fields.map(function(k, i) {\n            return [stats[k].min, stats[k].max];\n        }).concat(new Array($p.deriveMax).fill([0, 1]));\n        $p.uniform(\"uFieldDomains\", \"vec2\",  $p.fieldDomains);\n    } else {\n        $p.uniform(\"uFieldDomains\", \"vec2\",  $p.fields.map(f => [0, 1]));\n    }\n\n    let filterControls = new Array($p.fieldCount).fill(0);\n    //setup all attribute, uniform, texture, varying needed by all the shaders\n    $p.uniform(\"uDataSize\",    \"float\", $p.dataSize);\n    $p.uniform(\"uDataDim\",     \"vec2\",  $p.dataDimension);\n    $p.uniform(\"uResultDim\",   \"vec2\",  $p.dataDimension);\n    $p.uniform(\"uIndexCount\",  \"int\",   $p.indexes.length);\n    $p.uniform(\"uFieldWidths\", \"float\", $p.fieldWidths);\n    $p.uniform(\"uFieldCount\",  \"int\",   $p.fieldCount);\n    $p.uniform(\"uFieldId\",     \"int\",   0);\n    $p.uniform(\"uFilterFlag\",  \"int\",   0);\n    $p.uniform(\"uFilterControls\",\"int\", filterControls)\n    $p.uniform(\"uVisControls\",\"int\", filterControls);\n    $p.uniform(\"uFilterRanges\",\"vec2\", $p.fieldDomains);\n    $p.uniform(\"uVisRanges\",\"vec2\", $p.fieldDomains);\n    // $p.uniform(\"uGroupFields\", \"int\",   [0, -1]);\n    $p.uniform(\"uDataInput\",   \"sampler2D\");\n    $p.uniform(\"uDeriveCount\", \"int\", $p.deriveMax);\n    // $p.uniform(\"uDeriveDomains\", \"vec2\", $p.deriveDomains);\n    // $p.uniform(\"uDeriveWidths\", \"float\", $p.deriveWidths);\n    $p.uniform(\"uFilterLevel\", \"float\", 0.1)\n    $p.uniform('uVisLevel',    \"float\", 0.1)\n\n    $p.varying(\"vResult\", \"float\");\n    $p.varying(\"vDiscardData\", \"float\");\n    $p.texture(\n        \"tData\",\n        \"float\",\n        new Float32Array($p.dataDimension[0] * $p.dataDimension[1] * $p.fieldCount), [$p.dataDimension[0], $p.dataDimension[1] * $p.fieldCount],\n        \"alpha\"\n    );\n    $p.framebuffer(\"fFilterResults\", \"unsigned_byte\", $p.dataDimension);\n    $p.framebuffer(\"fGroupResults\", \"float\", [1024, 1]);\n    $p.framebuffer(\"fDerivedValues\", \"float\", [$p.dataDimension[0], $p.dataDimension[1] * $p.deriveMax]);\n    $p.framebuffer(\"fStats\", \"float\", [2, $p.fieldCount]);\n    $p.parameter({\n        fieldCount: $p.fields.length - $p.indexes.length,\n        indexCount: $p.indexes.length\n    });\n\n    $p.fields.slice($p.indexes.length).forEach(function(attr, ai) {\n        let buf = new Float32Array($p.dataDimension[0] * $p.dataDimension[1]);\n        for (let i = 0, l = data[attr].length; i < l; i++) {\n            buf[i] = data[attr][i];\n        }\n\n        $p.texture.tData.update(\n            buf, [0, $p.dataDimension[1] * ai], $p.dataDimension\n        );\n    });\n\n    // $p.texture.tData.sampler = $p.uniform.uDataInput;\n    $p.uniform.uDataInput = $p.texture.tData;\n\n    function getFieldWidth({fid = 'int'}) {\n        return this.uFieldWidths[fid];\n    }\n\n    function getFieldDomain({fid = 'int'}) {\n        return this.uFieldDomains[fid];\n    }\n\n    function getData({fid = 'int', r = 'float', s = 'float'}) {\n        var t, value;\n        if (fid >= this.uFieldCount + this.uIndexCount) {\n            t = (float(fid - this.uFieldCount - this.uIndexCount) + s) /\n                float(this.uDeriveCount);\n            value = texture2D(this.fDerivedValues, vec2(r, t)).a;\n        } else {\n            if (this.uIndexCount > 0 && fid == 0) value = this.aDataValx;\n            else if (this.uIndexCount > 1 && fid == 1) value = this.aDataValy;\n            else {\n                t = (float(fid - this.uIndexCount) + s) / float(this.uFieldCount);\n                value = texture2D(this.uDataInput, vec2(r, t)).a;\n            }\n        }\n        return value;\n    }\n\n    function getNonIndexedData({fieldId = 'int', addrX = 'float', addrY = 'float'}) {\n        var offsetY, value;\n        if (fieldId >= this.uFieldCount + this.uIndexCount) {\n            offsetY = (float(fieldId - this.uFieldCount - this.uIndexCount) + addrY) /\n                float(this.uDeriveCount);\n            value = texture2D(this.fDerivedValues, vec2(addrX, offsetY)).a;\n        } else {\n            offsetY = (float(fieldId - this.uIndexCount) + addrY) / float(this.uFieldCount);\n            value = texture2D(this.uDataInput, vec2(addrX, offsetY)).a;\n        }\n        return value;\n    }\n\n    $p.subroutine(\"getFieldWidth\", \"float\", getFieldWidth);\n    $p.subroutine(\"getFieldDomain\", \"vec2\", getFieldDomain);\n    $p.subroutine(\"getData\", \"float\", getData);\n    $p.subroutine(\"getNonIndexedData\", \"float\", getNonIndexedData);\n\n    var gl = $p.ctx;\n    gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdx.location, 0);\n    gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataValx.location, 0);\n    gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdy.location, 1);\n    gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataValy.location, 1);\n\n}\n","function _reduce(array, opt) {\n    var i,\n        len = array.length,\n        fn,\n        result;\n\n    if (!len) return 0;\n\n    switch (opt) {\n        case \"max\":\n            result = array.reduce(function(a, b) {\n                return (a > b) ? a : b;\n            });\n            break;\n        case \"min\":\n            result = array.reduce(function(a, b) {\n                return (a < b) ? a : b;\n            });\n            break;\n        case \"and\":\n        case \"&\":\n            result = array.reduce(function(a, b) {\n                return a & b;\n            });\n            break;\n        case \"or\":\n        case \"|\":\n            result = array.reduce(function(a, b) {\n                return a | b;\n            });\n            break;\n        case \"mult\":\n        case \"*\":\n            result = array.reduce(function(a, b) {\n                return a * b;\n            });\n            break;\n        default: // \"sum\" or \"+\"\n            result = array.reduce(function(a, b) {\n                return a + b;\n            });\n            break;\n    }\n\n    return result;\n}\n\nexport function reduce(opt) {\n    return function(array) {\n        var a = (array instanceof Array) ? array : Array.apply(null, arguments);\n        return _reduce(a, opt);\n    };\n};\n\nexport function avg(array) {\n    return _reduce(array, \"+\") / array.length;\n    // return array.reduce(function(a,b){ return 0.5 * (a + b)});\n};\n\nexport function normalize(array) {\n    var max = _reduce(array, \"max\"),\n        min = _reduce(array, \"min\"),\n        range = max - min;\n\n    return array.map(function(a) {\n        return (a - min) / range;\n    });\n}\n\nexport function seq(start, end, intv) {\n    var interval = intv || 1,\n        array = [];\n\n    for (var i = start; i <= end; i += interval)\n        array.push(i);\n\n    return array;\n};\n\n// [\"max\", \"min\", \"mult\", \"and\", \"or\"].forEach(function(f) {\n//     array[f] = array.reduce(f);\n// });\n\n// export sum = array.reduce(\"+\");\n\nexport function scan(a) {\n    var pfsum = [],\n        accum = 0;\n\n    for (var i = 0; i < a.length; i++) {\n        accum += a[i];\n        pfsum.push(accum);\n    }\n\n    return pfsum;\n};\n\nexport function iscan(a) {\n    return array.scan([0].concat(a));\n};\n\nexport function diff(a, b) {\n    var difference = [];\n    a.forEach(function(d) {\n        if (b.indexOf(d) === -1) {\n            difference.push(d);\n        }\n    });\n    return difference;\n};\n\nexport function intersect(a, b) {\n    var t;\n    if (b.length > a.length) t = b, b = a, a = t; // indexOf to loop over shorter\n    return a.filter(function(e) {\n        if (b.indexOf(e) !== -1) return true;\n    });\n};\n\nexport function unique(a) {\n    return a.reduce(function(b, c) {\n        if (b.indexOf(c) < 0) b.push(c);\n        return b;\n    }, []);\n};\n\nexport function lcm(A) {\n    var n = A.length,\n        a = Math.abs(A[0]);\n    for (var i = 1; i < n; i++) {\n        var b = Math.abs(A[i]),\n            c = a;\n        while (a && b) {\n            (a > b) ? a %= b: b %= a;\n        }\n        a = Math.abs(c * A[i]) / (a + b);\n    }\n    return a;\n};\n\nexport function stats(array) {\n    return {\n        max: _reduce(array, \"max\"),\n        min: _reduce(array, \"min\"),\n        avg: array.avg(array)\n    };\n};\n\nexport function histogram(array, numBin, _max, _min) {\n    var l = array.length,\n        min = (typeof(_min) == 'number') ? _min : _reduce(array, \"min\"),\n        max = (typeof(_max) == 'number') ? _max : _reduce(array, \"max\"),\n        range = max - min,\n        interval = range / numBin,\n        bins = [],\n        // ids = [],\n        hg = new Array(numBin + 1).fill(0);\n\n    for (var b = 0; b < numBin; b++) {\n        bins.push([min + range * (b / (numBin)), min + range * (b + 1) / (numBin)]);\n        // ids[b] = [];\n    }\n\n    // ids[numBin] = [];\n\n    for (var i = 0; i < l; i++) {\n        binID = Math.floor((array[i] - min) / range * (numBin));\n        hg[binID]++;\n        // ids[binID].push(i);\n    };\n\n    hg[numBin - 1] += hg[numBin];\n    // ids[numBin-1] = ids[numBin-1].concat(ids.pop());\n    return {\n        bins: bins,\n        counts: hg.slice(0, numBin),\n        // ids: ids\n    };\n}\n\nexport function variance(rowArray) {\n    var m = _reduce(rowArray, \"+\") / rowArray.length,\n        va = rowArray.map(function(a) {\n            return Math.pow(a - m, 2)\n        });\n\n    return _reduce(va, \"+\") / (rowArray.length - 1);\n}\n\nexport function std(rowArray) {\n    return Math.sqrt(variance(rowArray));\n}\n\nexport function vectorAdd(a, b) {\n    var c = [];\n    a.forEach(function(v, i) {\n        c[i] = v + b[i];\n    });\n\n    return c;\n}\n\nexport function vectorSum(vectors) {\n    var result = vectors[0],\n        numberOfVectors = vectors.length;\n\n    for (var i = 1; i < numberOfVectors; i++) {\n        result = array.vectorAdd(result, vectors[i]);\n    }\n\n    return result;\n}\n\nfunction _vectorAvg(a, b) {\n    var c = [];\n    a.forEach(function(v, i) {\n        c[i] = (v + b[i]) * 0.5;\n    });\n\n    return c;\n}\n\nexport function vectorAvg(vectors) {\n    var result = vectors[0],\n        numberOfVectors = vectors.length;\n\n    for (var i = 1; i < numberOfVectors; i++) {\n        result = _vectorAvg(result, vectors[i]);\n    }\n\n    return result;\n}\n","import aggregate  from './ops/aggregate';\nimport cache      from './ops/cache.gl';\nimport derive     from './ops/derive';\nimport extent     from './ops/extent.gl';\nimport match      from './ops/match';\nimport visualize  from './vis/visualize';\nimport reveal     from './vis/reveal';\n\nexport default function compile($p, fields, spec) {\n\n    // if(spec.hasOwnProperty('perceptual'))\n    //     operations.perceptual = kernels.perceptual($p);\n    //\n    // if(spec.hasOwnProperty('derive'))\n    //     operations.derive = kernels.derive($p, spec.derive);\n\n    return {\n        aggregate : aggregate($p),\n        cache     : cache($p),\n        match     : match($p, fields),\n        extent    : extent($p),\n        visualize : visualize($p)\n    }\n}\n","export default function ($p) {\n\n    let registers = {};\n    let control = {};\n\n    let serializeArray = function(arrayOfArray) {\n        return [].concat.apply([], arrayOfArray);\n    }\n\n    control.register = function(tag) {\n        registers[tag] = {\n            indexes: $p.indexes.slice(),\n            dataSize: $p.dataSize,\n            fields: $p.fields.slice(),\n            fieldCount: $p.fieldCount,\n            dataDim: $p.uniform.uDataDim.data.slice(),\n            fieldWidths: $p.fieldWidths.slice(),\n            fieldDomains: $p.fieldDomains.slice(),\n            deriveCount: $p.deriveCount,\n            filterFlag: $p.uniform.uFilterFlag.data,\n            filterControls: $p.uniform.uFilterControls.data.slice(),\n            dataInput: $p.uniform.uDataInput.data,\n            resultDim: $p.resultDimension.slice(),\n            attribute: {\n                aDataIdx: {\n                    ids: $p.attribute.aDataIdx.data,\n                    value: $p.attribute.aDataValx.data\n                },\n                aDataIdy: {\n                    ids: $p.attribute.aDataIdy.data,\n                    value: $p.attribute.aDataValy.data\n                },\n                aDataFieldId: $p.attribute.aDataFieldId.data,\n                aDataItemId: $p.attribute.aDataItemId.data\n            },\n            extraDim: $p.extraDimension\n        }\n        return control;\n    }\n\n    control.updateRegister = function(tag, props) {\n        if(registers.hasOwnProperty(tag)) {\n            Object.keys(props).forEach(k => {\n                registers[tag][k] = props[k];\n            })\n        }\n        return control;\n    }\n    \n    control.resume = function(tag) {\n        if (!registers.hasOwnProperty(tag))\n            throw new Error('\"' + tag + '\" is not found in regesters.');\n    \n        var reg = registers[tag];\n        //resume CPU registers\n        $p.indexes = reg.indexes;\n        $p.dataSize = reg.dataSize;\n        $p.deriveCount = reg.deriveCount;\n        $p.fieldCount = reg.fieldCount;\n        $p.fields = reg.fields.slice();\n        $p.fieldWidths = reg.fieldWidths.slice();\n        $p.fieldDomains = reg.fieldDomains.slice();\n        $p.dataDimension = reg.dataDim.slice();\n        $p.resultDimension = reg.resultDim.slice();\n        $p.extraDimension = reg.extraDim;\n        //resume GPU Uniforms\n        $p.uniform.uFieldCount.data = $p.fieldCount;\n        $p.uniform.uDataSize.data = $p.dataSize;\n        $p.uniform.uDataDim.data = reg.dataDim;\n        $p.uniform.uIndexCount.data = reg.indexes.length;\n        $p.uniform.uFieldDomains.data = serializeArray(reg.fieldDomains);\n        $p.uniform.uFieldWidths.data = reg.fieldWidths;\n        $p.uniform.uFilterFlag.data = reg.filterFlag;\n        // $p.uniform.uFilterControls.data = reg.filterControls;\n        $p.uniform.uDataInput.data = reg.dataInput;\n    \n        //resume GPU Attribute Buffers\n        $p.attribute['aDataIdx'] = reg.attribute['aDataIdx'].ids;\n        $p.attribute['aDataIdy'] = reg.attribute['aDataIdy'].ids;\n        $p.attribute['aDataValx'] = reg.attribute['aDataIdx'].value;\n        $p.attribute['aDataValy'] = reg.attribute['aDataIdy'].value;\n        $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute['aDataIdx'].location, 0);\n        $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute['aDataIdy'].location, 1);\n        $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute['aDataValx'].location, 0);\n        $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute['aDataValy'].location, 1);\n    \n        $p.attribute['aDataFieldId'] = reg.attribute['aDataFieldId'];\n        $p.attribute['aDataItemId'] = reg.attribute['aDataItemId'];\n    \n        return control;\n    }\n\n    // control.head = function() {\n    //     control.resume('__init__');\n    //     return control;\n    // }\n\n    var branchID = 0;\n    control.branch = function(branches) {\n        branches.forEach(function(b){\n            var operations = Object.keys(b).map(function(o) {\n                var obj = {};\n                obj[o] = b[o];\n                return obj;\n            });\n            control.run(operations);\n            control.resume('_branch' + branchID);\n        })\n        branchID++;\n\n        return control;\n    }\n\n    return control;\n}\n","import * as ctypes from './ctypes';\r\nimport {unique} from './arrays';\r\n\r\nconst __VERSION__ = 1.0;\r\n\r\nexport default function ColumnStore(arg){\r\n    var cstore     = (this instanceof ColumnStore) ? this : {},\r\n        options    = arg || {},\r\n        columns    = [],                  // column-based binary data\r\n        size       = options.size  || 0,   // max size\r\n        count      = options.count || 0,   // number of entries stored\r\n        types      = options.types || [],  // types of the columns\r\n        attributes = options.attributes || options.keys || options.names || [],  // column attributes\r\n        struct     = options.struct || options.schema || null,\r\n        strValues  = options.strValues || {},  // string values \r\n        strLists   = options.strLists  || {},  // table lookaside buffer\r\n        intervals  = {},\r\n        indexes    = options.indexes || {},\r\n        colStats   = {},\r\n        colAlloc   = {},\r\n        colRead    = {},                  // functions for reading values\r\n        skip       = options.skip  || 0;\r\n\r\n    if(typeof(struct) === 'object') initStruct(struct);\r\n\r\n    function initCStore() {\r\n        if(size && types.length === attributes.length && types.length > 0) {\r\n            attributes.forEach(function(c, i){\r\n                configureColumn(i);\r\n                columns[i] = new colAlloc[c](size);\r\n                if(!columns.hasOwnProperty(c)) {\r\n                    Object.defineProperty(columns, c, {\r\n                        get: function() { return columns[i]; }\r\n                    });\r\n                }\r\n                if(intervals.hasOwnProperty(c)) {\r\n                    cstore.intervalize(c, intervals[c]);\r\n                }\r\n\r\n                if(strValues[c] && Object.keys(strValues[c]).length > 0) {\r\n                    strLists[c] = Object.keys(strValues[c]);\r\n                }\r\n\r\n            });\r\n            columns.attributes = attributes;\r\n            columns.keys = attributes;\r\n            columns.types = types;\r\n            columns.struct = struct;\r\n            columns.strLists = strLists;\r\n            columns.strValues = strValues;\r\n            columns.uniqueValues = indexes;\r\n            columns.size = size;\r\n            columns.get = function(c) {\r\n                var index = attributes.indexOf(c);\r\n                if(index < 0 ) throw new Error(\"Error: No column named \" + c);\r\n                return columns[index];\r\n            }\r\n        } \r\n        return cstore;\r\n    }\r\n\r\n    function initStruct(s) {\r\n        struct = s;\r\n        if(Array.isArray(struct)) {\r\n            struct.forEach(function(s){\r\n                attributes.push(s.name);\r\n                types.push(s.type || s.dtype);\r\n            })\r\n        } else {\r\n            for(var k in struct){\r\n                attributes.push(k);\r\n                types.push(struct[k]);\r\n            }\r\n        }\r\n        return struct;\r\n    }\r\n\r\n    function configureColumn(cid) {\r\n        if(typeof(cid) == \"string\") cid = attributes.indexOf(cid);\r\n        var f = attributes[cid];\r\n        colAlloc[f] = ctypes[types[cid]];\r\n        var columnType = types[cid]\r\n        if(columnType === 'string' || columnType === 'str'){\r\n            if (!strValues.hasOwnProperty(f)) {\r\n                strValues[f] = {};\r\n                strLists[f] = [];\r\n            }\r\n            colRead[f] = function(value) {\r\n                if(!strValues[f].hasOwnProperty(value)){\r\n                    strValues[f][value] = strLists[f].length;\r\n                    strLists[f].push(value);\r\n                }\r\n                return strValues[f][value];\r\n            };\r\n        } else if(['int', 'short', 'integer'].includes(columnType)) {\r\n            colRead[f] = function(value) { return parseInt(value) || 0; };\r\n        } else if(['float', 'double', 'numeric'].includes(columnType)){\r\n            colRead[f] = function(value) { return parseFloat(value) || 0.0; };\r\n        } else if(['date', 'time', 'datetime'].includes(columnType)){\r\n            colRead[f] = function(value) { \r\n                let datetime = new Date(value);\r\n                let ts = datetime.getTime() / 1000 - datetime.getTimezoneOffset() * 60; \r\n                return Math.floor(ts);\r\n            };\r\n        } else {\r\n            throw new Error(\"Invalid data type for TypedArray data!\")\r\n        }\r\n    }\r\n\r\n    cstore.addRows = function(rowArray) {\r\n        if(size === 0) {\r\n            size = rowArray.length;\r\n            initCStore();\r\n        }\r\n        if(count === 0 && skip > 0) {\r\n            for(var j = 0; j<skip; j++)\r\n                rowArray.shift();\r\n        }\r\n        rowArray.forEach(function(row, i){\r\n            row.forEach(function(v,j){\r\n                columns[j][count] = colRead[attributes[j]](v);\r\n            });\r\n            count++;\r\n        });\r\n\r\n        return count;\r\n    }\r\n\r\n    cstore.addObjects = function(objArray) {\r\n        if(count === 0 && skip > 0) {\r\n            for(var j = 0; j<skip; j++)\r\n                objArray.shift();\r\n        }\r\n        objArray.forEach(function(obj, i){\r\n            Object.keys(obj).forEach(function(v,j){\r\n                if(typeof colRead[attributes[j]] !== 'function') {\r\n                    console.log(attributes[j], j, v, obj)\r\n                }\r\n                columns[j][count] = colRead[attributes[j]](obj[v]);\r\n            });\r\n            count++;\r\n        });\r\n        return count;\r\n    }\r\n\r\n    cstore.addColumn = function(arg) {\r\n        var props = arg || {},\r\n            columnData = props.data || props.array,\r\n            columnName = props.name,\r\n            columnType = props.dtype,\r\n            values = props.values || [];\r\n\r\n        var cid = attributes.indexOf(columnName);\r\n        if( cid < 0) {\r\n            attributes.push(columnName);\r\n            types.push(columnType);\r\n            configureColumn(columnName);\r\n            cid = types.length - 1;\r\n            Object.defineProperty(columns, columnName, {\r\n                get: function() { return columns[cid]; }\r\n            });\r\n        }\r\n\r\n        if(columnData instanceof ctypes[types[cid]]) {\r\n            columns[cid] = columnData;\r\n            if(values.length) {\r\n                strLists[columnName] = values;\r\n                strValues[columnName] = {};\r\n                values.forEach(function(value, vi){\r\n                    strValues[columnName][value] = vi;\r\n                })\r\n            }\r\n        } else if(ArrayBuffer.isView(columnData)){\r\n            columns[cid] = new colAlloc[columnName](size);\r\n            for(var di = 0; di < size; di++) {\r\n                columns[cid][di] = colRead[columnName](columnData[di]);\r\n            }\r\n        } else {\r\n            throw new Error(\"Error: Invalid data type for columnArray!\");\r\n        }\r\n        size = count = columnData.length;\r\n    }\r\n\r\n    cstore.metadata = cstore.info = function() {\r\n        return {\r\n            size: size,\r\n            count: count,\r\n            attributes: attributes,\r\n            types: types,\r\n            strLists: strLists,\r\n            strValues: strValues,\r\n            stats: cstore.stats()\r\n        }\r\n    }\r\n\r\n    cstore.columns = function() {\r\n        return columns;\r\n    }\r\n\r\n    cstore.data = function() {\r\n        var data = columns;\r\n        data.stats = cstore.stats();\r\n        data.keys = attributes;\r\n        data.size = size;\r\n        data.strValues = strValues;\r\n        data.strLists = strLists;\r\n        data.dtypes = types;\r\n        data.export = cstore.export;\r\n        data._p4_cstore_version = __VERSION__;\r\n        return data;\r\n    }\r\n\r\n    cstore.stats = function(col){\r\n        var col = col || attributes;\r\n        col.forEach(function(name, c){\r\n            if(!colStats[c]){\r\n                var min, max, avg;\r\n                min = max = avg = columns[c][0];\r\n\r\n                for(var i = 1; i < columns[c].length; i++){\r\n                    var d = columns[c][i];\r\n                    if(d > max) max = d;\r\n                    else if(d < min) min = d;\r\n                    avg = avg - (avg-d) / i;\r\n                }\r\n                if(max == min) max += 0.000001;\r\n                colStats[name] = {min: min, max: max, avg: avg};\r\n            }\r\n        })\r\n        return colStats;\r\n    }\r\n\r\n    cstore.domains = function(col){\r\n        var col = col || attributes,\r\n            domains = [];\r\n\r\n        col.forEach(function(name, c){\r\n            domains[name] = [colStats[name].min, colStats[name].max];\r\n        })\r\n        return domains;\r\n    }\r\n\r\n    cstore.ctypes = function() {\r\n        return ctypes;\r\n    }\r\n\r\n    cstore.size = size;\r\n\r\n    cstore.exportAsJSON = function() {\r\n        var rows = new Array(size);\r\n        for(var ri = 0; ri < size; ri++) {\r\n            var dataFrame = {};\r\n            attributes.forEach(function(attr, ai) {\r\n                if(types[ai] == 'string') {\r\n                    dataFrame[attr] = strLists[attr][columns[ai][ri]];\r\n                } else if(indexes.hasOwnProperty(attr)) {\r\n                    dataFrame[attr] = indexes[attr][columns[ai][ri]];\r\n                } else {\r\n                    dataFrame[attr] = columns[ai][ri];\r\n                }\r\n            })\r\n            rows[ri] = dataFrame;\r\n        }\r\n        return rows;\r\n    }\r\n\r\n    cstore.exportAsRowArray = function() {\r\n        var rows = new Array(size);\r\n        for(var ri = 0; ri < size; ri++) {\r\n            var row = new Array(attributes.length);\r\n            attributes.forEach(function(attr, ai) {\r\n                if(types[ai] == 'string') {\r\n                    row[ai] = strLists[attr][columns[ai][ri]];\r\n                } else if(indexes.hasOwnProperty(attr)) {\r\n                    row[ai] = indexes[attr][columns[ai][ri]];\r\n                } else {\r\n                    row[ai] = columns[ai][ri];\r\n                }\r\n            })\r\n            rows[ri] = row;\r\n        }\r\n        return rows;\r\n    }\r\n\r\n    cstore.export = function(arg) {\r\n        var format = arg || 'json';\r\n        if(format == 'rowArray') {\r\n            return cstore.exportAsRowArray();\r\n        } else {\r\n            return cstore.exportAsJSON();\r\n        }\r\n    }\r\n\r\n    cstore.import = function({\r\n        data,\r\n        schema = null,\r\n        type = 'json'\r\n    }) {\r\n        size = data.length;\r\n        if(typeof(schema == 'object')) initStruct(schema);\r\n        initCStore();\r\n        if(type === 'json') {\r\n            cstore.addObjects(data);\r\n        } else {\r\n            cstore.addRows(data);\r\n        }\r\n        \r\n        return cstore;\r\n    }\r\n\r\n    cstore.scale = function(attr, factor) {\r\n        let len = columns[attr].length;\r\n        for(var i = 0; i < len; i++) {\r\n            columns[attr] *= factor;\r\n        }\r\n        return cstore;\r\n    }\r\n\r\n    cstore.normalize = function(attr) {\r\n        if(!colStats.hasOwnProperty(attr)) {\r\n            cstore.stats();\r\n        }\r\n        let fid = attributes.indexOf(attr);\r\n        let len = columns[attr].length;\r\n        let max = colStats[f].max;\r\n        let min = colStats[f].min;\r\n\r\n        if(types[fid] === 'float') {\r\n            for(var i = 0; i < len; i++) {\r\n                columns[attr][i] = (columns[attr][i] - min) / (max - min);\r\n            }\r\n        } \r\n        return cstore;\r\n    }\r\n\r\n    cstore.intervalize = function(attr, interval) {\r\n        intervals[attr] = interval;\r\n        if(!colStats.hasOwnProperty(attr)) {\r\n            cstore.stats([attr]);\r\n        }\r\n        let fid = attributes.indexOf(attr);\r\n        let len = columns[attr].length;\r\n        let min = colStats[f].min;\r\n\r\n        if(types[fid] === 'int' || types[fid] === 'float') {\r\n            for(var i = 0; i < len; i++) {\r\n                columns[attr][i] = (columns[attr][i] - min) / interval;\r\n            }\r\n        } \r\n        return cstore;\r\n    }\r\n\r\n    cstore.index = function(attr) {\r\n        let attrId = attributes.indexOf(attr);\r\n        if(attrId === -1) throw Error('Invalid attribute for indexing');\r\n        types[attrId] = 'int';\r\n        indexes[attr] = unique(columns[attr]).sort(function(a, b) {\r\n            return a - b;\r\n        });\r\n        let len = columns[attr].length;\r\n        for(var i = 0; i < len; i++) {\r\n            columns[attr][i] = indexes[attr].indexOf(columns[attr][i]); \r\n        }\r\n        \r\n        return cstore;\r\n    }\r\n\r\n    return initCStore();\r\n}\r\n","const int      = Int32Array;\nconst short    = Int16Array;\nconst float    = Float32Array;\nconst double   = Float64Array;\nconst string   = Uint16Array;\nconst time     = Float32Array;\nconst datetime = Float32Array;\nconst temporal = Float32Array;\nconst integer  = Int32Array;\nconst numeric  = Float32Array;\nconst nominal  = Uint16Array;\n\nexport {\n    int,\n    short,\n    float,\n    double,\n    string,\n    time,\n    datetime,\n    temporal,\n    integer,\n    numeric,\n    nominal\n};\n","import { vis } from 'p3.js';\n// import animation from '../src/animate';\n\nexport default [\n    {\n        name: 'spline',\n        exportData: true,\n        skipDefault: true,\n        getContext: false,\n        restartOnUpdate: false,\n        compute: true,\n        condition: vmap => vmap.mark === 'spline', \n        type: 'class',\n        function: vis.Spline\n    },\n    {\n        name: 'area',\n        exportData: true,\n        skipDefault: true,\n        getContext: false,\n        restartOnUpdate: false,\n        condition: vmap => vmap.mark === 'area', \n        type: 'class',\n        function: vis.AreaChart\n    },\n    {\n        name: 'column',\n        exportData: true,\n        skipDefault: true,\n        getContext: false,\n        restartOnUpdate: false,\n        condition: vmap => vmap.mark === 'column', \n        type: 'class',\n        function: vis.BarChart\n    },\n    // {\n    //     name: 'animate',\n    //     // exportData: true,\n    //     skipDefault: true,\n    //     getContext: true,\n    //     restartOnUpdate: false,\n    //     condition: vmap => vmap.mark === 'circle' && vmap.animate === true, \n    //     function: animation\n    // }\n]\n","export const Aggregate = {\n  vertexShader() {\n    gl_PointSize = 1.0;\n\n    var i, j;\n    var groupKeyValue;\n\n    i = (this.aDataIdx + 0.5) / this.uDataDim.x;\n    j = (this.aDataIdy + 0.5) / this.uDataDim.y;\n\n    if (this.aDataIdy * this.uDataDim.x + this.aDataIdx >= this.uDataSize) {\n        this.vResult = 0.0;\n    } else {\n        if(this.uAggrOpt != 2.0) {\n            this.vResult = this.getData(this.uFieldId, i, j);\n        } else {\n            this.vResult = 1.0;\n        }\n    }\n\n    if (this.uFilterFlag == 1) {\n        if (texture2D(this.fFilterResults, vec2(i, j)).a < this.uVisLevel - 0.01) {\n            this.vResult = 0.0;\n        }\n    }\n\n    var pos = new Vec2();\n    for (var ii = 0; ii < 2; ii++) {\n        var gid = new Int();\n        gid = this.uGroupFields[ii];\n        if (gid != -1) {\n            if (this.uIndexCount > 0) {\n                if (gid == 0) {\n                    groupKeyValue = i;\n                } else if (gid == 1) {\n                    groupKeyValue = j;\n                }\n            }\n            if (this.uIndexCount == 0 || gid > 1) {\n                var d = new Vec2();\n                var w = this.getFieldWidth(gid);\n                var value = this.getData(gid, i, j);\n\n                d = this.getFieldDomain(gid);\n\n                if(this.uBinCount[ii] > 0) {\n                    value = max(ceil((value - d[0]) / this.uBinIntervals[ii]), 1.0);\n                    groupKeyValue = value / float(this.uBinCount[ii]);\n                } else {\n                    groupKeyValue = (value - d.x) / (d.y - d.x) * w / (w + 1.0);\n                    groupKeyValue += 0.5 / w;\n                }\n            }\n            pos[ii] = groupKeyValue * 2.0 - 1.0;\n        } else {\n            pos[ii] = 0.5;\n        }\n    }\n\n    if(this.uGroupFields[2] != -1) {\n        var keyValue = this.getData(this.uGroupFields[2], i, j);\n        if(keyValue != this.uExtraKeyValue) {\n            this.vResult = 0.0;\n        }\n    }\n\n    gl_Position = vec4(pos, 0.0, 1.0);\n  },\n\n  fragmentShader() {\n    if (this.vResult == 0.0) discard;\n    if (this.uAggrOpt == 2.0)\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    else\n        gl_FragColor = vec4(0.0, 0.0, 1.0, this.vResult);\n  }\n}\n\nexport const GetStats = {\n  vertexShader() {\n    gl_Position = vec4(this._square, 0, 1);\n  },\n\n  fragmentShader() {\n    var x, y, res;\n    $vec4(value);\n\n    if (this.uAggrOpt > 3.0) {\n        x = (gl_FragCoord.x) / this.uResultDim.x;\n        y = (gl_FragCoord.y) / (this.uResultDim.y * float(this.uFieldCount));\n        value = texture2D(this.uDataInput, vec2(x, y));\n        res = value.a / value.b;\n    } else {\n        res = value.a;\n    }\n    gl_FragColor = vec4(0.0, 0.0, 0.0, res);\n  }\n}\n\nexport const FillValues = {\n  vertexShader() {\n    gl_Position = vec4(this._square, 0, 1);\n  },\n\n  fragmentShader() {\n    gl_FragColor = vec4(0.0, 0.0, 0.0, this.uFillValue);\n  }\n}\n","export const IntervalMatch = {\n  vertexShader() {\n    var i, j, k, value;\n    var filter = new Int(0);\n    var sel = new Int(0);\n    var visSelect = new Bool(false);\n    i = (this.aDataIdx+0.5) / this.uDataDim.x;\n    j = (this.aDataIdy+0.5) / this.uDataDim.y;\n    \n    for(var f = 0; f < $(fieldCount) + $(indexCount); f++) {\n      if(this.uFilterControls[f] == 1 || this.uVisControls[f] == 1) {\n        value = this.getData(f, i, j);\n    \n        if(this.uFilterControls[f] == 1) {\n          if(value < this.uFilterRanges[f].x || value > this.uFilterRanges[f].y) {\n            filter -= 1;\n          }\n        }\n        if(this.uVisControls[f] == 1) {\n          if(value < this.uVisRanges[f].x || value > this.uVisRanges[f].y) {\n            sel -= 1;\n          }\n          visSelect = true;\n        }\n      }\n    }\n    this.vResult = 0.1;\n    if(filter < 0) {\n      this.vResult = 0.0;\n    } else {\n      if(visSelect)\n        this.vResult = (sel < 0) ? 0.1 : 0.2;\n    }\n    var x = i * 2.0 - 1.0;\n    var y = j * 2.0 - 1.0;\n    gl_PointSize = 1.0;\n    gl_Position = vec4(x, y, 0.0, 1.0);\n  },\n\n  fragmentShader() {\n    gl_FragColor = vec4(0., 0., 0., this.vResult);\n  }\n}\n\nexport const DiscreteMatch = {\n  vertexShader() {\n    var i, j, k, value;\n    i = (this.aDataIdx+0.5) / this.uDataDim.x;\n    j = (this.aDataIdy+0.5) / this.uDataDim.y;\n    this.vResult = this.uFilterLevel - 0.1;\n    value = this.getData(this.uFieldId, i, j);\n    for(var l = 0; l < 100; l++){\n      if(l < this.uSelectCount) {\n        if(value == this.uInSelections[l]) {\n          this.vResult = this.uFilterLevel;\n        }\n      }\n    }\n    var x = i * 2.0 - 1.0;\n    var y = j * 2.0 - 1.0;\n    gl_PointSize = 1.0;\n    gl_Position = vec4(x, y, 0.0, 1.0);\n  },\n\n  fragmentShader() {\n    gl_FragColor = vec4(0., 0., 0., this.vResult);\n  }\n}","\n// Calculate the current day of the week as an integer\n//   now - Unix timestamp like that from time(NULL)\n//   tz_offset - Number of hours off from UTC; i.e. PST = -8\n//   Return value: Sunday=0, Monday=1, ... Saturday=6\n// int dayofweek(time_t now, int tz_offset) {\n// \t// Calculate number of seconds since midnight 1 Jan 1970 local time\n// \ttime_t localtime = now + (tz_offset * 60 * 60);\n// \t// Convert to number of days since 1 Jan 1970\n// \tint days_since_epoch = localtime / 86400;\n// \t// 1 Jan 1970 was a Thursday, so add 4 so Sunday is day 0, and mod 7\n// \tint day_of_week = (days_since_epoch + 4) % 7; \n\n// \treturn day_of_week;\n// }\n\n// function getDateTime(s) {\n//   let z = Math.floor(s / 86400) + 719468;\n//   let era = Math.floor(z >= 0 ? z : z - 146096) / 146097;\n//   let doe = Math.floor((z - era * 146097));\n//   let yoe = Math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365);\n//   let year = Math.floor((yoe) + era * 400);\n//   let doy = Math.floor(doe - (365 * yoe + yoe / 4 - yoe / 100));\n//   let mp = Math.floor(( 5 * doy + 2) / 153);\n//   let day = Math.floor(doy - (153 * mp + 2) / 5 + 1);\n//   let month = Math.floor(mp + (mp < 10 ? 3 : -9));\n//   year += (month <= 2);\n//   return {year, month, day};\n// }\n\nfunction getDateTime(s) {\n  let second = s % 60\n  let minute = Math.floor(s / 60) % 60\n  let hour = Math.floor(s / 3600) % 24\n  let days = Math.floor(s / 3600 / 24) \n  let years = Math.floor(days / 365.25)\n  let year = 1970 + years;\n  let dayOfWeek = (days + 4) % 7\n\n  // let leapDays = 0\n  // for (var i = 1970; i < year; i++) {\n  //   if ((i % 4 === 0 && i % 100 !== 0) || (i % 400 == 0)) {\n  //     leapDays += 1;\n  //   }\n  // }\n  // days = days - (years * 365 + leapDays);\n  days = days - Math.ceil(years * 365.25);\n  let isLeapYear = ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0));\n  let month = 1\n  let daysInMonth\n  while (month <= 12) {\n    \n    if(month === 2) {\n      daysInMonth = 28 + isLeapYear;\n    } else {\n      daysInMonth = 30 + (month + (month < 7)) % 2\n    }\n\n    if (days > daysInMonth) {\n      days -= daysInMonth\n      month += 1\n    } else {\n      break;\n    }\n  }\n\n  return {year, month, days, hour, minute, second, dayOfWeek}\n}\n\n\nexport function getHour({ts = 'float'}) {\n  var hours = floor(ts / 3600.0);\n  return hours - (24.0 * floor(hours / 24.0)) + 1.0;\n}\n\nexport function getYear({ts = 'float'}) {\n  var days = floor(ts / 3600.0 / 24.0);\n  var years = floor(days / 365.25);\n  return 1970.0 + years;\n}\n\nexport function floatMod({a = \"float\", b = \"float\"}) {\n  return a - (b * floor(a / b));\n}\n\n// export function getMonth({ts = 'float'}) {\n//   var days = floor(ts / 3600.0 / 24.0);\n//   var years = floor(days / 365.25) + 1970.0;\n//   var months = floor(days / 30.5);\n//   return months - floor(months / 12.0);\n// }\n\nexport function getDayOfWeek({ts = 'float'}) {\n  var days = floor(ts / 3600.0 / 24.0) + 4.0;\n  return days - (7.0 * floor(days / 7.0)) + 1.0;\n} \n\nexport function getMonth({ts = 'float'}) {\n  var days = floor(ts / 3600.0 / 24.0);\n  var years = floor(days / 365.25);\n  days = days - ceil(years * 365.25);\n  var month = new int();\n  var daysInMonth;\n  var year = 1970.0 + years;\n  var isLeapYear = 0.0;\n  if( (year - (4.0 * floor(year/4.0)) == 0.0 \n    && year - (100.0 * floor(year/100.0)) != 0.0)\n    || (year - (100.0 * floor(year/400.0)) == 0.0)\n  ) {\n    isLeapYear = 1.0;\n  }\n  month = 1;\n  for (var i = 1; i<=12; i++) {\n    if(month == 2) {\n      daysInMonth = 28.0 + isLeapYear;\n    } else if( month == 4 || month == 6 || month == 9 || month == 11) {\n      daysInMonth = 30.0;\n    } else {\n      daysInMonth = 31.0;\n    }\n    if (days > daysInMonth) {\n      days -= daysInMonth;\n      month += 1;\n    }\n  }\n  return float(month);\n}","export default class Grid {\n    constructor(views) {\n        this.views = views\n    }\n\n    add (view) {\n        this.view.push(view)\n    }\n\n    reset () {\n        this.views.forEach(function(v){\n            if(v.hasOwnProperty('chart')) {\n                v.chart.svg.remove()\n                v.chart.removeAxis()\n                v.chart.removeLegend()\n                delete v.chart\n            }\n        })\n    }\n\n    generateViews ({\n        layout = 'rows',\n        count = 1,\n        width = 640,\n        height = 480,\n        padding = {left: 0, right: 0, top: 0, bottom: 0},\n        gridlines = {x: false, y: false}\n    }) {\n        let views = new Array(count)\n        let calcOffset\n        // height -= padding.top + padding.bottom;\n        // width -= padding.left + padding.right;\n        if (layout == 'rows') {\n            height = height / count\n            calcOffset = (index) => [0, index * height]\n        } else {\n            width = width / count\n            calcOffset = (index) => [index * width, 0]\n        }\n        for (let i = 0; i < count; i++) {\n            let offset = calcOffset(i)\n            views[i] = {width, height, padding, offset, gridlines}\n        }\n        this.views = views;\n        return views;\n    }\n}","import FlexGL from '../flexgl';\n\nexport default function init({\n    context = null,\n    container = document.body,\n    viewport =  [800, 450],\n    padding = {left:0, right: 0,top: 0, bottom: 0},\n    attributes = {},\n    views\n}){\n    let $p = context;\n    let defaultLayout = [\n        {\n            width: viewport[0],\n            height: viewport[1],\n            // padding: {left: 30, right: 30, top: 30, bottom: 30},\n            offset: [0, 0]\n        }\n    ];\n    if ($p === null) {\n        $p = new FlexGL({\n            container: container,\n            width: viewport[0],\n            height: viewport[1],\n            padding: {left:0, right: 0,top: 0, bottom: 0},\n            attributes: attributes\n        });\n    }\n    $p.container = container;\n    $p.padding = padding;\n    $p.viewport = viewport;\n    $p.views = views || defaultLayout;\n    return $p;\n}\n","\nimport Brush from './vis/brush';\nexport default function interact($p, options) {\n  let viewTags = options.view || [$p.views[0].id];\n\n  if(!Array.isArray(viewTags)) viewTags = [viewTags];\n\n  let actions = options.actions || options.events || [],\n    condition = options.condition || {},\n    facet = options.facet || false,\n    callback = options.callback || function() {};\n\n  if($p._update) return;\n\n  if(!condition.x && !condition.y) {\n    condition.x = condition.y = true;\n  }\n\n  viewTags.forEach(function(viewTag){\n    let vis = $p.views.filter(v=>v.id == viewTag)[0];\n    if(!Array.isArray(actions)) {\n      actions = [actions];\n    }\n\n    if(vis === undefined || !vis.hasOwnProperty('chart')) return;\n\n    let vmap = vis.vmap,\n      p = vis.padding || $p.padding,\n      w = vis.width - p.left - p.right,\n      h = vis.height - p.top - p.bottom;\n    \n    let interactor = vis.chart.svg.append(\"g\")\n      .attr(\"class\", \"selector\")\n\n    if(facet === 'rows') {\n      h = $p.viewport[1] - p.bottom;\n    } else if(facet === 'columns') {\n      w = $p.viewport[0] - p.right;\n    }\n\n    let rect = interactor.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", w)\n      .attr(\"height\", h)\n      .attr(\"fill-opacity\", 0)\n      .attr(\"stroke\", \"none\");\n\n    let svg = interactor.svg,\n      box = rect.svg.getBoundingClientRect();\n\n    function getSelection(e) {\n      let dx = e.clientX - box.left;\n      let dy = e.clientY - box.top;\n      let selection = {};\n      if(vmap.x) {\n        selection[vmap.x] = [vis.chart.x.invert(dx)];\n      }\n      if(vmap.y) {\n        selection[vmap.y] = [vis.chart.y.invert(h - dy)];\n      }\n      return selection;\n    }\n\n    actions.forEach(function(action){\n      if(action === 'brush') {\n        svg.style.cursor = \"crosshair\";\n        let brushOptions = {\n          container: interactor,\n          width: w,\n          height: h\n        };\n\n        if(!Array.isArray(vmap.x) && !Array.isArray(vmap.y)) {\n          let updateEvent = (condition.lazy) ? 'brushend' : 'brush';\n          brushOptions[updateEvent] = function(d) {\n            let selection = {};\n            if(vmap.x && d.x) selection[vmap.x] = d.x;\n            if(vmap.y && d.y) {\n              if (d.y[0] > d.y[1]) {\n                selection[vmap.y] = d.y.reverse();\n              } else {\n                selection[vmap.y] = d.y;\n              }\n            }\n\n            Object.keys(selection).forEach(k => {\n              if ($p.uniqueValues.hasOwnProperty(k)) {\n                let values = $p.uniqueValues[k]\n                let start = Math.floor(selection[k][0]);\n                let end = Math.floor(selection[k][1]);\n                if(end === start) start -= 1;\n                selection[k] = [values[start], values[end]];\n              } \n            })\n\n            callback(selection);\n          }\n          if(condition.x && typeof(vis.chart.x.invert) == 'function')\n            brushOptions.x = vis.chart.x.invert;\n\n          if(condition.y && typeof(vis.chart.y.invert) == 'function') {\n            brushOptions.y = (y) => { \n              if(vmap.mark === 'rect') {\n                return vis.chart.y.invert(h-y);\n              }\n              return vis.chart.y.invert(y);\n            } \n          }\n          \n          new Brush(brushOptions);\n        }\n\n        let dims = ['x', 'y'],\n          selections = {};\n\n        dims.forEach(function(dim){\n          if(Array.isArray(vmap[dim]) && Array.isArray(vis.chart[dim])){\n            let axisDist = (dim == 'x') ? h : w,\n              selectors = vis.chart.svg.append('g');\n\n            axisDist =  axisDist / (vmap[dim].length-1);\n\n            vmap[dim].forEach(function(d, i) {\n\n              let axisSelect = selectors.append(\"g\");\n              if(dim == 'x') {\n                brushOptions.height = axisDist * 0.2;\n                axisSelect.translate(0, axisDist * (i - 0.1));\n                brushOptions.brush = function(range) {\n                  selections[d] = range[dim];\n                  callback(selections);\n                }\n              } else {\n                brushOptions.width = axisDist * 0.2;\n                axisSelect.translate(axisDist * (i - 0.1), 0);\n                brushOptions.brush = function(range) {\n                  selections[d] = range[dim].reverse();\n                  callback(selections);\n                }\n              }\n              brushOptions.container = axisSelect;\n              brushOptions[dim] = vis.chart[dim][i].invert;\n\n              new Brush(brushOptions);\n            });\n          }\n        })\n      } else if(action === 'zoom') {\n        vis.updateDomain = true;\n        let delta = {x: null, y: null};\n        let scale = 0.05;\n        svg.onmousewheel = function(e) {\n          let dir = (e.deltaY > 0) ? 1 : -1;\n          let selection = {};\n          let proportion = {\n            x: (e.clientX - box.left) / box.width,\n            y: 1.0 - (e.clientY - box.top) / box.height\n          }\n\n          for (let dim of ['x', 'y']) {\n            if(condition[dim]) {\n              let attr = vis.vmap[dim];\n              if(delta[dim] === null ){\n                delta[dim] =  scale * (vis.domains[attr][1] - vis.domains[attr][0]);\n              }\n    \n              let domain = vis.domains[attr];\n              let newDomain = [domain[0] - dir * delta[dim] * (proportion[dim]), domain[1] + dir * delta[dim] * (1-proportion[dim])];\n              if(newDomain[1] - newDomain[0] > 1e-9){\n                selection[attr] = newDomain;\n                vis.domains[attr] = newDomain;\n              } else {\n                scale *= 0.5;\n              }\n\n            }\n          }\n          callback(selection);\n        }\n\n      } else if(action == 'pan') {\n        svg.style.cursor = 'move';\n        vis.updateDomain = true;\n        let selection = {};\n        svg.onmousedown = function(e) {\n          let sx = e.clientX;\n          let sy = e.clientY;\n          svg.style.cursor = 'move';\n\n          function onpan(e) {\n            let delta = {\n              x: -(e.clientX - sx) / box.width,\n              y: (e.clientY - sy) / box.height\n            }\n            for (let dim of ['x', 'y']) {\n              if(condition[dim]) {\n                let attr = vis.vmap[dim];\n                let domain = vis.domains[attr];\n                let diff = delta[dim] * (domain[1] - domain[0]);\n                let newDomain = [domain[0] + diff, domain[1] + diff];\n                selection[attr] = newDomain;\n                vis.domains[attr] = newDomain;\n              }\n            }\n            sx = e.clientX;\n            sy = e.clientY;\n            callback(selection);\n          }\n\n          window.addEventListener(\"mousemove\", onpan, false);\n          window.addEventListener(\"mouseup\", function(){\n            svg.style.cursor = 'default';\n            window.removeEventListener(\"mousemove\", onpan, false);\n          }, false);\n\n        }\n\n      } else if(action === 'click') {\n        svg.onclick = function(e) {\n          callback(getSelection(e));\n        }\n      } \n      \n      if(action === 'hover') {\n        svg.onmouseover = function(e) {\n          callback(getSelection(e));\n          svg.onmousemove = function(e) {\n            callback(getSelection(e));\n          }\n\n          // svg.onmouseout = function(e) {\n          //     updatePos(e);\n          //     svg.style.cursor = 'default';\n          //     svg.onmousemove = null;\n          //     svg.onmouseover = null;\n          // }\n        }\n      }\n    })\n  })\n}\n","export function request(arg) {\n    var url = arg.url || arg,\n        method = arg.method || \"GET\",\n        dataType = arg.dataType || \"json\",\n        data = arg.data || [],\n        query = [];  //arraybuffer, blob, document, json, text\n\n    for (var key in data) {\n        query.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key]));\n    }\n\n    return new Promise(function(resolve, reject) {\n\n        var req = new XMLHttpRequest();\n        req.open(method, url);\n        req.responseType = dataType;\n\n        req.onload = function() {\n          if (req.status == 200) {\n            resolve(req.response);\n          }\n          else {\n            reject(Error(req.statusText));\n          }\n        };\n\n        req.onerror = function() {\n          reject(Error(\"Network Error\"));\n        };\n\n        if (method == 'POST') {\n            req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n        }\n\n        req.send(data);\n    });\n};\n\nexport let get = request;\n\nexport function getAll(options) {\n    var promises = [];\n    options.forEach(function(option){\n        promises.push(\n            request(option)\n            .then(function(result){\n                return new Promise(function(resolve, reject) {\n                    resolve(result);\n                });\n            })\n        );\n    });\n\n    return Promise.all(promises);\n}\n\nexport function post(arg) {\n    arg.method = \"POST\";\n    return ajax.request(arg);\n};\n","import * as ajax from './ajax';\nimport cstore from '../cstore';\nimport parse from './parse';\n\nconst INPUT_FORMATS = [\n  'json',\n  'csv',\n  'text',\n  'RowArrays',\n  'ColArrays',\n  'cstore'\n];\n\nconst INPUT_METHODS = ['memory', 'http', 'websocket', 'file'];\n\nexport default function input({\n  type = 'cstore',\n  format = 'cstore',\n  method = 'memory',\n  delimiter = ',',\n  size = 0,\n  schema,\n  source,\n  url,\n  onready,\n  uniqueKeys = []\n}) {\n  if(INPUT_FORMATS.indexOf(type) === -1) {\n    throw Error('Invalid input type ', type)\n  }\n\n  if(INPUT_METHODS.indexOf(method) === -1) {\n    throw Error('Unknown method ', method)\n  }\n\n  let cache;\n  function createIndexes() {\n    uniqueKeys.forEach(function(uk){\n      cache.index(uk);\n    })\n  }\n  let dataFormat = format || type;\n  let dataHandlers = {\n    json: function(data) {\n      cache = cstore({schema, size})\n      cache.import({data: (method == 'websocket') ? JSON.parse(data) : data});\n      createIndexes();\n      return cache.data();\n    },\n    csv: function(text) {\n      let data = parse(text, delimiter);\n      // let fields = data.shift();\n      // cache = cstore({keys: fields, types: fields.map(() => 'float')})\n      cache = cstore({schema, size})\n      cache.addRows(data);\n      createIndexes();\n      return cache.data();\n    },\n    cstore: function() {\n      if(Number.isInteger(source.size) && Array.isArray(source.types)) {\n        return source;\n      }\n    }\n  }\n\n  dataHandlers.text = dataHandlers.csv;\n  let response = function(data) {\n    return new Promise(function(resolve, reject) {\n      if(typeof(dataHandlers[dataFormat]) === 'function') {\n        resolve(dataHandlers[dataFormat](data));\n      } else {\n        reject(Error('No handler for data type ', dataFormat));\n      }\n    })\n  }\n\n  if(method === 'http') {\n    let dataSource = url || source;\n    return ajax.get({url: dataSource, dataType: dataFormat}).then(response);\n  } else if (method == 'websocket') {\n    return new Promise(function(resolve, reject) {\n      var socket = new WebSocket(source);\n      socket.onopen = function() {\n        if(typeof(onready) === 'function') onready(socket)\n      }\n      socket.onmessage = function(event) {\n        resolve(dataHandlers[dataFormat](event.data));\n      }\n      socket.onerror = function(err) {\n        reject(err);\n      }\n    });\n  } else {\n    return response(source);\n  }\n}\n","export default function($p) {\n  let output = {};\n  output.result = function({format = 'row', outputTag = 'fGroupResults'}) {\n    let objectArray = new Array();\n    let match = null;\n    if($p.uniform.uFilterFlag.data == 1){\n      match = $p.getMatchBuffer()\n    }\n    // $p.setInput(outputTag)\n    \n    for(let edi = 0; edi < $p.extraDimension; edi++) { \n\n      // if only match is performed and no other write ops, use cache to write source data to framebuffer.\n      if($p.getResultBuffer === undefined) { \n        $p.cache('cachedData')\n      }\n      let buf = $p.getResultBuffer({outputTag, offset: [edi * $p.resultDimension[0], 0]});\n      let res = {};\n      let offset = 0;\n      let rs = 0;\n      if(typeof buf.subarray !== 'function') return buf;\n      if($p.indexes.length > 0) {\n        if ($p.resultDimension[0] > 1) {\n          res[$p.fields[rs]] = $p.attribute.aDataValx.data;\n          rs++;\n        }\n        if ($p.resultDimension[1] > 1) {\n          let bx = $p.attribute.aDataValx.data;\n          let by = $p.attribute.aDataValy.data;\n          let ax = new Array($p.resultDimension[0] * $p.resultDimension[1]);\n          let ay = new Array($p.resultDimension[0] * $p.resultDimension[1]);\n\n          for (let y = 0; y < $p.resultDimension[1]; y++) {\n            for (let x = 0; x < $p.resultDimension[0]; x++) {\n              ax[y * $p.resultDimension[0] + x] = bx[x];\n              ay[y * $p.resultDimension[0] + x] = by[y]\n            }\n          }\n          res[$p.fields[0]] = ax;\n          res[$p.fields[rs]] = ay;\n          rs++;\n        }\n      }\n \n      let arraySize = $p.resultDimension[0] * $p.resultDimension[1];\n      let fields = $p.fields.filter( f => f !== $p.indexes[2]);\n      for (let i = rs; i < fields.length; i++) {\n        res[fields[i]] = buf.subarray(offset, offset + arraySize);\n        offset += arraySize;\n      };\n\n      for (let i = 0; i < arraySize; i++) {\n        if(match !== null && match[i] == 0) continue\n        let obj = (format == 'array') ? new Array(fields.length) : {};\n        if($p.extraDimension > 0 && $p.indexes.length === 3) {\n          let fieldName = $p.indexes[2];\n          obj[fieldName] = ($p.strLists.hasOwnProperty(fieldName)) ?  $p.strLists[fieldName][edi] : edi + 1;\n        } \n        fields.forEach(function(f, fi) {\n          let kid = $p.dkeys.indexOf(f);\n          let dtype = $p.dtypes[kid];\n          let key = (format == 'array') ? fi : f;\n\n          if (dtype == 'string' && $p.strLists.hasOwnProperty(f)) {\n            obj[key] = $p.strLists[f][res[f][i]];\n          } else if ($p.intervals.hasOwnProperty(f) && $p.intervals[f].dtype == 'histogram') {\n            obj[key] = $p.intervals[f].min + res[f][i] * $p.intervals[f].interval;\n          } else if ($p.uniqueValues.hasOwnProperty(f)) {\n            obj[key] = $p.uniqueValues[f][res[f][i]];\n          } else {\n            obj[key] = res[f][i];\n          }\n        });\n        objectArray.push(obj);\n      }\n    }\n    if($p.extraDimension === 1 && objectArray.length > $p.dataSize) {\n      objectArray = objectArray.slice(0, $p.dataSize);\n    }\n    return objectArray;\n  }\n\n  output.toArray = () => output.result({format: 'array'})\n  output.toJson = () => output.result({format: 'json'})\n  output.readPixels = function({\n    offset = [0, 0],\n    resultSize =  $p.dataDimension[0]* $p.dataDimension[1],\n    rowSize = Math.min(resultSize, $p.dataDimension[0]),\n    colSize = Math.ceil(resultSize / $p.dataDimension[0])\n  }) {\n    let result = new Uint8Array(rowSize * colSize * 4);\n    $p.bindFramebuffer(null);\n    $p.ctx.readPixels(offset[0], offset[1], rowSize, colSize, gl.RGBA, gl.UNSIGNED_BYTE, result);\n    return result.filter(function(d, i){ return i%4===3;} );\n  }\n  return output;\n}\n","export default function parse(text, delimiter) {\n    \"use strict\";\n    var size = text.length,\n        accum = 0,\n        i, //index for starting of a line\n        row,\n        rows = [],\n        fields = [],\n        lens = [],\n        EOL = false;\n\n    while(accum < size) {\n        i = accum, EOL = false;\n        row = loadLine(text, delimiter.charCodeAt(0), i);\n        rows.push(row.fields);\n        accum += row.size;\n    }\n    return rows;\n}\n\nfunction loadLine(text, delimiterCode, initPos) {\n    // if(typeof(initPos) === 'undefined') initPos = 0;\n    var EOL = false,\n        QUOTE = false,\n        c = initPos, //current pos\n        code, //code at c\n        f = initPos, // start pos of current field\n        q, //start pos of quote\n        fields = [],\n        L = text.length;\n\n    while(!EOL){\n        code = text.charCodeAt(c);\n        if(code === 10 || c>=L){\n            EOL = true;\n            // if(text.charCodeAt(c+1) === 13) ++c;\n            fields.push( text.slice(f, c) );\n        } else {\n            if(code === delimiterCode && !QUOTE) {\n                // console.log(f,c, text.slice(f, c));\n                var field = text.slice(f, c);\n                fields.push( field );\n                f = c+1;\n            } else if(code === 34){\n                if(QUOTE){\n                    if(text.charCodeAt(c+1) === delimiterCode){\n                        QUOTE = false;\n                        fields.push(text.slice(q, c));\n                        f = c+2;\n                        c++;\n                    }\n                } else {\n                    q = c+1;\n                    QUOTE = true;\n                }\n            }\n        }\n        c++;\n    }\n    return { fields: fields, size: c-initPos };\n}\n","import aggregate  from './ops/aggregate';\nimport cache      from './ops/cache.gl';\nimport derive     from './ops/derive';\nimport extent     from './ops/extent.gl';\nimport match      from './ops/match';\nimport visualize  from './vis/visualize';\n\nexport default {\n    aggregate,\n    cache,\n    derive,\n    extent,\n    match,\n    visualize\n}","import allocate from './allocate';\nimport input from './io/input';\nimport output from './io/output';\nimport initialize from './initialize';\nimport interact from './interact';\nimport control from './control';\nimport pipeline from './pipeline';\nimport operate from './operate';\nimport kernels from './kernels';\nimport extensions from './extensions';\nimport Grid from './grid';\nimport cstore from './cstore';\n\nexport default function p4(options) {\n  let $p = initialize(options);\n  $p.async = options.async || false;\n  $p.views = [];\n  $p.interactions = [];\n  $p.histograms = [];\n  $p.extensions = extensions;\n  $p.responses = {};\n  $p.crossfilters = {};\n  $p.primitives = [];\n  $p.dataSize = 0;\n  $p.rowSize = options.dimX || 4096;\n  $p.deriveMax = options.deriveMax || 4;\n  $p.deriveCount = 0;\n  \n  $p._responseType = 'unselected';\n  $p._update = false;\n  $p._progress = false;\n  $p.skipRender= false;\n\n  $p.getResult = function() {};\n  let api = pipeline($p);\n  api.ctx = $p;\n  api.addModule(control);\n  api.assignMethods(output);\n  // api.addModule(view);\n  // let outputs = output($p)\n  // api.result = outputs.result;\n  api.addOperation('head', function() {\n    api.resume('__init__');\n    if(Object.keys($p.crossfilters).length > 0) api.match({});\n    $p.getResult = $p.getRawData;\n    return api;\n  });\n\n  $p.grid = {views: []};\n  api.view = function(views) {\n    if($p.grid.views.length !== 0) {\n      $p.grid.reset();\n    } \n    $p.grid = new Grid(views);\n    $p.views = $p.grid.views;\n    return api;\n  }\n  api.views = api.view;\n  api.getViews = function () {\n    return $p.views;\n  }\n  \n  $p.reset = api.head;\n  $p.exportResult = api.result;\n\n  $p.setInput = function(inputName) {\n    api.resume(inputName);\n    return api;\n  }\n\n  $p.setOutput = function(outputName) {\n    api.register(outputName);\n    // console.log(api.result({outputTag: outputName, format: 'row'}))\n    return api;\n  }\n\n  function configPipeline($p) {\n    $p.extent = kernels.extent($p);\n    // $p.operations = compile($p);\n    let operations = operate($p);\n    api.getOperations = () => Object.keys(operations);\n    for(let optName of Object.keys(operations)) {\n      api.addOperation(optName, operations[optName], true);\n    }\n    \n    for(let ext of $p.extensions) {\n      if(ext.getContext === true) {\n        ext.function = ext.function($p);\n      }\n    }\n    api.register('__init__');\n  }\n  \n  api.data = function(dataOptions) {\n    if (dataOptions.format === 'json') {\n      let columns = cstore({\n          schema: dataOptions.schema,\n          size: dataOptions.values.length\n        })\n        .import({data: dataOptions.values});\n\n      allocate($p, columns.data());\n    } else {\n      allocate($p, dataOptions);\n    }\n    configPipeline($p);\n    $p.getResult = dataOptions.export;\n    $p.cache = api.cache;\n    $p.getRawData = dataOptions.export;\n    $p.match = api.match;\n    return api;\n  }\n\n  api.index = function(indexes) {\n    data.indexes = indexes;\n    return api;\n  }\n\n  let asyncPipeline = {};\n  let asyncInput = function(arg) {\n    let inputReady = false;\n    for(let program of Object.keys(api).concat(Object.keys(kernels))) {\n      asyncPipeline[program] = function(spec) {\n        api.addToQueue(program, spec);\n        return asyncPipeline;\n      }\n    }\n\n    asyncPipeline.execute = function() {\n      return input(arg).then(function(data){\n        if(Array.isArray(arg.indexes)) {\n          data.indexes = arg.indexes;\n        }   \n        api.data(data);\n        api.async(true);\n        api.run();\n        api.async(false);\n        inputReady = true;\n        return new Promise(function(resolve, reject){\n          resolve(api.result('row'))\n          return api;\n        })\n      })\n    }\n\n    asyncPipeline.commit = asyncPipeline.execute;\n\n    if(arg.dimX) $p.rowSize = arg.dimX;\n    return asyncPipeline;\n  }\n\n  api.runJSON = function(jsonSpec) {\n    let inputSpec = jsonSpec[0];\n    if (!inputSpec.hasOwnProperty('input')) {\n      throw Error('Error: No specification for input!');\n    }\n    let asyncPipeline = api.input(inputSpec)\n    jsonSpec.slice(1).forEach(spec => {\n      let opt = Object.keys(spec)[0];\n      asyncPipeline[opt](spec[opt]);\n    })\n\n    return api;\n  }\n\n  api.getResult = function (d) {\n    return $p.getResult(d);\n  }\n\n  api.clearWebGLBuffers = function() {\n    let frameBuffers = ['offScreenFBO', 'visStats', null];\n    frameBuffers.forEach(fb => {\n      $p.bindFramebuffer(fb);\n      $p.ctx.clearColor( 0.0, 0.0, 0.0, 0.0 );\n      $p.ctx.clear( $p.ctx.COLOR_BUFFER_BIT | $p.ctx.DEPTH_BUFFER_BIT );\n    })\n  }\n\n  api.runSpec = function(specs) {\n    api.head();\n    api.clearWebGLBuffers();\n    $p.interactions = [];\n    $p.responses = {};\n    $p.crossfilters = [];\n    $p.uniform.uFilterFlag.data = 0;\n    api.clearQueue();\n    // $p.uniform.uFilterRanges = $p.fieldDomains.concat($p.deriveDomains);\n    specs.forEach(function(spec){\n      let opt = Object.keys(spec)[0];\n      let arg = spec[opt];\n      opt = opt.slice(1); // ignore $ sign \n      if(typeof api[opt] == 'function') {\n        api[opt](arg);\n      }\n    })\n    return api;\n  }\n  \n  api.interact = function(spec) {\n    if(typeof(spec) != 'undefined') $p.interactions.push(spec);\n    $p.interactions.forEach(function(interaction){\n      // console.log(interaction)\n      let callback = interaction.callback || function(selection) {\n        $p.responses = interaction.response;\n        if(!$p._update) {\n          $p._update = true;\n          $p.crossfilters = {};\n          if(typeof selection == 'object') {\n            Object.keys(selection).forEach(function(k) {\n              if(selection[k].length < 2) {\n                if($p.intervals.hasOwnProperty(k)) {\n                  var value = (Array.isArray(selection[k]))\n                    ? selection[k][0]\n                    : selection[k];\n                  selection[k] = [value-$p.intervals[k].interval, value];\n                } \n                // else if(!$p.strLists.hasOwnProperty(k)) {\n                //     selection[k] = [selection[k][0] + selection[k][0] + 1];\n                // }\n              }\n              $p.crossfilters[k] = selection[k];\n            });\n          }\n          $p._responseType = 'unselected';\n          $p.uniform.uFilterLevel.data = 0.2;\n          $p.uniform.uVisLevel.data = 0.1;\n          api.head().run();\n          $p._responseType = 'selected';\n          $p.uniform.uVisLevel.data = 0.2;\n          api.head().run();\n          $p._responseType = 'unselected';\n          $p._update = false;\n          $p.uniform.uFilterLevel.data = 0.1;\n          $p.uniform.uVisLevel.data = 0.1;\n        }\n      }\n      interact($p, {\n        actions: interaction.event,\n        view: interaction.from,\n        condition: interaction.condition,\n        facet: interaction.facet,\n        callback: callback  \n      })\n    })\n  }\n  $p.respond = api.interact;\n\n  api.updateData = function(newData) {\n    let data;\n    if(newData._p4_cstore_version) {\n      data = newData\n    } else {\n      \n      let cache = cstore({\n        schema: $p.dataSchema,\n        strValues: $p.strValues\n      })\n      cache.addRows(newData)\n      data = cache.data()\n    }\n\n    //update and combine all strValues\n    Object.keys(data.strValues).forEach((attr) => {\n      $p.strValues[attr] = Object.assign($p.strValues[attr], data.strValues[attr]);\n    })\n\n    if(data.size > 0) {\n      $p.dataSize = data.size;\n    }\n    $p.fields\n    .slice($p.indexes.length)\n    .forEach((attr, ai) => {\n      let buf = new Float32Array($p.dataDimension[0] * $p.dataDimension[1]);\n      if(data[attr] === undefined) debugger;\n      for (let i = 0, l = data[attr].length; i < l; i++) {\n        buf[i] = data[attr][i];\n      }\n      $p.texture.tData.update(\n        buf, [0, $p.dataDimension[1] * ai], $p.dataDimension\n      );\n      $p.fieldDomains[ai] = [\n        Math.min(data.stats[attr].min, $p.fieldDomains[ai][0]),\n        Math.max(data.stats[attr].max, $p.fieldDomains[ai][1])\n      ]\n      $p.fieldWidths[ai] = $p.fieldDomains[ai][1] - $p.fieldDomains[ai][0] + 1;\n      if(data.strLists.hasOwnProperty(attr)){\n        $p.fieldDomains[ai] = [0, data.strLists[attr].length - 1];\n        $p.strLists[attr] = data.strLists[attr];\n        $p.fieldWidths[ai] = data.strLists[attr].length;\n      }\n    });\n\n    api.updateRegister('__init__', {\n      fieldDomains: $p.fieldDomains,\n      fieldWidths: $p.fieldWidths}\n    )\n    $p.uniform.uFieldDomains.data = $p.fieldDomains;\n    $p.uniform.uFieldWidths.data = $p.fieldWidths;\n    return api;\n  }\n\n  api.updateDataColumn = function(data, attribute) {\n    if($p.fields.indexOf(attribute) === -1) {\n      throw Error('Invalid attribute', attribute);\n    }\n    let buf = new Float32Array($p.dataDimension[0] * $p.dataDimension[1]);\n    let attrId = $p.fields.indexOf(attribute) - $p.indexes.length;\n    for (let i = 0, l = data[attribute].length; i < l; i++) {\n      buf[i] = data[attr][i];\n    }\n    $p.texture.tData.update(\n      buf, [0, $p.dataDimension[1] * attrId], $p.dataDimension\n    );\n  }\n\n  api.updateDataRow = function(data, rowId) {\n    let dataType = (Array.isArray(data)) ? 'array' : 'json';\n    $p.fields.slice($p.indexes.length).forEach((attr, ai) => {\n      let texPosX = rowId % $p.dataDimension[0];\n      let value = (dataType == 'array') ? data[ai] : data[attr];\n      if(value === undefined) throw Error('Cannot update data due to invalid data value');\n      $p.texture.tData.update(\n        new Float32Array(data[ai]), [texPosX, $p.dataDimension[1] * i], [1,1]\n      );\n    });\n    return api;\n  }\n\n  api.extend = function(arg) {\n    let extOptions = Object.assign({\n      restartOnUpdate: true,\n      skipDefault: false,\n      exportData: false,\n      getContext: false,\n    }, arg)\n\n    if(extOptions.name != undefined && \n      (typeof extOptions.function === 'function' \n      || typeof extOptions.constructor === 'function')\n    ) {\n      $p.extensions.push(extOptions);\n    }\n  }\n\n  api.annotate = function ({\n    id = 0,\n    mark = 'vline',\n    color = 'red',\n    size = 3,\n    position = {values: []}\n  }) {\n    let view = $p.views[0];\n    if (Number.isInteger(id) && id < $p.views.length) {\n      view = $p.views[id];\n    } else {\n      $p.views.filter(v => v.id == id);\n      if (view.length > 0) {\n        view = view[0];\n      }\n    }\n    if (mark === 'vline') {\n      let values = position[view.vmap.x || view.vmap.width] || position.values;\n      values.forEach(val => {\n        let x = view.chart.x(val);\n        view.chart.svg.append('line')\n          .attr('x1', x)\n          .attr('x2', x)\n          .attr('y1', 0)\n          .attr('y2', view.height - view.padding.top - view.padding.bottom)\n          .attr('stroke', color)\n          .attr('stroke-width', size)\n      })\n    } else if (mark === 'hline') {\n      let values = position[view.vmap.y || view.vmap.height] || position.values;\n      values.forEach(val => {\n        let y = view.chart.y(val);\n        view.chart.svg.append('line')\n          .attr('x1', 0)\n          .attr('x2', view.width - view.padding.left - view.padding.height)\n          .attr('y1', y)\n          .attr('y2', y)\n          .attr('stroke', color)\n          .attr('stroke-width', size)\n      }) \n    }\n  }\n\n  let inputDataOptions = options.data || options.input;\n  if ($p.async && inputDataOptions) {\n    return asyncInput(options.data)\n  } else if ($p.async) { //no data option\n    asyncPipeline.data = asyncInput;\n    asyncPipeline.input = asyncInput;\n    return asyncPipeline;\n  } else {\n    return api;\n  }\n}\n","import programs from './kernels';\nimport compile from './compile';\nimport * as arrayOpt from './arrays';\n\nexport default function($p) {\n    let operations = {};\n    let kernels = compile($p);\n    let bin = function (spec, binIndex) {\n        let binAttr;\n        let binCount;\n    \n        if (typeof spec == 'object') {\n            binAttr = Object.keys(spec)[0];\n            binCount = spec[binAttr];\n        } else {\n            binAttr = spec;\n            // Apply Sturges' formula for determining the number of bins\n            binCount = Math.ceil(Math.log2($p.dataSize)) + 1;\n        }\n        let binAttrId = $p.fields.indexOf(binAttr);\n        let binDomain = $p.fieldDomains[$p.fields.indexOf(binAttr)];\n        let binInterval = (binDomain[1] - binDomain[0]) / binCount;\n        // debugger\n        $p.uniform.uBinCount.data[binIndex] = binCount;\n        $p.uniform.uBinIntervals.data[binIndex] = binInterval;\n        $p.fieldWidths[binAttrId] = binCount;    \n        $p.intervals[binAttr] = {};\n        $p.intervals[binAttr].dtype = 'histogram';\n        $p.intervals[binAttr].interval = binInterval;\n        $p.intervals[binAttr].min = binDomain[0];\n        $p.intervals[binAttr].max = binDomain[1];\n        $p.histograms.push(binAttr);\n        return binAttr;\n    }\n    \n    operations.aggregate = function (spec) {\n        if(spec.$bin) { \n            let binSpecs = Array.isArray(spec.$bin) ? spec.$bin : [spec.$bin];\n            let binAttrs = binSpecs.map((spec, ii) => {\n                return bin(spec, ii);\n            })\n            if(spec.$group) {\n                spec.$group = binAttrs.filter(a => spec.$group.indexOf(a) === -1).concat(spec.$group);\n            } else {\n                spec.$group = binAttrs;\n            }\n        }\n        if(Object.keys($p.crossfilters).length) {\n            $p.uniform.uFilterFlag = 1;\n            // operations.match({})\n            // $p.crossfilters = {}\n        }\n        if (!kernels.hasOwnProperty('aggregate')) {\n            kernels.aggregate = programs.aggregate($p, spec);\n        }\n        kernels.aggregate.execute(spec);\n        if (typeof(spec.out) === 'string') {\n            $p.setOutput(spec.out)\n        }\n        return kernels.aggregate.result;\n    }\n\n    operations.match = function(spec) {\n        if (!kernels.hasOwnProperty('match')) {\n            kernels.match = programs.match($p);\n        }\n        kernels.match.execute(spec);\n        return kernels.match.result;\n    }\n\n    operations.cache = function(tag) {\n        if (!kernels.hasOwnProperty('cache')) {\n            kernels.cache = programs.cache($p);\n        }\n        kernels.cache.execute(tag);\n        return kernels.cache.result;\n    }\n\n    operations.derive = function(spec) {\n        // if (!kernels.hasOwnProperty('derive')) {\n        if(!$p._update) {\n            kernels.derive = programs.derive($p, spec);\n        }\n        // }\n        kernels.derive.execute(spec);\n        return kernels.derive.result;\n    }\n\n    operations.visualize = function(vmap) {\n        // if(Object.keys($p.crossfilters).length > 0)\n        //     operations.match({});\n        let vmaps;\n        if(vmap.facets) {\n            let facet = vmap.facets;\n            let spec = facet.rows || facet.columns;\n            if(facet.sortBy !== undefined) {\n                let sortOpt = Object.keys(facet.sortBy)[0];\n                let sortAttr = facet.sortBy[sortOpt];\n                let result = $p.exportResult('row');\n                let sorted = spec[sortAttr].map((fields) => {\n                    let values = result.map(r => r[fields])\n                    let min = Math.min(...values);\n                    let max = Math.max(...values);\n                    let normalizedValues = values.map( val => (val - min) / (max - min) )\n                    if (sortOpt === 'var') sortOpt = 'variance';\n                    let opt = typeof(arrayOpt[sortOpt]) === 'function' ? sortOpt : 'avg'\n                    return {\n                        name: fields,\n                        value: arrayOpt[opt](normalizedValues)\n                    }\n                })\n                .sort((a, b) => b.value - a.value )\n                spec[sortAttr] = sorted.map(r => r.name);;\n            }\n            let encodings = Object.keys(vmap).filter(k => k !== 'facets')\n            let variables = Object.keys(spec)\n            let minLoopCount = Math.min(...variables.map(v => spec[v].length))\n\n            vmaps = new Array(minLoopCount)\n            for(let i = 0; i < minLoopCount; i++) {\n                let rule = {}\n                encodings.forEach(code => {\n                    let vi = variables.indexOf(vmap[code])\n                    if(vi < 0) {\n                    rule[code] = vmap[code]     \n                    } else {\n                    rule[code] = spec[variables[vi]][i]\n                    }\n                })\n                vmaps[i] = rule;\n                if(facet.brush && i === 0) {\n                    vmaps[i].brush = facet.brush;\n                    vmaps[i].brush.facet = 'rows'\n                }\n            }\n        } else {\n            vmaps = Array.isArray(vmap) ? vmap : [vmap];\n        }\n\n        if($p.grid.views.length < vmaps.length) {\n            $p.grid.reset();  \n            $p.views = $p.grid.generateViews({\n                count: vmaps.length, \n                width: $p.viewport[0],\n                height: $p.viewport[1],\n                padding: $p.padding,\n                gridlines: vmap.gridlines\n            })\n        }\n        vmaps.forEach( (vmap, vi) => {\n            if (!kernels.hasOwnProperty('visualize')) {\n                kernels.visualize = programs.visualize($p);\n            }\n            if (vmap.in) {\n                $p.setInput(vmap.in);\n            }\n            let viewIndex = vi;\n            if(typeof vmap.id == 'string') {\n                viewIndex = $p.views.map(d=>d.id).indexOf(vmap.id);\n                if(viewIndex == -1) {\n                    //find the next available view slot in all views\n                    for(let vi = 0; vi < $p.views.length; vi++){\n                        if(!$p.views[vi].id) {\n                            viewIndex = vi;\n                            $p.views[viewIndex].id = vmap.id;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if(vmap.mark == 'bar') vmap.zero = true;\n            $p.views[viewIndex].vmap = vmap;\n            let encoding = vmap,\n                viewTag = $p.views[viewIndex].id;\n    \n            if($p._update && $p.responses.hasOwnProperty(viewTag)) {\n                if($p.responses[viewTag].hasOwnProperty($p._responseType)) {\n                    encoding = Object.assign({}, vmap, $p.responses[viewTag][$p._responseType]);\n                }\n            }\n            if(encoding.opacity !== 0){\n                kernels.visualize({\n                    vmap: encoding,\n                    viewIndex: viewIndex\n                });\n                $p.respond();\n            }\n        })\n        $p.reset();\n    }\n\n    return operations;\n}","import {seqFloat} from '../utils';\nimport {Aggregate, GetStats, FillValues} from '../gljs/Aggregation.gl';\n\nconst VEC_IDS = ['x', 'y', 'z'];\nconst METRICS = ['$min', '$max', '$count', '$sum', '$avg', '$var', '$std'];\n\nexport default function aggregate($p) {\n    let aggregate = {};\n\n    $p.uniform('uFillValue', 'float', 0.0);\n    $p.uniform('uBinIntervals', 'vec2', [0.0, 0.0]);\n    $p.uniform('uBinCount', 'ivec2', [0, 0]);\n    $p.uniform('uAggrOpt', 'float', 2.0);\n    $p.uniform(\"uGroupFields\", \"int\",   [0, -1, -1]);\n    $p.uniform(\"uExtraKeyValue\", \"float\",  0.0);\n    $p.varying(\"vIsFiltered\", \"float\");\n    $p.extraDimension = 1;\n\n    $p.program(\n        'AggregateCompute',\n        $p.shader.vertex(Aggregate.vertexShader),\n        $p.shader.fragment(Aggregate.fragmentShader)\n    );\n\n    $p.program(\n        'GetAggrStats',\n        $p.shader.vertex(GetStats.vertexShader),\n        $p.shader.fragment(GetStats.fragmentShader)\n    );\n    $p.program(\n        'FillValues',\n        $p.shader.vertex(FillValues.vertexShader),\n        $p.shader.fragment(FillValues.fragmentShader)\n    );\n\n    var resultFieldCount,\n        getAvgValues = false,\n        getVarStd = false,\n        resultDomains;\n\n    function compute(opts, groupFieldIds, resultFieldIds, outputTag) {\n        resultFieldCount = resultFieldIds.length;\n        let gl = $p.program('FillValues');\n        $p.bindFramebuffer(outputTag);\n\n        if(!$p._progress) {\n            gl.clearColor(0.0, 0.0, 0.0, 0.0);\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        }\n\n        gl.disable(gl.BLEND);\n        resultFieldIds.forEach(function(f, i) {\n            gl.viewport(0, i * $p.resultDimension[1], $p.resultDimension[0], $p.resultDimension[1]);\n            var opt = METRICS.indexOf(opts[i]);\n            if (opt == 0) {\n                $p.uniform.uFillValue = Math.pow(2, 127);\n                gl.drawArrays(gl.TRIANGLES, 0, 6);\n            } else if(opt == 1) {\n                $p.uniform.uFillValue = -Math.pow(2, 128);\n                gl.drawArrays(gl.TRIANGLES, 0, 6);\n            }\n        });\n\n        gl = $p.program('AggregateCompute');\n      \n        $p.framebuffer.enableRead('fDerivedValues');\n        $p.framebuffer.enableRead('fFilterResults');\n\n        gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdx.location, 0);\n        gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataValx.location, 0);\n        gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdy.location, 1);\n        gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataValy.location, 1);\n\n        $p.uniform.uGroupFields = groupFieldIds;\n\n        gl.disable(gl.CULL_FACE);\n        gl.disable(gl.DEPTH_TEST);\n        gl.enable(gl.BLEND);\n        gl.blendFunc(gl.ONE, gl.ONE);\n        gl.blendEquation(gl.FUNC_ADD);\n        $p.uniform.uResultDim = $p.resultDimension;\n\n        let postComputeFieldIds = [];\n        \n        getAvgValues = false;\n        getVarStd = false;\n\n        for (var ii = 0; ii < $p.extraDimension; ii++) {\n            postComputeFieldIds = [];\n            resultFieldIds.forEach(function(f, i) {\n                var opt = METRICS.indexOf(opts[i]);\n                if (opt == -1) throw Error('unknowm operator for aggregation: ' + opts[i]);\n\n                if (opt > 3) {\n                    getAvgValues = true;\n                    $p.bindFramebuffer('fAggrStats');\n                    postComputeFieldIds.push(i);\n                } else {\n                    $p.bindFramebuffer(outputTag);\n                }\n\n                gl.viewport(ii * $p.resultDimension[0], i * $p.resultDimension[1], $p.resultDimension[0], $p.resultDimension[1]);\n                if (opt == 0) {\n                    gl.blendEquation(gl.MIN_EXT);\n                } else if (opt == 1) {\n                    gl.blendEquation(gl.MAX_EXT);\n                } else {\n                    gl.blendEquation(gl.FUNC_ADD);\n                }\n\n                $p.uniform.uFieldId = f;\n                $p.uniform.uAggrOpt = opt;\n                if(groupFieldIds[2] !== -1) {\n                    $p.uniform.uExtraKeyValue = seqFloat($p.fieldDomains[groupFieldIds[2]][0], $p.fieldDomains[groupFieldIds[2]][1])[ii];\n                }\n                \n                gl.ext.drawArraysInstancedANGLE(\n                    gl.POINTS, 0,\n                    $p.dataDimension[0],\n                    $p.dataDimension[1]\n                );\n            });\n        }\n        $p.uniform.uFieldCount.data = resultFieldIds.length;\n        if(getAvgValues) {\n            postCompute(opts, postComputeFieldIds, resultFieldIds, outputTag);\n        }\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    }\n\n    function postCompute(opts, postComputeFieldIds, resultFieldIds, outputTag) {\n        $p.uniform.uDataInput.data = $p.framebuffer.fAggrStats.texture;\n        var gl = $p.program('GetAggrStats');\n        $p.bindFramebuffer(outputTag);\n        $p.uniform.uResultDim = [$p.resultDimension[0] * $p.extraDimension, $p.resultDimension[1]];\n        $p.framebuffer.enableRead('fAggrStats');\n        // gl.ext.vertexAttribDivisorANGLE($p.attribute._square.location, 0);\n        \n        gl.viewport(0, 0, $p.resultDimension[0] * $p.extraDimension, $p.resultDimension[1] * resultFieldIds.length);\n        gl.disable(gl.BLEND);\n\n        postComputeFieldIds.forEach(function(f) {\n            $p.uniform.uAggrOpt = METRICS.indexOf(opts[f]);\n            $p.uniform.uFieldId = f;\n            gl.viewport(\n                0, \n                f * $p.resultDimension[1], \n                $p.resultDimension[0] * $p.extraDimension,\n                $p.resultDimension[1]\n            );\n            gl.drawArrays(gl.TRIANGLES, 0, 6);\n        })\n    }\n\n    aggregate.execute = function(spec) {\n        let newFieldSpec = spec.$collect || spec.$reduce || null;\n        let groupFields = spec.$group || spec.group;\n        let groupFieldIds = [-1, -1, -1];\n        let outputTag = spec.out || 'fGroupResults';\n        if (!Array.isArray(groupFields)) groupFields = [groupFields];\n        if (groupFields.length >= 2) {\n            groupFieldIds[0] = $p.fields.indexOf(groupFields[0]);\n            groupFieldIds[1] = $p.fields.indexOf(groupFields[1]);\n            $p.resultDimension = [\n                $p.fieldWidths[groupFieldIds[0]],\n                $p.fieldWidths[groupFieldIds[1]]\n            ];\n            if(groupFields.length === 3) {\n                groupFieldIds[2] = $p.fields.indexOf(groupFields[2]);\n                $p.extraDimension = $p.fieldWidths[groupFieldIds[2]];\n            } else {\n                $p.extraDimension = 1\n            }\n        } else {\n            groupFieldIds[0] = $p.fields.indexOf(groupFields[0]);\n            $p.resultDimension = [$p.fieldWidths[groupFieldIds[0]], 1];\n        }\n\n        // For backward compatibility, allowing new fields specified without using the $collect or $reduce\n        if (newFieldSpec === null) {\n            newFieldSpec = {};\n            Object.keys(spec)\n            .filter(d => d != '$by' && d != '$group')\n            .forEach(function(d) {\n                newFieldSpec[d] = spec[d];\n            });\n        }\n\n        let newFieldNames = Object.keys(newFieldSpec);\n        let resultFields = newFieldNames.map(f => newFieldSpec[f][Object.keys(newFieldSpec[f])[0]]);\n        let resultFieldIds = resultFields.map( f => (f == '*') ? 0 : $p.fields.indexOf(f));\n        let operators = resultFields.map( (f,i) => { \n            return (typeof(newFieldSpec[newFieldNames[i]]) === 'object')\n                ? Object.keys(newFieldSpec[newFieldNames[i]])[0]\n                : newFieldSpec[newFieldNames[i]]\n        });\n        let twoPassFields = operators.filter(opt => METRICS.indexOf(opt) > 2 );\n\n        if (!$p._update && !$p._progress) {\n            $p.framebuffer(\n                outputTag,\n                'float', [$p.resultDimension[0] * $p.extraDimension, $p.resultDimension[1] * resultFieldIds.length]\n            );\n\n            if(twoPassFields.length > 0) {\n                $p.framebuffer(\n                    'fAggrStats',\n                    'float', [$p.resultDimension[0] * $p.extraDimension, $p.resultDimension[1] * resultFieldIds.length]\n                );\n            }\n        }\n        $p.bindFramebuffer(outputTag);\n\n        compute(operators, groupFieldIds, resultFieldIds, outputTag);\n\n        $p.getResult = aggregate.result;\n        $p.indexes = groupFields;\n        $p.dataDimension = $p.resultDimension;\n        $p.uniform.uDataInput.data = $p.framebuffer[outputTag].texture;\n\n        var oldFieldIds = groupFields.concat(resultFields).map( f => $p.fields.indexOf(f));\n\n        $p.fields = groupFields.concat(newFieldNames);\n        $p.uniform.uDataDim.data = $p.resultDimension;\n        $p.uniform.uIndexCount.data = $p.indexes.length;\n        $p.fieldCount = $p.fields.length - $p.indexes.length;\n        $p.uniform.uFieldCount.data = $p.fieldCount;\n\n        // $p.fieldWidths = $p.fieldWidths.concat($p.deriveWidths);\n        // $p.fieldDomains = $p.fieldDomains.concat($p.deriveDomains);\n       \n        let newFieldDomains = oldFieldIds.map(f => $p.fieldDomains[f]);\n        let newFieldWidths = oldFieldIds.map(f => $p.fieldWidths[f]);\n        \n        oldFieldIds.slice(0, groupFields.length).forEach((fid, fii) => {\n            if($p.uniform.uBinCount.data[fii] > 0) {\n                newFieldDomains[fii] = [0, $p.uniform.uBinCount.data[fii]-1];\n            }\n        })\n        $p.uniform.uBinCount.data = [0,0];\n\n        $p.fieldDomains = newFieldDomains;\n        $p.fieldWidths = newFieldWidths;\n       \n        $p.attribute.aDataItemId = seqFloat(0, $p.resultDimension[0] * $p.resultDimension[1] - 1);\n        $p.dataSize = $p.resultDimension[0] * $p.resultDimension[1];\n        $p.uniform.uDataSize.data = $p.dataSize;\n        $p.uniform.uFieldDomains.data = $p.fieldDomains;\n        $p.uniform.uFieldWidths.data = $p.fieldWidths;\n        $p.uniform.uFilterFlag.data = 0;\n\n        $p.indexes.forEach(function(d, i) {\n            $p.attribute['aDataId' + VEC_IDS[i]] = seqFloat(0, $p.resultDimension[i]-1);\n            var interval = 1;\n            var ifid = $p.fields.indexOf(d);\n            // if ($p.intervals.hasOwnProperty(d)) interval = $p.intervals[d].interval;\n            $p.attribute['aDataVal' + VEC_IDS[i]] = seqFloat(\n                $p.fieldDomains[ifid][0],\n                $p.fieldDomains[ifid][1],\n                interval\n            );\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute['aDataId' + VEC_IDS[i]].location, i);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute['aDataVal' + VEC_IDS[i]].location, i);\n        });\n        if ($p.indexes.length == 1) {\n            $p.attribute.aDataIdy = new Float32Array(1);\n            $p.attribute.aDataValy = new Float32Array(1);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdy.location, 1);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataValy.location, 1);\n        }\n        if (!$p._update) {\n            let resultFieldIds = resultFields.map( f => (f == '*') ? 0 : $p.fields.indexOf(f));\n            resultDomains = $p.extent(resultFieldIds, $p.dataDimension);\n        }\n        for (var ii = $p.indexes.length; ii < $p.indexes.length + resultFields.length; ii++) {\n            $p.fieldDomains[ii] = resultDomains[ii - $p.indexes.length];\n            $p.fieldWidths[ii] = resultDomains[ii - $p.indexes.length][1] - resultDomains[ii - $p.indexes.length][0];\n        }\n        $p.getResultBuffer = aggregate.result;\n        // console.log(aggregate.result({outputTag}))\n    }\n\n    aggregate.result = function(arg) {\n        let options = arg || {};\n        let outputTag =  arg.outputTag || 'fGroupResults';\n        let offset = options.offset || [0, 0];\n        let resultSize = options.size || $p.resultDimension[0] * $p.resultDimension[1];\n        let rowTotal = Math.min(resultSize, $p.resultDimension[0]);\n        let colTotal = Math.ceil(resultSize / $p.resultDimension[0]);\n        let result = new Float32Array(rowTotal * colTotal * 4 * resultFieldCount);\n        $p.bindFramebuffer(outputTag);\n        let gl = $p.program('AggregateCompute');\n        gl.readPixels(offset[0], offset[1], rowTotal, colTotal * resultFieldCount, gl.RGBA, gl.FLOAT, result);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        return result.filter((d, i) => i % 4 === 3);\n    }\n\n    return aggregate;\n}\n","export default function cache($p) {\n    var cache = {},\n        dataDimension = $p.uniform.uDataDim.data,\n        fieldCount =  $p.uniform.uFieldCount.data,\n        cacheTag;\n\n    var vs = $p.shader.vertex(function () {\n         gl_Position = vec4(this._square, 0, 1);\n    });\n\n    var fs = $p.shader.fragment(function () {\n        var x, y;\n\n        x = (gl_FragCoord.x) / this.uDataDim.x;\n        y = (gl_FragCoord.y) / (this.uDataDim.y * float(this.uFieldCount));\n\n        gl_FragColor = texture2D(this.uDataInput, vec2(x, y));\n    });\n\n    $p.program(\"cache\", vs, fs);\n\n    cache.execute = function(tag) {\n        cacheTag = tag;\n        dataDimension = $p.uniform.uDataDim.data;\n        fieldCount = $p.uniform.uFieldCount.data;\n        $p.framebuffer(tag, \"float\", [dataDimension[0], dataDimension[1] * fieldCount]);\n        $p.bindFramebuffer(tag);\n        var gl = $p.program(\"cache\");\n        gl.viewport(0, 0, dataDimension[0], dataDimension[1] * fieldCount);\n        gl.clearColor( 0.0, 0.0, 0.0, 0.0 );\n        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );\n        gl.disable(gl.CULL_FACE);\n        gl.disable(gl.DEPTH_TEST);\n        gl.disable(gl.BLEND);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        $p.framebuffer.enableRead(tag);\n        $p.uniform.uDataInput = $p.framebuffer[tag].texture;\n        $p.getResultBuffer = cache.result;\n    }\n\n    cache.result =  function() {\n        var gl = $p.ctx;\n        $p.bindFramebuffer(cacheTag);\n        dataDimension = $p.uniform.uDataDim.data;\n        var result = new Float32Array(dataDimension[0]*dataDimension[1]*4*fieldCount);\n        gl.readPixels(0, 0, dataDimension[0], dataDimension[1] * fieldCount, gl.RGBA, gl.FLOAT, result);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        result = result.filter(function(d, i){ return i%4===3;} );\n\n        return result;\n    }\n\n    return cache;\n}\n","import {getHour, getDayOfWeek, getMonth, getYear} from '../gljs/datetime.gl'\n\nexport default function derive($p, spec) {\n\n  let derive = {};\n  let dataDimension = $p.uniform.uDataDim.data;\n  let deriveMax = $p.uniform.uDeriveCount.data;\n  let derivedFields = Object.keys(spec);\n\n  let fields = $p.fields;\n  if(derivedFields.length > $p.deriveMax) {\n    throw Error('Error: cannot derive more than ' + $p.deriveMax + ' new attributes');\n  }\n\n  $p.subroutine(\"hour\", \"float\", getHour);\n  $p.subroutine(\"month\", \"float\", getMonth);\n  $p.subroutine(\"year\", \"float\", getYear);\n  $p.subroutine(\"dayOfWeek\", \"float\", getDayOfWeek);\n\n  let marco = \"\\t\";\n\n  derivedFields.forEach(function(d, i){\n    let re = new RegExp(\"(\"+fields.join(\"|\")+\")\",\"g\");\n    // let formula = spec[d].replace(/@([\\w|\\d|_]+)/g, function(matched){\n    let formula = spec[d].replace(re, function(matched){\n      // console.log(matched);\n      let index = fields.indexOf(matched);\n      return 'this.getNonIndexedData ('  + index + ', pos.x, pos.y)';\n    });\n    marco += 'if (index == ' + i + ') return ' + formula + \"; \\n \\telse \";\n  });\n\n  marco = marco.replace(/\\$/g, 'this.') + \" return 0.0;\";\n\n  $p.uniform(\"uOptMode\", \"float\", 0)\n    .uniform(\"uDeriveId\", \"int\", 0)\n    .subroutine(\"getDerivedValue\", \"float\", new Function(\"$int_index\", \"$vec2_pos\", marco));\n\n  function vertexShader() {\n    gl_PointSize = 1.0;\n\n    var i, j;\n\n    i = (this.aDataIdx+0.5) / this.uDataDim.x;\n    j = (this.aDataIdy+0.5) / this.uDataDim.y;\n\n    this.vResult = this.getDerivedValue(this.uDeriveId, vec2(i, j));\n    if(this.uFilterFlag == 1) {\n      if(texture2D(this.fFilterResults, vec2(i, j)).a == 0.0)\n        this.vResult = 0.0;\n    }\n    var x, y;\n    if(this.uOptMode == 0.0){\n      x = 0.5;\n      y = 0.5;\n    } else {\n      x = i * 2.0 - 1.0;\n      y = j * 2.0 - 1.0;\n    }\n\n    gl_Position = vec4(x, y, 0.0, 1.0);\n  }\n\n  function fragmentShader() {\n    if(this.vResult == 0.0) discard;\n    if(this.uOptMode > 0.0 || this.vResult >= 0.0)\n      gl_FragColor = vec4(0.0, 0.0, 1.0, this.vResult);\n    else\n      gl_FragColor = vec4(-1.0, this.vResult, 0.0, 0.0);\n  }\n\n  var vs = $p.shader.vertex(vertexShader),\n    fs = $p.shader.fragment(fragmentShader),\n    gl = $p.createProgram(\"derive\", vs, fs);\n\n  // gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdx.location, 0);\n  // gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataValx.location, 0);\n  // gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdy.location, 1);\n  // gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataValy.location, 1);\n\n  function _execute() {\n    var gl = $p.program(\"derive\");\n    $p.framebuffer.enableRead(\"fFilterResults\");\n    $p.bindFramebuffer(\"fDerivedValues\");\n    gl.disable(gl.CULL_FACE);\n    gl.disable(gl.DEPTH_TEST);\n    gl.enable( gl.BLEND );\n    gl.blendFunc( gl.ONE, gl.ONE );\n    gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdx.location, 0);\n    gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdy.location, 1);\n    \n    if($p.indexes.length > 0)\n      gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataValx.location, 0);\n     \n    if($p.indexes.length > 1)\n      gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataValy.location, 1);\n    $p.uniform.uOptMode = 0.0;\n    // $p.uniform.uDeriveCount = derivedFields.length;\n    var deriveDomains = [];\n    derivedFields.forEach(function(d, i){\n      $p.uniform.uDeriveId = i;\n      gl.clearColor( 0.0, 0.0, 0.0, 0.0 );\n      gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );\n      gl.viewport(0, 0, 1,  1);\n\n      var result = new Float32Array(8);\n\n      gl.blendEquation(gl.MAX_EXT);\n      gl.ext.drawArraysInstancedANGLE(gl.POINTS, 0, dataDimension[0], dataDimension[1]);\n      // gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.FLOAT, max);\n\n      gl.viewport(1, 0, 1,  1);\n      gl.ext.drawArraysInstancedANGLE(gl.POINTS, 0, dataDimension[0], dataDimension[1]);\n\n      gl.blendEquation(gl.MIN_EXT);\n      gl.ext.drawArraysInstancedANGLE(gl.POINTS, 0, dataDimension[0], dataDimension[1]);\n      gl.readPixels(0, 0, 2, 1, gl.RGBA, gl.FLOAT, result);\n\n      var minValue = (result[4] < 0) ? result[5] : result[7],\n        maxValue = (result[2] > 0) ? result[3] : result[1];\n      deriveDomains[i] = [minValue, maxValue];\n\n      // deriveDomains[i] = [Math.min(min[0], min[3]), Math.max(max[0], max[3])];\n    });\n    gl.viewport(0, 0, dataDimension[0], dataDimension[1]*deriveMax);\n    gl.disable( gl.BLEND );\n    gl.clearColor( 0.0, 0.0, 0.0, 0.0 );\n    gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );\n\n    $p.uniform.uOptMode = 1.0;\n\n    derivedFields.forEach(function(d, i){\n      $p.uniform.uDeriveId = i;\n      gl.viewport(0, dataDimension[1]*i, dataDimension[0], dataDimension[1]);\n      gl.ext.drawArraysInstancedANGLE(gl.POINTS, 0, dataDimension[0], dataDimension[1]);\n    });\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n    return deriveDomains;\n  }\n\n  derive.execute = function(spec) {\n    var derivedFields = Object.keys(spec);\n    var newDerivedDomains = _execute();\n    if(!$p._update) {\n      newDerivedDomains.forEach(function(d, i) {\n        var fieldId = $p.fields.indexOf(derivedFields[i]);\n        if(fieldId === -1) {\n          $p.fields.push(derivedFields[i]);\n          fieldId = $p.fields.indexOf(derivedFields[i]);\n          $p.deriveCount += 1;\n        }\n        $p.fieldDomains[fieldId] = d;\n        $p.fieldWidths[fieldId] = d[1] - d[0] + 1;\n      });\n      $p.uniform.uFieldDomains.value($p.fieldDomains);\n      $p.uniform.uFieldWidths.data = $p.fieldWidths;\n    }\n  }\n\n  derive.result = function(arg) {\n    var options = arg || {},\n      offset = options.offset || [0, 0],\n      resultSize = options.size || $p.dataDimension[0]* $p.dataDimension[1],\n      fid = options.fieldId || options.deriveFieldId || 0,\n      rowSize = Math.min(resultSize, $p.dataDimension[0]),\n      colSize = Math.ceil(resultSize/$p.dataDimension[0]);\n    \n    $p.bindFramebuffer('DerivedValues');\n    var result = new Float32Array(rowSize * colSize * 4);\n    gl.readPixels(0, dataDimension[1]*fid, rowSize, colSize, gl.RGBA, gl.FLOAT, result);\n    return result.filter(function(d, i){ return i%4===3;} ); //return channel alpha in rgba\n  }\n\n  return derive;\n}\n","\nconst smallest = -Math.pow(2, 128);\nexport default function extent($p) {\n\n    var vs = $p.shader.vertex(function() {\n        gl_PointSize = 1.0;\n        var i, j;\n        if (this.aDataIdy * this.uDataDim.x + this.aDataIdx >= this.uDataSize) {\n            this.vDiscardData = 1.0;\n        } else {\n            this.vDiscardData = 0.0;\n            i = (this.aDataIdx + 0.5) / this.uDataDim.x;\n            j = (this.aDataIdy + 0.5) / this.uDataDim.y;\n            this.vResult = this.getData(this.uFieldId, i, j);\n        }\n        gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n    });\n\n    var fs = $p.shader.fragment(function() {\n        if (this.vDiscardData == 1.0) discard;\n        if (this.vResult >= 0.0) {\n            gl_FragColor = vec4(0.0, 0.0, 1.0, this.vResult);\n        } else {\n            gl_FragColor = vec4(-1.0, this.vResult, 0.0, 0.0);\n        }\n    });\n\n    var gl = $p.program(\"stats\", vs, fs);\n\n    return function(fieldIds, dataDimension) {\n        if (!$p._update) {\n            $p.framebuffer(\"fStats\", \"float\", [2, fieldIds.length]);\n        }\n        var gl = $p.program(\"stats\");\n        $p.framebuffer.enableRead(\"fGroupResults\");\n\n        gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdx.location, 0);\n        gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataValx.location, 0);\n        gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdy.location, 1);\n        gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataValy.location, 1);\n\n        $p.bindFramebuffer(\"fStats\");\n        gl.clearColor(smallest, smallest, smallest, smallest);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        gl.disable(gl.CULL_FACE);\n        gl.disable(gl.DEPTH_TEST);\n        gl.enable(gl.BLEND);\n        gl.blendFunc(gl.ONE, gl.ONE);\n\n        var extents = new Array(fieldIds.length);\n\n        var idCount = $p.uniform.uIndexCount.data;\n        fieldIds.forEach(function(d, i) {\n            $p.uniform.uFieldId = i + idCount;\n            gl.viewport(0, i, 1, 1);\n            gl.blendEquation(gl.MAX_EXT);\n            gl.ext.drawArraysInstancedANGLE(gl.POINTS, 0, dataDimension[0], dataDimension[1]);\n            // gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.FLOAT, max);\n\n            gl.viewport(1, i, 1, 1);\n            gl.ext.drawArraysInstancedANGLE(gl.POINTS, 0, dataDimension[0], dataDimension[1]);\n\n            gl.blendEquation(gl.MIN_EXT);\n            gl.ext.drawArraysInstancedANGLE(gl.POINTS, 0, dataDimension[0], dataDimension[1]);\n\n            // var extent = new Float32Array(8);\n            // gl.readPixels(0, i, 2, 1, gl.RGBA, gl.FLOAT, extent);\n            // console.log(extent);\n            // var ext = extent;\n            // var minValue = (ext[0] > 0) ? ext[1] : ext[7],\n            //     maxValue = (ext[2] > 0) ? ext[3] : ext[5];\n            //  extents[i] = [minValue, maxValue];\n        });\n        var extent = new Float32Array(8 * fieldIds.length);\n       \n        gl.readPixels(0, 0, 2, fieldIds.length, gl.RGBA, gl.FLOAT, extent);\n        fieldIds.forEach(function(d, i) {\n            var ext = extent.slice(i * 8, i * 8 + 8);\n            var minValue = (ext[4] < 0) ? ext[5] : ext[7],\n                maxValue = (ext[2] > 0) ? ext[3] : ext[1];\n            extents[i] = [minValue, maxValue];\n        });\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        return extents;\n    }\n}\n","import {IntervalMatch, DiscreteMatch} from '../gljs/Match.gl'\n\nexport default function match($p) {\n    const SELECT_MAX = 100;\n    let match = {};\n    let dataDimension = $p.uniform.uDataDim.data;\n    let fieldCount = $p.fields.length;\n    let filterControls = new Array(fieldCount).fill(0);\n    let filterRanges = $p.fieldDomains;\n    let visControls = new Array(fieldCount).fill(0);\n    let visRanges = $p.fieldDomains;\n    let inSelections = new Array(SELECT_MAX);\n    let matchResultBuffer = null;\n\n    $p.uniform('uInSelections', 'float', Float32Array.from(inSelections));\n    $p.uniform('uSelectMax', 'int', SELECT_MAX);\n    $p.uniform('uSelectCount', 'int', 0);\n\n    let rangeMatch = {\n        vs: $p.shader.vertex(IntervalMatch.vertexShader),\n        fs: $p.shader.fragment(IntervalMatch.fragmentShader)\n    };\n\n    let inMatch = {\n        vs: $p.shader.vertex(DiscreteMatch.vertexShader),\n        fs: $p.shader.fragment(DiscreteMatch.fragmentShader)\n    };\n\n    $p.program('IntervalMatch', rangeMatch.vs, rangeMatch.fs);\n    $p.program('DiscreteMatch', inMatch.vs, inMatch.fs);\n\n    match.control = function(ctrl) {\n        filterControls = ctrl;\n    }\n\n    function _execute(spec){\n        var fields = $p.fields;\n        var gl;\n        var matchFields = Object.keys(spec).filter(function(s){\n            return spec[s].hasOwnProperty('$in');\n        })\n        .concat(Object.keys($p.crossfilters).filter(function(s){\n            return $p.crossfilters[s].hasOwnProperty('$in');\n        }))\n\n        $p.bindFramebuffer('fFilterResults');\n       \n        $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdy.location, 1);\n        $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataValy.location, 1);\n        if(matchFields.length) {\n            gl = $p.program('DiscreteMatch');\n            if($p.deriveCount > 0) {\n                $p.framebuffer.enableRead('fDerivedValues');\n            }\n\n            gl.viewport(0, 0, dataDimension[0], dataDimension[1]);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdx.location, 0);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataValx.location, 0);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdy.location, 1);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataValy.location, 1);\n            gl.clearColor( 1.0, 1.0, 1.0, 1.0 );\n            gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );\n            gl.enable( gl.BLEND );\n            gl.blendFunc( gl.ONE, gl.ONE );\n            gl.blendEquation(gl.MIN_EXT);\n\n            matchFields.forEach(function(k){\n                var fieldId = $p.fields.indexOf(k);\n                var inSelections = (spec.hasOwnProperty(k)) ? spec[k].$in :  $p.crossfilters[k].$in;\n                if($p.strValues.hasOwnProperty(k)) {\n                    inSelections = inSelections\n                        .slice(0, SELECT_MAX)\n                        .map(function(v) { return $p.strValues[k][v]; });\n                } else {\n                    inSelections = inSelections.slice(0, SELECT_MAX);\n                }\n                $p.uniform.uSelectCount = inSelections.length;\n                $p.uniform.uInSelections = Float32Array.from(inSelections);\n                $p.uniform.uFieldId = fieldId;\n\n                gl.ext.drawArraysInstancedANGLE(gl.POINTS, 0, $p.dataDimension[0], $p.dataDimension[1]);\n                // filterRanges[fieldId*2] = Math.min.apply(null, spec[k].$in);\n                // filterRanges[fieldId*2+1] = Math.max.apply(null, spec[k].$in);\n                filterRanges[fieldId] = [Math.min.apply(null, inSelections), Math.max.apply(null, inSelections)];\n            })\n        }\n\n        var filterSelections = Object.keys(spec).filter(function(s){\n            return !spec[s].hasOwnProperty('$in');\n        });\n\n        var viewSelections = Object.keys($p.crossfilters).filter(function(s){\n            return !$p.crossfilters[s].hasOwnProperty('$in'); \n        });\n     \n        if(filterSelections.length || viewSelections.length){\n            filterControls = new Array(fieldCount).fill(0);\n\n            filterSelections.forEach(function(k){\n                var fieldId = $p.fields.indexOf(k);\n                if(fieldId === -1) {\n                    console.log('Skipped: Matching on invalid data field ' + k);\n                    return;\n                }\n                if(spec[k].length < 2) spec[k][1] = spec[k][0];\n                filterControls[fieldId] = 1;\n                filterRanges[fieldId] = spec[k];\n                // filterRanges[fieldId*2] = spec[k][0];\n                // filterRanges[fieldId*2+1] = spec[k][1];\n            });\n\n            viewSelections.forEach(function(k){\n                var fieldId = $p.fields.indexOf(k);\n                if(fieldId === -1) {\n                    console.log('Skipped: Matching on invalid data field ' + k);\n                    return;\n                }\n                if($p.crossfilters[k].length < 2) $p.crossfilters[k][1] = $p.crossfilters[k][0];\n                visControls[fieldId] = 1;\n                visRanges[fieldId] = $p.crossfilters[k];\n            });\n\n            $p.uniform.uFilterControls.data = filterControls;\n            $p.uniform.uFilterRanges.data = filterRanges;\n            $p.uniform.uVisControls.data = visControls;\n            $p.uniform.uVisRanges.data = visRanges;\n\n            if (matchFields.length) {\n                matchResultBuffer= match.result();\n                $p.bindFramebuffer('fFilterResults');\n            }\n\n            gl = $p.program('IntervalMatch');\n            if($p.deriveCount > 0) {\n                $p.framebuffer.enableRead('fDerivedValues');\n            }\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdx.location, 0);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataValx.location, 0);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdy.location, 1);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataValy.location, 1);\n            gl.disable(gl.BLEND);\n            // gl.clearColor( 0.0, 0.0, 0.0, 0.0 );\n            // gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );\n            gl.viewport(0, 0, $p.dataDimension[0], $p.dataDimension[1]);\n            gl.ext.drawArraysInstancedANGLE(gl.POINTS, 0, $p.dataDimension[0], $p.dataDimension[1]);\n        }\n        $p.ctx.bindFramebuffer($p.ctx.FRAMEBUFFER, null);\n        return filterRanges;\n    }\n\n    match.execute = function(spec, skipUpdateDomain = false) {\n        filterControls = new Array($p.fields.length).fill(0);\n        visControls = new Array($p.fields.length).fill(0);\n        var filterSpec = spec;\n\n        Object.keys($p.crossfilters).forEach(function(k, i) {\n            if($p.strValues.hasOwnProperty(k) && !$p.crossfilters[k].$in) {\n                let filterValues = $p.crossfilters[k];\n                if(filterValues.length > 1) {\n                    let startIndex = $p.strLists[k].indexOf($p.crossfilters[k][0]);\n                    let endIndex = $p.strLists[k].indexOf($p.crossfilters[k][1]);\n                    filterValues = $p.strLists[k].slice(startIndex, endIndex + 1);\n                }\n                $p.crossfilters[k] = {$in: filterValues};\n            }\n        });\n\n        Object.keys(filterSpec).forEach(function(k, i) {\n            if($p.strValues.hasOwnProperty(k) && !spec[k].$in) {\n                spec[k] = {$in: spec[k]};\n            }\n        });\n\n        $p.uniform.uFilterFlag.data = 1;\n        if(!$p._update) {\n           \n            $p.framebuffer('fFilterResults', 'unsigned_byte', $p.dataDimension);\n            filterRanges = $p.fieldDomains.slice();\n            visRanges = $p.fieldDomains.slice();\n        }\n        var newDomains = _execute(spec);\n\n        if(!$p._update){\n            newDomains.forEach(function(domain, fid) {\n                var d = domain;\n                // if($p.dtypes[fid] == 'int') d[1] -= 1;\n                $p.fieldDomains[fid] = d;\n                $p.fieldWidths[fid] = $p.getDataWidth(fid, d);\n            });\n\n            $p.uniform.uFieldDomains.value($p.fieldDomains);\n            $p.uniform.uFieldWidths.data = $p.fieldWidths;\n        }\n        $p.getMatchBuffer = match.result;\n    }\n\n    match.result = function(arg) {\n        var options = arg || {},\n            offset = options.offset || [0, 0],\n            resultSize = options.size || $p.dataDimension[0]* $p.dataDimension[1],\n            rowSize = Math.min(resultSize, $p.dataDimension[0]),\n            colSize = Math.ceil(resultSize/$p.dataDimension[0]);\n\n        $p.bindFramebuffer('fFilterResults');\n\n        var gl = $p.ctx;\n        var bitmap = new Uint8Array(rowSize*colSize*4);\n        gl.readPixels(offset[0], offset[1], rowSize, colSize, gl.RGBA, gl.UNSIGNED_BYTE, bitmap);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        let result = bitmap.filter((d, i) => i % 4 === 3);\n        if(matchResultBuffer !== null) {\n            result = result.map((r,i) => r & matchResultBuffer[i])\n            matchResultBuffer = null\n        }\n        \n        return result;\n    }\n\n    return match;\n}\n","export default function pipeline($p) {    \n    let pipeline = {};\n    let async = false;\n    let optID = 0;\n    let queue = [];\n    \n    pipeline.addModule = function(mod) {\n        let newModule = mod($p)\n\n        Object.keys(newModule).forEach(name => {\n            if (typeof(newModule[name]) === 'function') {\n                pipeline[name] = function() {\n                    newModule[name].apply(null, arguments);\n                    return pipeline;\n                }\n            }\n        })\n        return pipeline;\n    }\n\n    pipeline.assignMethods = function(mod) {\n        let newModule = mod($p)\n\n        Object.keys(newModule).forEach(name => {\n            if (typeof(newModule[name]) === 'function') {\n                pipeline[name] = function() {\n                    return newModule[name].apply(null, arguments);\n                }\n            }\n        })\n        return pipeline;\n    }\n\n    pipeline.addToQueue = function (opt, arg) {\n        if(!$p._update && !$p._progress) {\n            let spec = {};\n            spec[opt] = arg;\n            queue.push(spec);\n            return optID++;\n        } else {\n            return -1;\n        }\n    }\n\n    pipeline.addOperation = function(name, operation, overwrite = false) {\n        if(!pipeline.hasOwnProperty(name) || overwrite) {\n            pipeline[name] = function(arg) {\n                if(!async) {\n                    pipeline.addToQueue(name, arg);\n                }\n                let getResult = operation(arg);\n                if(typeof(getResult) === 'function') {\n                    $p.getResult = getResult;\n                }\n                return pipeline;\n            }\n        }   \n    }\n\n    pipeline.clearQueue = function() {\n        queue = [];\n        return pipeline;\n    }\n\n    pipeline.run = function(jobs = queue) {\n        for (let q of jobs) {\n            let opt = Object.keys(q)[0];\n            if(typeof pipeline[opt] === 'function') {\n                pipeline[opt](q[opt]);\n            }\n        }\n        return pipeline;\n    }\n\n    pipeline.queue = function() {\n        return queue;\n    }\n\n    pipeline.async = function(isAsync) {\n        async = isAsync;\n    }\n\n    return pipeline;\n}","import * as ctypes from './ctypes';\n\nexport function seq(dtype, start, end, interval) {\n    var step = interval || 1,\n        size = (end - start) / step + 1,\n        buf;\n\n    buf = new ctypes[dtype](size);\n    for (var i = 0; i < size; i++) {\n        buf[i] = start + i * step;\n    }\n    return buf;\n}\n\nexport let seqInt = seq.bind(null, \"int\");\nexport let seqFloat = seq.bind(null, \"float\");\n","import Scale from './scale';\n\nexport default function axis(arg) {\n\n    var option = arg || {},\n        svg = option.container || option.parent,\n        dim = option.dim || \"x\",\n        color = option.color || \"#000\",\n        position = option.position || 0,\n        align = option.align || \"\",\n        scale = option.scale || \"linear\",\n        exponent = option.exponent || 1,\n        metric = option.metric || null,\n        domain = option.domain || [0, 1],\n        width = option.width || svg.innerWidth(),\n        height = option.height || svg.innerHeight(),\n        padding = option.padding || svg.padding() || {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        },\n        range = option.range || (dim == \"x\") ? [0, width] : [height, 0],\n        styles = {\n            stroke: color,\n            'stroke-width': 1\n        },\n        ticks = option.ticks,\n        tickLength = option.tickLength || 6,\n        tickPosition = option.tickPosition || [0, 0],\n        tickInterval = option.tickInterval || \"auto\",\n        tickAlign = option.tickAlign || \"center\",\n        skipLast = option.skipLast || false,\n        tickFormat = option.tickFormat || null,\n        grid = option.grid,\n        format = option.format || function (_) {return _;},\n        visable = option.visable || true,\n        domainIntervals,\n        labelPos = null,\n        labelAngle = option.labelAngle || 0,\n        X = [],\n        Y = [];\n\n    if (typeof (ticks) != \"number\") {\n        ticks = (dim == \"x\") ? Math.ceil(width / 50) : Math.ceil(height / 50);\n    }\n    var tickLabelAlign = option.tickLabelAlign || \"end\";\n    switch (align) {\n        case \"left\" || \"center\":\n            labelPos = option.labelPos || {\n                x: -tickLength / 2,\n                y: -5\n            };\n            tickLabelAlign = option.tickLabelAlign || \"end\";\n            break;\n        case \"right\":\n            labelPos = option.labelPos || {\n                x: tickLength,\n                y: -5\n            };\n            tickLabelAlign = option.tickLabelAlign || \"start\";\n            if (!tickPosition) tickPosition = [tickLength / 2, 0];\n            break;\n        case \"top\":\n            labelPos = {\n                x: 0,\n                y: 0\n            };\n            tickLabelAlign = \"middle\";\n            if (!tickPosition) tickPosition = [0, -tickLength];\n            break;\n        case \"bottom\" || \"middle\":\n            labelPos = option.labelPos || {\n                x: 0,\n                y: -tickLength * 3\n            };\n            tickLabelAlign = option.tickLabelAlign || \"middle\";\n            break;\n        default:\n            labelPos = option.labelPos || option.labelPosition || {\n                x: 0,\n                y: 0\n            };\n            break;\n    }\n\n    function getTickInterval() {\n        var vDomain = Math.abs(domain[1] - domain[0]),\n            intv = vDomain / ticks,\n            pow = Math.ceil(Math.log10(intv)),\n            intv = intv / Math.pow(10, pow);\n\n        if (intv > 0.2 && intv <= 0.25) {\n            intv = 0.25;\n        } else if (intv > 0.7 && intv <= 0.75) {\n            intv = 0.75;\n        } else {\n            intv = Math.ceil(intv * 10) / 10;\n        }\n        return intv * Math.pow(10, pow);\n    }\n\n    if (scale == \"categorical\" || scale == \"ordinal\") {\n        domainIntervals = function () {\n            if(domain.length > 20) {\n                var dstep = Math.floor(domain.length / 20);\n                return domain.filter( (d,di) => di % dstep === 0)\n            }\n            return domain;\n        };\n    } else {\n        var intv;\n\n        if (tickInterval == \"auto\") {\n            intv = getTickInterval();\n\n        } else {\n            if (typeof (tickInterval) == \"number\") {\n                intv = tickInterval;\n            } else {\n                // intv = Math.abs(domain[1] - domain[0]) / ticks;\n                intv = getTickInterval();\n                domain[0] = intv * Math.floor(domain[0] / intv);\n                domain[1] = intv * Math.ceil(domain[1] / intv);\n            }\n        }\n\n        domainIntervals = function () {\n            var di = [];\n\n            if (domain[0] > domain[1]) {\n                domain[0] += intv;\n                for (var i = domain[0]; i > domain[1]; i = i - intv)\n                    di.push(i);\n            } else {\n                for (var i = domain[0]; i < domain[1]; i = i + intv)\n                    di.push(i);\n            }\n\n            if (di[di.length - 1] != domain[1] && !isNaN(domain[1]) && !skipLast) {\n\n                if ((domain[1] - di[di.length - 1]) < 0.4 * intv)\n                    di[di.length - 1] = domain[1];\n                else\n                    di.push(domain[1]);\n            }\n            return di;\n        }\n    }\n\n    if (metric === null) {\n\n        var scaleOptions = {\n            align: tickAlign,\n            type: scale,\n            domain: domain,\n            range: range\n        };\n\n        if (scale == \"power\") {\n            scaleOptions.exponent = exponent;\n        }\n\n        metric = Scale(scaleOptions)\n    } else {\n        domain = metric.domain();\n    }\n\n    var axis = svg.append(\"g\");\n\n    if (dim == 'x') {\n        if (!position && align) {\n            position = [0, height / 2, height];\n            position = position[[\"top\", \"middle\", \"bottom\"].indexOf(align)];\n        }\n        Y[0] = Y[1] = position;\n        X[0] = 0;\n        X[1] = Math.abs(range[1] - range[0]);\n    } else {\n        if (!position && align) {\n            position = [0, width / 2, width];\n            position = position[[\"left\", \"center\", \"right\"].indexOf(align)];\n        }\n        X[0] = X[1] = position;\n        Y[0] = 0;\n        Y[1] = Math.abs(range[1] - range[0]);\n    }\n\n    metric.show = metric.axis = function () {\n        axis.append(\"g\")\n            .append(\"line\")\n            .Attr({\n                x1: X[0],\n                x2: X[1],\n                y1: Y[0],\n                y2: Y[1]\n            })\n            .Style(styles);\n\n        var di = domainIntervals();\n\n        for (var i = 0; i < di.length; i++) {\n            var x1, x2, y1, y2;\n            if (dim == 'x') {\n                x1 = x2 = metric(di[i]) + tickPosition[0];\n                y1 = position + tickPosition[1] + tickLength;\n                y2 = y1 - tickLength;\n            } else {\n                y1 = y2 = metric(di[i]) + tickPosition[1];\n                x1 = position + tickPosition[0];\n                x2 = x1 - tickLength;\n            }\n\n            var svgTicks = axis.append(\"g\");\n            svgTicks.append(\"line\", {\n                x1: x1,\n                x2: x2,\n                y1: y1,\n                y2: y2,\n            }, styles);\n\n\n            // if (dim == 'x') tickLabelAlign = \"middle\";\n            // if (dim == 'x' && labelAngle) tickLabelAlign = \"end\";\n\n            var tickLabel = svgTicks.append(\"text\")\n                .Attr({\n                    x: x2 + labelPos.x,\n                    y: y2 - labelPos.y,\n                    class: \"p4-axis-label\",\n                    \"font-size\": \"0.9em\",\n                    textAnchor: tickLabelAlign\n                });\n            if (labelAngle) tickLabel.attr(\"transform\", \"rotate(\" + [labelAngle, (x2 + labelPos.x), (y2 - labelPos.y)].join(\",\") + \")\");\n\n            var labelText = (typeof (tickFormat) == \"function\") ? format(tickFormat(di[i])) : format(di[i]);\n            // tickLabel.appendChild( document.createTextNode(labelText) );\n            tickLabel.text(labelText);\n\n            if (grid) {\n                var gx1, gx2, gy1, gy2;\n                if (dim == 'x') {\n                    gx1 = gx2 = metric(di[i]);\n                    gy1 = 0;\n                    gy2 = height;\n                } else {\n                    gy1 = gy2 = metric(di[i]);\n                    gx1 = 0;\n                    gx2 = width;\n                }\n                axis.append(\"line\", {\n                    x1: gx1,\n                    x2: gx2,\n                    y1: gy1,\n                    y2: gy2,\n                    class: \"grid-lines\"\n                }, {\n                    \"stroke\": color,\n                    // \"stroke-width\": 0.5,\n                    \"stroke-opacity\": 0.15\n                });\n            }\n        }\n        axis.translate(padding.left, padding.top);\n        return axis;\n    };\n\n    metric.remove = function () {\n        axis.remove();\n    }\n\n    if (visable) {\n        metric.svg = metric.show();\n    }\n\n    return metric;\n};","export default function brush(arg){\n\n    var option = arg || {},\n        container = option.container || this.svg[0],\n        width = option.width || this.width,\n        height = option.height || this.height,\n        x = function(s) {return s},\n        y = function(s) {return s},\n        base = option.base || null,\n        selectX = option.x || false,\n        selectY = option.y || false,\n        border = option.border || \"#FFF\",\n        color = option.color || \"#111\",\n        brush = option.brush || function() {},\n        brushstart = option.brushstart || function() {},\n        brushend = option.brushend || function() {};\n\n    if(typeof(selectX) === \"function\") {\n        x = selectX;\n        selectX = true;\n    }\n    if(typeof(selectY) === \"function\") {\n        y = selectY;\n        selectY = true;\n    }\n    if(base === null){\n        base = container.append(\"g\").attr(\"class\", \"selector\");\n    } else {\n        base = container;\n    };\n\n    base.append(\"rect\")\n        .attr(\"x\", 0)\n        .attr(\"y\", 0)\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"fill-opacity\", 0)\n        .attr(\"stroke\", \"none\")\n        .css(\"cursor\", \"crosshair\");\n\n    var selector = base.append(\"rect\")\n        .attr(\"x\", 0)\n        .attr(\"y\", 0)\n        .attr(\"width\", 0)\n        .attr(\"height\", 0)\n        .attr(\"fill-opacity\", 0.1)\n        .css(\"fill\", color)\n        .css(\"stroke\", border)\n        .css(\"cursor\", \"move\");\n\n    var sx, sy,\n        dx, dy,\n        bx, by,\n        selection = {},\n        intStart = false,\n        drag = false;\n\n    base.svg.addEventListener(\"mousedown\", function(evt){\n        evt.preventDefault();\n        brushstart.call(this);\n        intStart = true;\n        sx = evt.clientX;\n        sy = evt.clientY;\n\n        var sp = selector.svg.getBoundingClientRect();\n        var box = base.svg.getBoundingClientRect();\n        var x0, y0, nw, nh;\n\n        if(sx>sp.left && sy>sp.top && sx<sp.left+sp.width && sy<sp.top+sp.height) {\n            drag = true;\n            bx = sp.left;\n            by = sp.top;\n        }\n\n        if(!drag){\n            x0 = selectX ? sx - box.left : 0;\n            y0 = selectY ? sy - box.top : 0;\n            selector.attr(\"x\", x0)\n                .attr(\"y\", y0)\n                .attr(\"width\", 0);\n        }\n\n        ondrag = function(evt){\n            if(intStart){\n                dx = evt.clientX - sx;\n                dy = evt.clientY - sy;\n                var selectorBox = selector.svg.getBoundingClientRect();\n                if(drag){\n\n                    var nx = bx + dx-box.left,\n                        ny = by + dy-box.top;\n\n                    if(bx+dx < box.left) nx = 0;\n                    if(bx+dx+selectorBox.width > box.right) nx = width - selectorBox.width ;\n                    if(by+dy < box.top) ny = 0;\n                    if(by+dy+selectorBox.height > box.bottom) ny = height - selectorBox.height;\n                    selector.attr(\"x\", nx).attr(\"y\", ny);\n                } else {\n                    if(evt.clientX < box.left) dx = box.left - sx;\n                    if(evt.clientX > box.right) dx = box.right - sx;\n                    if(evt.clientY > box.bottom) dy = box.bottom - sy;\n                    if(evt.clientY < box.top) dy = box.top - sy;\n\n                    x0 = selectX ? sx + dx - box.left: 0;\n                    y0 = selectY ? sy + dy - box.top : 0;\n                    nw = selectX ? Math.abs(dx) : width;\n                    nh = selectY ? Math.abs(dy) : height;\n\n                    if(dx<0 && dy>=0) selector.attr(\"x\", x0);\n                    if(dy<0 && dx>=0) selector.attr(\"y\", y0);\n                    if(dx<0 && dy<0) selector.attr(\"x\", x0).attr(\"y\", y0);\n                    selector.attr(\"width\", nw).attr(\"height\", nh);\n                }\n                if(selectX) {\n                    selection.x = [ x(selectorBox.left - box.left ), x(selectorBox.right - box.left )];\n                }\n                if(selectY) {\n                    selection.y = [y(selectorBox.top - box.top), y(selectorBox.bottom - box.top)];\n                }\n                brush.call(this, selection);\n            }\n        };\n\n        window.addEventListener(\"mousemove\", ondrag, false);\n        window.addEventListener(\"mouseup\", function(evt){\n            if(intStart){\n                ondrag(evt);\n                intStart = false;\n                if(drag){\n                    drag = false;\n                }\n            }\n            brushend.call(this, selection);\n            window.removeEventListener(\"mousemove\", ondrag, false);\n        }, false);\n    });\n};\n","import axis from './axis';\nimport format from './format';\nimport legend from './legend';\n\nexport default function chart(frontSvg, backSvg, arg) {\n    var options = arg || {},\n        plot = frontSvg.append('g'),\n        metavis = backSvg.append('g'),\n        frontMetaVis = frontSvg.append('g'),\n        width = options.width,\n        height = options.height,\n        top = options.top || 0,\n        left = options.left || 0,\n        vmap = options.vmap || {},\n        histogram =  options.histogram,\n        features = options.fields || [],\n        domain = options.domain,\n        strLists = options.strLists,\n        labels = plot.append('g'),\n        onclick = options.onclick || null,\n        onhover = options.onhover || null,\n        showLegend = options.legend,\n        tickOffset = options.axisOffset || [0, 0],\n        padding = options.padding || {left: 0, right: 0, top: 0, bottom: 0},\n        marks = [],\n        frameBorder = options.frameBorder || false,\n        gridlines = options.gridlines || {x: false, y: false},\n        colors = options.colors;\n\n    var scale = options.scale || {x: 'linear', y: 'linear'},\n        domainX = options.domainX || domain[vmap.x] || domain[vmap.width],\n        domainY = options.domainY || domain[vmap.y] || domain[vmap.height];\n\n    width -= padding.left + padding.right;\n    height -= padding.top + padding.bottom;\n\n    var axisOption = {\n        x: {\n            container: metavis,\n            dim: \"x\",\n            width: width,\n            height: height,\n            domain: domainX,\n            scale:  scale.x,\n            align: \"bottom\",\n            // ticks: 15,\n            grid: gridlines.x,\n            format: format(\".3s\"),\n        },\n        y: {\n            container: metavis,\n            dim: \"y\",\n            domain: domainY,\n            scale: scale.y,\n            width: width,\n            height: height,\n            align: \"left\",\n            // labelPos: {x: -5, y: -5},\n            // ticks: 8,\n            grid: gridlines.y,\n            format: format(\".3s\"),\n        }\n    };\n\n    let colorLegend;\n    if(showLegend && features.indexOf(vmap.color) !== -1){\n        colorLegend = legend({\n            container: metavis,\n            width: 20,\n            height: 180,\n            dim: \"y\",\n            domain: domain[vmap.color],\n            pos: [width + padding.right/2, 0],\n            colors: colors\n        });\n    }\n\n    let x, y, xAxes = [], yAxes = [];\n\n    // For parallel coordinates\n    if(Array.isArray(vmap.x)) {\n        let axisDist = height / (vmap.x.length-1);\n        axisOption.x.container = frontMetaVis;\n        vmap.x.forEach(function(d, i) {\n            axisOption.x.position = i * axisDist + 1;\n            axisOption.x.domain = domain[d];\n            if(strLists.hasOwnProperty(d)){\n                axisOption.x.scale = 'ordinal';\n                axisOption.x.tickAlign = 'outer';\n                axisOption.x.domain = strLists[d].reverse();\n            }\n            let labelOffset = 20;\n            if(i === 0) {\n                axisOption.x.tickPosition = [0, -5];\n                axisOption.x.labelPos = {x: 0, y: 2};\n                labelOffset = 35;\n            } else {\n                axisOption.x.tickPosition = null;\n                axisOption.x.labelPos = null;\n            }\n            x = axis(axisOption.x);\n            xAxes[i] = x;\n\n            labels\n            .append(\"text\")\n              .attr(\"x\", 5 )\n              .attr(\"y\", i * axisDist - labelOffset)\n              .attr(\"dy\", \"1em\")\n              .css(\"text-anchor\", \"middle\")\n              .css(\"font-size\", \"1em\")\n              .text(d);\n        });\n    }\n\n    if(Array.isArray(vmap.y)) {\n        var axisDist = width / (vmap.y.length-1);\n        axisOption.y.container = frontMetaVis;\n        vmap.y.forEach(function(d, i) {\n            axisOption.y.position = i * axisDist;\n            axisOption.y.domain = domain[d];\n            if(strLists.hasOwnProperty(d)){\n                axisOption.y.scale = 'ordinal';\n                axisOption.y.tickAlign = 'outer';\n                axisOption.y.domain = strLists[d].reverse();\n            }\n            if(i == vmap.y.length-1) {\n                axisOption.y.tickPosition = [5, 0];\n                axisOption.y.tickLabelAlign = \"start\";\n                axisOption.y.labelPos = {x: 8, y: -5};\n\n            }\n            y = axis(axisOption.y);\n            yAxes[i] = y;\n\n            labels.append(\"text\")\n              .attr(\"y\", -padding.top + 10)\n              .attr(\"x\", i * axisDist)\n              .attr(\"dy\", \"1em\")\n              .css(\"text-anchor\", \"middle\")\n              .css(\"font-size\", \"1em\")\n              .text(d);\n        });\n    }\n\n    let histDomain = {\n        x: domainX, \n        y: domainY\n    };\n    for(let dim of ['x', 'y']) {\n        if(scale[dim] == 'ordinal' || scale[dim] == 'categorical') {\n            if(width / histDomain[dim].length < 10) {\n                axisOption[dim].ticks = histDomain[dim].length;\n            }\n            // while(width / axisOption[dim].ticks < 20) {\n            //     axisOption[dim].ticks *= 0.5;\n            // }\n        }\n\n        if(histogram[dim]) {\n            axisOption[dim].tickPosition = (dim == 'x') \n                ? [-width / (histDomain[dim].length-1) /2, 0]\n                : [0, height/ (histDomain[dim].length-1) /2]\n\n            axisOption[dim].scale = \"ordinal\";\n            axisOption[dim].tickAlign = \"outer\";\n            axisOption[dim].domain = histDomain[dim];\n            axisOption[dim].ticks = histDomain[dim].length;\n        }\n    }\n\n    if((vmap.x || vmap.width) && !Array.isArray(vmap.x)) x = axis(axisOption.x);\n    if((vmap.y || vmap.height) && !Array.isArray(vmap.y)) y = axis(axisOption.y);\n\n    if((vmap.hasOwnProperty('x') || vmap.hasOwnProperty('width')) && !Array.isArray(vmap.x)) {\n        let xAxisTitle = vmap.x || vmap.width;\n        labels.append(\"g\")\n          .append(\"text\")\n            .attr(\"x\", width/2)\n            .attr(\"y\", height + padding.bottom/2 )\n            .attr(\"dy\", \"1em\")\n            .css(\"text-anchor\", \"middle\")\n            .css(\"font-size\", \"1.0em\")\n            .css(\"font-weight\", \"bold\")\n            .css(\" text-transform\", \"capitalize\")\n            .text(xAxisTitle);\n\n    }\n    if((vmap.hasOwnProperty('y') || vmap.hasOwnProperty('height')) && !Array.isArray(vmap.y)) {\n        let yAxisTitle = vmap.y || vmap.height;\n        if(!Array.isArray(vmap.y)) {\n            labels.append(\"g\")\n              .append(\"text\")\n                .attr(\"transform\", \"rotate(-90)\")\n                .attr(\"y\", -padding.left / 1.25)\n                .attr(\"x\", -height / 2)\n                .attr(\"dy\", \"1em\")\n                .css(\"text-anchor\", \"middle\")\n                .css(\"font-size\", \"1.0em\")\n                .css(\"font-weight\", \"bold\")\n                .css(\" text-transform\", \"capitalize\")\n                .text(yAxisTitle);\n        }\n    }\n    \n    if(frameBorder) {\n        plot.append(\"line\")\n            .attr('x1', 0)\n            .attr('x2', width)\n            .attr('y1', 0)\n            .attr('y2', 0)\n            .css('stroke', '#000')\n        plot.append(\"line\")\n            .attr('x1', width)\n            .attr('x2', width)\n            .attr('y1', 0)\n            .attr('y2', height)\n            .css('stroke', '#000')\n            .css('stroke-opacity', 0.5)\n    }\n\n    plot.translate(padding.left+left, padding.top+top);\n    metavis.translate(padding.left+left, padding.top+top);\n    frontMetaVis.translate(padding.left+left, padding.top+top);\n\n    let chartLayer = {};\n    chartLayer.updateAxisX =  function(newDomain) {\n        x.remove();\n        axisOption.x.domain = newDomain;\n        x = axis(axisOption.x)\n        return chartLayer;\n    }\n    chartLayer.updateAxisY =  function(newDomain) {\n        y.remove();\n        axisOption.y.domain = newDomain;\n        y = axis(axisOption.y)\n        return chartLayer;\n    }\n    chartLayer.removeAxis = function() {\n\n        if(yAxes.length) {\n            yAxes.forEach(function(yp) {\n                yp.remove();\n            })\n        } else if(xAxes.length) {\n            xAxes.forEach(function(xp) {\n                xp.remove();\n            })\n        } else {\n            x.remove();\n            y.remove();\n        }\n\n        labels.remove();\n    }\n\n    chartLayer.axisLabels = labels;\n\n    chartLayer.removeLegend = function() {\n        if(showLegend) {\n            colorLegend.remove();\n        }\n    }\n    chartLayer.svg = plot;\n    chartLayer.x = Array.isArray(vmap.x) ? xAxes : x;\n    chartLayer.y = Array.isArray(vmap.y) ? yAxes : y;\n\n    return chartLayer;\n};\n","import {gradients as colorSchemes} from './gradients';\nimport {colorhex} from './colorhex';\n\nconst colorResolution = 256;\nconst colorSetMax = 32;\nconst defaultColorScheme = colorSchemes['viridis'];\nconst defaultColorSet = [\n    \"steelblue\",\n    \"red\",\n    \"teal\",\n    \"orange\",\n    \"purple\"\n];\n\nlet gradient = defaultColorScheme;\nlet colorset = defaultColorSet;\n\nexport default function color($p) {\n    let colorManager = {};\n\n    $p.uniform('uColorMode',       'int',   0) // 0=categorical, 1=numeric\n        .uniform('uColorCount',    'int',   colorSetMax)\n        .uniform('uColorSet',      'vec3',  setColorTable(colorset))\n        // .uniform('uColorGradient', 'vec4', setColorScheme(gradient))\n        .texture('tColorGradient', 'float', setColorScheme(gradient),  [colorResolution, 1], 'rgba')\n        .subroutine('mapColorRGB', 'vec3',  mapColorRGB);\n\n    colorManager.updateScheme = function(newColors) {\n        if(typeof newColors == 'string' && colorSchemes.hasOwnProperty(newColors)) {\n            gradient = colorSchemes[newColors];\n        } else if(Array.isArray(newColors)) {\n            gradient = newColors;\n        }\n        let colorGradient = setColorScheme(gradient)\n        $p.texture.tColorGradient = colorGradient;\n        // $p.texture.update('tColorGradient', colorGradient, [0, 0]);\n    }\n\n    colorManager.updateTable = function(colors) {\n        colorset = colors;\n        $p.uniform.uColorSet.data = setColorTable(colors);\n    }\n\n    colorManager.colorTable = defaultColorSet.map(function(t){\n        return rgba2hex(t);\n    });\n\n    colorManager.getColors = function() {\n        if($p.uniform.uColorMode == 0) {\n            return colorset;\n        } else {\n            return gradient;\n        }\n    }\n\n    colorManager.updateColors = function(colors, colorMode) {\n        \n        colorManager.updateScheme(colors || defaultColorScheme);\n        colorManager.updateTable(colors || defaultColorSet);\n        if(Number.isInteger(colorMode)) {\n            $p.uniform.uColorMode.data = colorMode;\n        }\n    }\n\n    colorManager.rgb = rgb;\n    colorManager.rgba = rgba;\n\n    return colorManager;\n}\n\nfunction colorStrToHex(colorStr) {\n    if (typeof colorhex[colorStr.toLowerCase()] != 'undefined') {\n        return colorhex[colorStr.toLowerCase()];\n    } else {\n        return false;\n    }\n}\n\nfunction rgb(hexStr) {\n    var hex, r, g, b;\n\n    if(hexStr.slice(0,1) == '#') {\n        hex = hexStr.slice(1);\n    } else {\n        hex = colorStrToHex(hexStr).slice(1);\n    }\n\n    r = parseInt(hex.substring(0,2), 16) / 255;\n    g = parseInt(hex.substring(2,4), 16) / 255;\n    b = parseInt(hex.substring(4,6), 16) / 255;\n    return [r, g, b];\n}\n\nfunction rgba(hexStr, alpha = 1.0) {\n    let c = rgb(hexStr);\n    return [c[0], c[1], c[2], alpha];\n}\n\nfunction rgba2hex(c) {\n    var r = c[0],\n        g = c[1],\n        b = c[2],\n        a = 1;\n    if (r > 255 || g > 255 || b > 255 || a > 255) {\n        throw 'Invalid color component';\n    }\n    return (256 + r).toString(16).substr(1) +((1 << 24) + (g << 16) | (b << 8) | a).toString(16).substr(1);\n}\n\nfunction setColorScheme(colors) {\n    var cc = colors.length - 1,\n        step = (cc >= 0) ? colorResolution / (cc+1) : 1,\n        colorGradient = new Float32Array(colorResolution * 4);\n\n    colors.push(colors[cc]);\n    for(var i = 0; i < cc+1; i++) {\n        var c0 = rgba(colors[i]),\n            c1 = rgba(colors[i+1]),\n            offset = Math.floor(i * step)*4;\n\n        for(var x = 0; x < step; x++) {\n            var xi = x / (step);\n            colorGradient[offset+x*4]   = c0[0] + (c1[0] - c0[0]) * xi;\n            colorGradient[offset+x*4+1] = c0[1] + (c1[1] - c0[1]) * xi;\n            colorGradient[offset+x*4+2] = c0[2] + (c1[2] - c0[2]) * xi;\n            colorGradient[offset+x*4+3] = c0[3] + (c1[3] - c0[3]) * xi;\n        }\n    }\n    colors.pop();\n    return colorGradient;\n}\n\nfunction setColorTable(colors) {\n    let colorTable = new Float32Array(colorSetMax * 3);\n    colors.forEach(function(c, i){\n        let colorValue = rgb(c);\n        colorTable[i*3] = colorValue[0];\n        colorTable[i*3+1] = colorValue[1];\n        colorTable[i*3+2] = colorValue[2];\n    });\n    return colorTable;\n}\n\nfunction mapColorRGB({fieldId = 'int', value = 'float'}) {\n    var d = new Vec2();\n    var colorRGB = new Vec3();\n    var intValue = new Int();\n    if(fieldId == -1) {\n        colorRGB = this.uDefaultColor;\n    } else {\n        if(this.uColorMode == 1) {\n            colorRGB = texture2D(this.tColorGradient, vec2(value, 1.0)).rgb;\n        } else {\n            d = this.uVisDomains[fieldId];\n            intValue = int(value * (d.y - d.x) + d.x + 0.5); //plus 0.5 for rounding\n\n            if(intValue >= this.uColorCount) {\n                colorRGB = vec3(0.0, 0.0, 0.0);\n            } else {\n                colorRGB = this.uColorSet[intValue];\n            }\n        }\n    }\n    return colorRGB;\n}\n","export const colorhex = {\n    \"aliceblue\": \"#f0f8ff\",\n    \"antiquewhite\": \"#faebd7\",\n    \"aqua\": \"#00ffff\",\n    \"aquamarine\": \"#7fffd4\",\n    \"azure\": \"#f0ffff\",\n    \"beige\": \"#f5f5dc\",\n    \"bisque\": \"#ffe4c4\",\n    \"black\": \"#000000\",\n    \"blanchedalmond\": \"#ffebcd\",\n    \"blue\": \"#0000ff\",\n    \"blueviolet\": \"#8a2be2\",\n    \"brown\": \"#a52a2a\",\n    \"burlywood\": \"#deb887\",\n    \"cadetblue\": \"#5f9ea0\",\n    \"chartreuse\": \"#7fff00\",\n    \"chocolate\": \"#d2691e\",\n    \"coral\": \"#ff7f50\",\n    \"cornflowerblue\": \"#6495ed\",\n    \"cornsilk\": \"#fff8dc\",\n    \"crimson\": \"#dc143c\",\n    \"cyan\": \"#00ffff\",\n    \"darkblue\": \"#00008b\",\n    \"darkcyan\": \"#008b8b\",\n    \"darkgoldenrod\": \"#b8860b\",\n    \"darkgray\": \"#a9a9a9\",\n    \"darkgreen\": \"#006400\",\n    \"darkkhaki\": \"#bdb76b\",\n    \"darkmagenta\": \"#8b008b\",\n    \"darkolivegreen\": \"#556b2f\",\n    \"darkorange\": \"#ff8c00\",\n    \"darkorchid\": \"#9932cc\",\n    \"darkred\": \"#8b0000\",\n    \"darksalmon\": \"#e9967a\",\n    \"darkseagreen\": \"#8fbc8f\",\n    \"darkslateblue\": \"#483d8b\",\n    \"darkslategray\": \"#2f4f4f\",\n    \"darkturquoise\": \"#00ced1\",\n    \"darkviolet\": \"#9400d3\",\n    \"deeppink\": \"#ff1493\",\n    \"deepskyblue\": \"#00bfff\",\n    \"dimgray\": \"#696969\",\n    \"dodgerblue\": \"#1e90ff\",\n    \"firebrick\": \"#b22222\",\n    \"floralwhite\": \"#fffaf0\",\n    \"forestgreen\": \"#228b22\",\n    \"fuchsia\": \"#ff00ff\",\n    \"gainsboro\": \"#dcdcdc\",\n    \"ghostwhite\": \"#f8f8ff\",\n    \"gold\": \"#ffd700\",\n    \"goldenrod\": \"#daa520\",\n    \"gray\": \"#808080\",\n    \"green\": \"#008000\",\n    \"greenyellow\": \"#adff2f\",\n    \"honeydew\": \"#f0fff0\",\n    \"hotpink\": \"#ff69b4\",\n    \"indianred \": \"#cd5c5c\",\n    \"indigo\": \"#4b0082\",\n    \"ivory\": \"#fffff0\",\n    \"khaki\": \"#f0e68c\",\n    \"lavender\": \"#e6e6fa\",\n    \"lavenderblush\": \"#fff0f5\",\n    \"lawngreen\": \"#7cfc00\",\n    \"lemonchiffon\": \"#fffacd\",\n    \"lightblue\": \"#add8e6\",\n    \"lightcoral\": \"#f08080\",\n    \"lightcyan\": \"#e0ffff\",\n    \"lightgoldenrodyellow\": \"#fafad2\",\n    \"lightgrey\": \"#d3d3d3\",\n    \"lightgreen\": \"#90ee90\",\n    \"lightpink\": \"#ffb6c1\",\n    \"lightsalmon\": \"#ffa07a\",\n    \"lightseagreen\": \"#20b2aa\",\n    \"lightskyblue\": \"#87cefa\",\n    \"lightslategray\": \"#778899\",\n    \"lightsteelblue\": \"#b0c4de\",\n    \"lightyellow\": \"#ffffe0\",\n    \"lime\": \"#00ff00\",\n    \"limegreen\": \"#32cd32\",\n    \"linen\": \"#faf0e6\",\n    \"magenta\": \"#ff00ff\",\n    \"maroon\": \"#800000\",\n    \"mediumaquamarine\": \"#66cdaa\",\n    \"mediumblue\": \"#0000cd\",\n    \"mediumorchid\": \"#ba55d3\",\n    \"mediumpurple\": \"#9370d8\",\n    \"mediumseagreen\": \"#3cb371\",\n    \"mediumslateblue\": \"#7b68ee\",\n    \"mediumspringgreen\": \"#00fa9a\",\n    \"mediumturquoise\": \"#48d1cc\",\n    \"mediumvioletred\": \"#c71585\",\n    \"midnightblue\": \"#191970\",\n    \"mintcream\": \"#f5fffa\",\n    \"mistyrose\": \"#ffe4e1\",\n    \"moccasin\": \"#ffe4b5\",\n    \"navajowhite\": \"#ffdead\",\n    \"navy\": \"#000080\",\n    \"oldlace\": \"#fdf5e6\",\n    \"olive\": \"#808000\",\n    \"olivedrab\": \"#6b8e23\",\n    \"orange\": \"#ffa500\",\n    \"orangered\": \"#ff4500\",\n    \"orchid\": \"#da70d6\",\n    \"palegoldenrod\": \"#eee8aa\",\n    \"palegreen\": \"#98fb98\",\n    \"paleturquoise\": \"#afeeee\",\n    \"palevioletred\": \"#d87093\",\n    \"papayawhip\": \"#ffefd5\",\n    \"peachpuff\": \"#ffdab9\",\n    \"peru\": \"#cd853f\",\n    \"pink\": \"#ffc0cb\",\n    \"plum\": \"#dda0dd\",\n    \"powderblue\": \"#b0e0e6\",\n    \"purple\": \"#800080\",\n    \"red\": \"#ff0000\",\n    \"rosybrown\": \"#bc8f8f\",\n    \"royalblue\": \"#4169e1\",\n    \"saddlebrown\": \"#8b4513\",\n    \"salmon\": \"#fa8072\",\n    \"sandybrown\": \"#f4a460\",\n    \"seagreen\": \"#2e8b57\",\n    \"seashell\": \"#fff5ee\",\n    \"sienna\": \"#a0522d\",\n    \"silver\": \"#c0c0c0\",\n    \"skyblue\": \"#87ceeb\",\n    \"slateblue\": \"#6a5acd\",\n    \"slategray\": \"#708090\",\n    \"snow\": \"#fffafa\",\n    \"springgreen\": \"#00ff7f\",\n    \"steelblue\": \"#4682b4\",\n    \"tan\": \"#d2b48c\",\n    \"teal\": \"#008080\",\n    \"thistle\": \"#d8bfd8\",\n    \"tomato\": \"#ff6347\",\n    \"turquoise\": \"#40e0d0\",\n    \"violet\": \"#ee82ee\",\n    \"wheat\": \"#f5deb3\",\n    \"white\": \"#ffffff\",\n    \"whitesmoke\": \"#f5f5f5\",\n    \"yellow\": \"#ffff00\",\n    \"yellowgreen\": \"#9acd32\"\n};\n","export const EncodingChannels = ['x', 'y', 'color', 'opacity', 'width', 'height', 'size']\n\nexport function encode($p, vmap, colorManager) {\n    let opacity = vmap.opacity || vmap.alpha;\n    let vmapIndex = new Int32Array(EncodingChannels.length);\n    let scaleExponents = new Float32Array(EncodingChannels.length).fill(1.0);\n    \n    EncodingChannels.forEach((channel, channelIndex) => {\n        let encoding = vmap[channel];\n        if (typeof(encoding) == 'object' && encoding.hasOwnProperty('field')) {\n            if(encoding.exponent !== 1.0) {\n                scaleExponents[channelIndex] = encoding.exponent;\n            }\n            encoding = vmap[channel].field;\n        }\n        vmapIndex[channelIndex] = $p.fields.indexOf(encoding);\n    })\n    $p.uniform.uVisualEncodings.data = vmapIndex;\n    $p.uniform.uScaleExponents.data = scaleExponents;\n    $p.uniform.uDefaultAlpha.data = 1.0;\n    if(vmapIndex[2] === -1) {\n        if (typeof(vmap.color) === 'string'){\n            if(vmap.color === 'auto') {\n                $p.revealDensity = true;\n                $p.uniform.uRevealMode.data = 1;\n            } else {\n                $p.uniform.uDefaultColor.data = colorManager.rgb(vmap.color);\n            }\n        } else {\n            if(typeof(vmap.size) == 'number') {\n                $p.uniform.uMarkSize.data = vmap.size;\n            }\n        }\n    } else {\n        if($p.strLists.hasOwnProperty($p.fields[vmapIndex[2]])) {\n            $p.uniform.uColorMode.data = 0;\n        } else {\n            $p.uniform.uColorMode.data = 1;\n        }\n    }\n\n    if(typeof(opacity) === 'number') {\n        $p.uniform.uDefaultAlpha.data = opacity;\n    } else if(vmapIndex[3] === -1 &&\n        typeof(opacity) == 'string' &&\n        opacity == 'auto'\n    ) {\n        $p.revealDensity = true;\n        $p.uniform.uRevealMode.data = 0;\n        // $p.uniform.uDefaultAlpha.data = 1.0;\n    }\n\n    if(vmapIndex[6] === -1 && typeof(vmap.size) == 'number') {\n        $p.uniform.uMarkSize.data = vmap.size;\n    }\n\n    let viewSetting = {scale: {}, histogram: {}};\n    let isRect = (['rect', 'bar'].indexOf(vmap.mark) !== -1);\n    let markSpace = [0, 0];\n    let isXYCategorical = [0, 0];\n    if(vmapIndex[0] > -1) {\n        let len = $p.fieldWidths[vmapIndex[0]];\n        let ext = $p.fieldDomains[vmapIndex[0]];\n        if($p.strLists.hasOwnProperty(vmap.x)){\n            viewSetting.scale.x = 'categorical';\n            viewSetting.domainX = new Array(len).fill(0).map(\n                (d,i) => $p.strLists[vmap.x][i]\n            );\n            isXYCategorical[0] = 1;\n         } else if (isRect) {\n            viewSetting.scale.x = 'ordinal';\n            viewSetting.domainX = new Array(len).fill(0).map((d,i) => ext[0] + i);\n         }\n         markSpace[0] = 0.02;\n\n    }\n    if(vmapIndex[1] > -1) {\n        let len = $p.fieldWidths[vmapIndex[1]];\n        let ext = $p.fieldDomains[vmapIndex[1]];\n\n        if($p.strLists.hasOwnProperty(vmap.y)){\n            viewSetting.scale.y = 'categorical';\n            viewSetting.domainY = new Array(len).fill(0).map(\n                (d,i)=>$p.strLists[vmap.y][i]\n            );\n            isXYCategorical[1] = 1;\n        } else if (isRect) {\n            viewSetting.scale.y = 'ordinal';\n            viewSetting.domainY = new Array(len).fill(0).map((d,i)=>ext[0] + i);\n        }\n        markSpace[1] = 0.1;\n    }\n\n    if(vmapIndex[0] > -1 && vmapIndex[1] > -1) {\n        markSpace = [0, 0];\n    }\n    let dims = ['x', 'y'];\n    for(let dim of dims) {\n        if($p.histograms.indexOf(vmap[dim]) !== -1) {\n            let histMin = $p.intervals[vmap[dim]].min;\n            let histMax = $p.intervals[vmap[dim]].max;\n            let histIntv = $p.intervals[vmap[dim]].interval;\n            let histBin = (histMax - histMin) / histIntv + 1;\n            let d = (dim == 'x') ? 'domainX' : 'domainY';\n            viewSetting.histogram[dim] = true;\n            viewSetting[d] = new Array(histBin).fill(histMin).map((h, i) => h + i*histIntv);\n            // markSpace[dims.indexOf(dim)] = 0.01;\n        }\n    }\n    $p.uniform.uMarkSpace.data = markSpace;\n    $p.uniform.uIsXYCategorical.data = isXYCategorical;\n\n    // if(!$p._update) {\n        if(!vmap.width && vmap.x) {\n            $p.uniform.uDefaultWidth.data = 1.0 / ($p.fieldWidths[$p.fields.indexOf(vmap.x)]);\n        } else if(vmapIndex[4] === -1 && typeof(vmap.width) == 'number') {\n            $p.uniform.uDefaultWidth.data = vmap.width / width;\n        }\n\n        if(!vmap.height && vmap.y) {\n            $p.uniform.uDefaultHeight.data = 1.0 / ($p.fieldWidths[$p.fields.indexOf(vmap.y)]);\n        } else if(vmapIndex[5] === -1 && typeof(vmap.width) == 'number') {\n            $p.uniform.uDefaultHeight.data = vmap.height / height;\n        }\n    // }\n    return viewSetting;\n}\n","export default function ($p, vmap, viewIndex, domains) {\n  let chart = $p.views[viewIndex];\n  let width = chart.width;\n  let height = chart.height;\n  let padding = chart.padding;\n\n  $p.extensions.forEach((ext) => {\n    if (ext.condition.call(null, vmap)) {\n      let dataDomains = {};\n      Object.keys(domains).forEach(f => {\n        if ($p.uniqueValues.hasOwnProperty(f)) {\n          let last = $p.uniqueValues[f].length - 1;\n          dataDomains[f] = [$p.uniqueValues[f][0], $p.uniqueValues[f][last]];\n        } else if($p.strLists.hasOwnProperty(f)) {\n          dataDomains[f] = $p.strLists[f];\n        } else {\n          dataDomains[f] = domains[f];\n        }\n      })\n\n      $p.skipRender = ext.skipDefault;\n      let data = {\n        json: null,\n        array: null,\n        texture: null,\n        vmap: vmap,\n        fields: $p.fields,\n        schema: $p.dataSchema,\n        domains: dataDomains\n      };\n\n      let view = Object.assign({}, chart);\n      view.width = width - padding.left - padding.right;\n      view.height = height - padding.top - padding.bottom;\n      view.encodings = vmap;\n      view.svg = chart.chart.svg.svg;\n      view.canvas = $p.canvas;\n\n      if (ext.exportData) {\n        data.json = $p.exportResult({format: 'row', outputTag: vmap.in});\n      }\n\n      if (typeof ext.onready === 'function') {\n        ext.onready.call($p, data, view);\n      }\n\n      let execution = (ext.type == 'class')\n        ? function (data, view) {\n          chart.plot = new ext.function(data, view)\n          return chart.plot;\n        } \n        : ext.function;\n\n      if (ext.restartOnUpdate) {\n        execution.call(ext, data, view);\n      } else {\n        if (!$p._update) {\n          execution.call(ext, data, view);\n        }\n      }\n    }\n  })\n}","import {seq} from '../arrays';\n\nexport default function printformat(spec) {\n    return function(value){\n        if(typeof value !== \"number\") return value;\n        var ret,\n            convert,\n            numericSymbols = ['y', 'z', 'a', 'f', 'p', 'n', '', 'm', '', 'k', 'M','G', 'T', 'P', 'E', 'Z', 'Y'],\n            n = seq(-24,24,3),\n            i = numericSymbols.length-1,\n            parts,\n            precision = spec.match(/\\d+/)[0] || 3,\n            number = Number(value),\n            exp,\n            suffix;\n\n        if(spec[spec.length-1] == 's')\n            precision--;\n\n        parts = number.toExponential(precision).toString().match(/^(-{0,1})(\\d+)\\.?(\\d*)[eE]([+-]?\\d+)$/);\n        exp = parseInt(parts[4]) || 0;\n\n        while (i--) {\n            if (exp >= n[i]) {\n                if(i==7 && (exp-n[i]) > 1) {\n                    // console.log(exp-n[i]);\n                    suffix = numericSymbols[i+1];\n                    exp -= n[i+1];\n                    break\n                } else {\n                    suffix = numericSymbols[i];\n                    exp -= n[i];\n                    break;\n                }\n            }\n        }\n        ret = parseFloat(parts[1] + parts[2] + '.' + (parts[3]||0) + 'e' + exp.toString());\n        return ret.toString() + suffix;\n    }\n}\n","export const gradients = {\n    \"inferno\": [\"#000004\", \"#010005\", \"#010106\", \"#010108\", \"#02010a\", \"#02020c\", \"#02020e\", \"#030210\", \"#040312\", \"#040314\", \"#050417\", \"#060419\", \"#07051b\", \"#08051d\", \"#09061f\", \"#0a0722\", \"#0b0724\", \"#0c0826\", \"#0d0829\", \"#0e092b\", \"#10092d\", \"#110a30\", \"#120a32\", \"#140b34\", \"#150b37\", \"#160b39\", \"#180c3c\", \"#190c3e\", \"#1b0c41\", \"#1c0c43\", \"#1e0c45\", \"#1f0c48\", \"#210c4a\", \"#230c4c\", \"#240c4f\", \"#260c51\", \"#280b53\", \"#290b55\", \"#2b0b57\", \"#2d0b59\", \"#2f0a5b\", \"#310a5c\", \"#320a5e\", \"#340a5f\", \"#360961\", \"#380962\", \"#390963\", \"#3b0964\", \"#3d0965\", \"#3e0966\", \"#400a67\", \"#420a68\", \"#440a68\", \"#450a69\", \"#470b6a\", \"#490b6a\", \"#4a0c6b\", \"#4c0c6b\", \"#4d0d6c\", \"#4f0d6c\", \"#510e6c\", \"#520e6d\", \"#540f6d\", \"#550f6d\", \"#57106e\", \"#59106e\", \"#5a116e\", \"#5c126e\", \"#5d126e\", \"#5f136e\", \"#61136e\", \"#62146e\", \"#64156e\", \"#65156e\", \"#67166e\", \"#69166e\", \"#6a176e\", \"#6c186e\", \"#6d186e\", \"#6f196e\", \"#71196e\", \"#721a6e\", \"#741a6e\", \"#751b6e\", \"#771c6d\", \"#781c6d\", \"#7a1d6d\", \"#7c1d6d\", \"#7d1e6d\", \"#7f1e6c\", \"#801f6c\", \"#82206c\", \"#84206b\", \"#85216b\", \"#87216b\", \"#88226a\", \"#8a226a\", \"#8c2369\", \"#8d2369\", \"#8f2469\", \"#902568\", \"#922568\", \"#932667\", \"#952667\", \"#972766\", \"#982766\", \"#9a2865\", \"#9b2964\", \"#9d2964\", \"#9f2a63\", \"#a02a63\", \"#a22b62\", \"#a32c61\", \"#a52c60\", \"#a62d60\", \"#a82e5f\", \"#a92e5e\", \"#ab2f5e\", \"#ad305d\", \"#ae305c\", \"#b0315b\", \"#b1325a\", \"#b3325a\", \"#b43359\", \"#b63458\", \"#b73557\", \"#b93556\", \"#ba3655\", \"#bc3754\", \"#bd3853\", \"#bf3952\", \"#c03a51\", \"#c13a50\", \"#c33b4f\", \"#c43c4e\", \"#c63d4d\", \"#c73e4c\", \"#c83f4b\", \"#ca404a\", \"#cb4149\", \"#cc4248\", \"#ce4347\", \"#cf4446\", \"#d04545\", \"#d24644\", \"#d34743\", \"#d44842\", \"#d54a41\", \"#d74b3f\", \"#d84c3e\", \"#d94d3d\", \"#da4e3c\", \"#db503b\", \"#dd513a\", \"#de5238\", \"#df5337\", \"#e05536\", \"#e15635\", \"#e25734\", \"#e35933\", \"#e45a31\", \"#e55c30\", \"#e65d2f\", \"#e75e2e\", \"#e8602d\", \"#e9612b\", \"#ea632a\", \"#eb6429\", \"#eb6628\", \"#ec6726\", \"#ed6925\", \"#ee6a24\", \"#ef6c23\", \"#ef6e21\", \"#f06f20\", \"#f1711f\", \"#f1731d\", \"#f2741c\", \"#f3761b\", \"#f37819\", \"#f47918\", \"#f57b17\", \"#f57d15\", \"#f67e14\", \"#f68013\", \"#f78212\", \"#f78410\", \"#f8850f\", \"#f8870e\", \"#f8890c\", \"#f98b0b\", \"#f98c0a\", \"#f98e09\", \"#fa9008\", \"#fa9207\", \"#fa9407\", \"#fb9606\", \"#fb9706\", \"#fb9906\", \"#fb9b06\", \"#fb9d07\", \"#fc9f07\", \"#fca108\", \"#fca309\", \"#fca50a\", \"#fca60c\", \"#fca80d\", \"#fcaa0f\", \"#fcac11\", \"#fcae12\", \"#fcb014\", \"#fcb216\", \"#fcb418\", \"#fbb61a\", \"#fbb81d\", \"#fbba1f\", \"#fbbc21\", \"#fbbe23\", \"#fac026\", \"#fac228\", \"#fac42a\", \"#fac62d\", \"#f9c72f\", \"#f9c932\", \"#f9cb35\", \"#f8cd37\", \"#f8cf3a\", \"#f7d13d\", \"#f7d340\", \"#f6d543\", \"#f6d746\", \"#f5d949\", \"#f5db4c\", \"#f4dd4f\", \"#f4df53\", \"#f4e156\", \"#f3e35a\", \"#f3e55d\", \"#f2e661\", \"#f2e865\", \"#f2ea69\", \"#f1ec6d\", \"#f1ed71\", \"#f1ef75\", \"#f1f179\", \"#f2f27d\", \"#f2f482\", \"#f3f586\", \"#f3f68a\", \"#f4f88e\", \"#f5f992\", \"#f6fa96\", \"#f8fb9a\", \"#f9fc9d\", \"#fafda1\", \"#fcffa4\"],\n    \"magma\": [\"#000004\", \"#010005\", \"#010106\", \"#010108\", \"#020109\", \"#02020b\", \"#02020d\", \"#03030f\", \"#030312\", \"#040414\", \"#050416\", \"#060518\", \"#06051a\", \"#07061c\", \"#08071e\", \"#090720\", \"#0a0822\", \"#0b0924\", \"#0c0926\", \"#0d0a29\", \"#0e0b2b\", \"#100b2d\", \"#110c2f\", \"#120d31\", \"#130d34\", \"#140e36\", \"#150e38\", \"#160f3b\", \"#180f3d\", \"#19103f\", \"#1a1042\", \"#1c1044\", \"#1d1147\", \"#1e1149\", \"#20114b\", \"#21114e\", \"#221150\", \"#241253\", \"#251255\", \"#271258\", \"#29115a\", \"#2a115c\", \"#2c115f\", \"#2d1161\", \"#2f1163\", \"#311165\", \"#331067\", \"#341069\", \"#36106b\", \"#38106c\", \"#390f6e\", \"#3b0f70\", \"#3d0f71\", \"#3f0f72\", \"#400f74\", \"#420f75\", \"#440f76\", \"#451077\", \"#471078\", \"#491078\", \"#4a1079\", \"#4c117a\", \"#4e117b\", \"#4f127b\", \"#51127c\", \"#52137c\", \"#54137d\", \"#56147d\", \"#57157e\", \"#59157e\", \"#5a167e\", \"#5c167f\", \"#5d177f\", \"#5f187f\", \"#601880\", \"#621980\", \"#641a80\", \"#651a80\", \"#671b80\", \"#681c81\", \"#6a1c81\", \"#6b1d81\", \"#6d1d81\", \"#6e1e81\", \"#701f81\", \"#721f81\", \"#732081\", \"#752181\", \"#762181\", \"#782281\", \"#792282\", \"#7b2382\", \"#7c2382\", \"#7e2482\", \"#802582\", \"#812581\", \"#832681\", \"#842681\", \"#862781\", \"#882781\", \"#892881\", \"#8b2981\", \"#8c2981\", \"#8e2a81\", \"#902a81\", \"#912b81\", \"#932b80\", \"#942c80\", \"#962c80\", \"#982d80\", \"#992d80\", \"#9b2e7f\", \"#9c2e7f\", \"#9e2f7f\", \"#a02f7f\", \"#a1307e\", \"#a3307e\", \"#a5317e\", \"#a6317d\", \"#a8327d\", \"#aa337d\", \"#ab337c\", \"#ad347c\", \"#ae347b\", \"#b0357b\", \"#b2357b\", \"#b3367a\", \"#b5367a\", \"#b73779\", \"#b83779\", \"#ba3878\", \"#bc3978\", \"#bd3977\", \"#bf3a77\", \"#c03a76\", \"#c23b75\", \"#c43c75\", \"#c53c74\", \"#c73d73\", \"#c83e73\", \"#ca3e72\", \"#cc3f71\", \"#cd4071\", \"#cf4070\", \"#d0416f\", \"#d2426f\", \"#d3436e\", \"#d5446d\", \"#d6456c\", \"#d8456c\", \"#d9466b\", \"#db476a\", \"#dc4869\", \"#de4968\", \"#df4a68\", \"#e04c67\", \"#e24d66\", \"#e34e65\", \"#e44f64\", \"#e55064\", \"#e75263\", \"#e85362\", \"#e95462\", \"#ea5661\", \"#eb5760\", \"#ec5860\", \"#ed5a5f\", \"#ee5b5e\", \"#ef5d5e\", \"#f05f5e\", \"#f1605d\", \"#f2625d\", \"#f2645c\", \"#f3655c\", \"#f4675c\", \"#f4695c\", \"#f56b5c\", \"#f66c5c\", \"#f66e5c\", \"#f7705c\", \"#f7725c\", \"#f8745c\", \"#f8765c\", \"#f9785d\", \"#f9795d\", \"#f97b5d\", \"#fa7d5e\", \"#fa7f5e\", \"#fa815f\", \"#fb835f\", \"#fb8560\", \"#fb8761\", \"#fc8961\", \"#fc8a62\", \"#fc8c63\", \"#fc8e64\", \"#fc9065\", \"#fd9266\", \"#fd9467\", \"#fd9668\", \"#fd9869\", \"#fd9a6a\", \"#fd9b6b\", \"#fe9d6c\", \"#fe9f6d\", \"#fea16e\", \"#fea36f\", \"#fea571\", \"#fea772\", \"#fea973\", \"#feaa74\", \"#feac76\", \"#feae77\", \"#feb078\", \"#feb27a\", \"#feb47b\", \"#feb67c\", \"#feb77e\", \"#feb97f\", \"#febb81\", \"#febd82\", \"#febf84\", \"#fec185\", \"#fec287\", \"#fec488\", \"#fec68a\", \"#fec88c\", \"#feca8d\", \"#fecc8f\", \"#fecd90\", \"#fecf92\", \"#fed194\", \"#fed395\", \"#fed597\", \"#fed799\", \"#fed89a\", \"#fdda9c\", \"#fddc9e\", \"#fddea0\", \"#fde0a1\", \"#fde2a3\", \"#fde3a5\", \"#fde5a7\", \"#fde7a9\", \"#fde9aa\", \"#fdebac\", \"#fcecae\", \"#fceeb0\", \"#fcf0b2\", \"#fcf2b4\", \"#fcf4b6\", \"#fcf6b8\", \"#fcf7b9\", \"#fcf9bb\", \"#fcfbbd\", \"#fcfdbf\"],\n    \"plasma\": [\"#0d0887\", \"#100788\", \"#130789\", \"#16078a\", \"#19068c\", \"#1b068d\", \"#1d068e\", \"#20068f\", \"#220690\", \"#240691\", \"#260591\", \"#280592\", \"#2a0593\", \"#2c0594\", \"#2e0595\", \"#2f0596\", \"#310597\", \"#330597\", \"#350498\", \"#370499\", \"#38049a\", \"#3a049a\", \"#3c049b\", \"#3e049c\", \"#3f049c\", \"#41049d\", \"#43039e\", \"#44039e\", \"#46039f\", \"#48039f\", \"#4903a0\", \"#4b03a1\", \"#4c02a1\", \"#4e02a2\", \"#5002a2\", \"#5102a3\", \"#5302a3\", \"#5502a4\", \"#5601a4\", \"#5801a4\", \"#5901a5\", \"#5b01a5\", \"#5c01a6\", \"#5e01a6\", \"#6001a6\", \"#6100a7\", \"#6300a7\", \"#6400a7\", \"#6600a7\", \"#6700a8\", \"#6900a8\", \"#6a00a8\", \"#6c00a8\", \"#6e00a8\", \"#6f00a8\", \"#7100a8\", \"#7201a8\", \"#7401a8\", \"#7501a8\", \"#7701a8\", \"#7801a8\", \"#7a02a8\", \"#7b02a8\", \"#7d03a8\", \"#7e03a8\", \"#8004a8\", \"#8104a7\", \"#8305a7\", \"#8405a7\", \"#8606a6\", \"#8707a6\", \"#8808a6\", \"#8a09a5\", \"#8b0aa5\", \"#8d0ba5\", \"#8e0ca4\", \"#8f0da4\", \"#910ea3\", \"#920fa3\", \"#9410a2\", \"#9511a1\", \"#9613a1\", \"#9814a0\", \"#99159f\", \"#9a169f\", \"#9c179e\", \"#9d189d\", \"#9e199d\", \"#a01a9c\", \"#a11b9b\", \"#a21d9a\", \"#a31e9a\", \"#a51f99\", \"#a62098\", \"#a72197\", \"#a82296\", \"#aa2395\", \"#ab2494\", \"#ac2694\", \"#ad2793\", \"#ae2892\", \"#b02991\", \"#b12a90\", \"#b22b8f\", \"#b32c8e\", \"#b42e8d\", \"#b52f8c\", \"#b6308b\", \"#b7318a\", \"#b83289\", \"#ba3388\", \"#bb3488\", \"#bc3587\", \"#bd3786\", \"#be3885\", \"#bf3984\", \"#c03a83\", \"#c13b82\", \"#c23c81\", \"#c33d80\", \"#c43e7f\", \"#c5407e\", \"#c6417d\", \"#c7427c\", \"#c8437b\", \"#c9447a\", \"#ca457a\", \"#cb4679\", \"#cc4778\", \"#cc4977\", \"#cd4a76\", \"#ce4b75\", \"#cf4c74\", \"#d04d73\", \"#d14e72\", \"#d24f71\", \"#d35171\", \"#d45270\", \"#d5536f\", \"#d5546e\", \"#d6556d\", \"#d7566c\", \"#d8576b\", \"#d9586a\", \"#da5a6a\", \"#da5b69\", \"#db5c68\", \"#dc5d67\", \"#dd5e66\", \"#de5f65\", \"#de6164\", \"#df6263\", \"#e06363\", \"#e16462\", \"#e26561\", \"#e26660\", \"#e3685f\", \"#e4695e\", \"#e56a5d\", \"#e56b5d\", \"#e66c5c\", \"#e76e5b\", \"#e76f5a\", \"#e87059\", \"#e97158\", \"#e97257\", \"#ea7457\", \"#eb7556\", \"#eb7655\", \"#ec7754\", \"#ed7953\", \"#ed7a52\", \"#ee7b51\", \"#ef7c51\", \"#ef7e50\", \"#f07f4f\", \"#f0804e\", \"#f1814d\", \"#f1834c\", \"#f2844b\", \"#f3854b\", \"#f3874a\", \"#f48849\", \"#f48948\", \"#f58b47\", \"#f58c46\", \"#f68d45\", \"#f68f44\", \"#f79044\", \"#f79143\", \"#f79342\", \"#f89441\", \"#f89540\", \"#f9973f\", \"#f9983e\", \"#f99a3e\", \"#fa9b3d\", \"#fa9c3c\", \"#fa9e3b\", \"#fb9f3a\", \"#fba139\", \"#fba238\", \"#fca338\", \"#fca537\", \"#fca636\", \"#fca835\", \"#fca934\", \"#fdab33\", \"#fdac33\", \"#fdae32\", \"#fdaf31\", \"#fdb130\", \"#fdb22f\", \"#fdb42f\", \"#fdb52e\", \"#feb72d\", \"#feb82c\", \"#feba2c\", \"#febb2b\", \"#febd2a\", \"#febe2a\", \"#fec029\", \"#fdc229\", \"#fdc328\", \"#fdc527\", \"#fdc627\", \"#fdc827\", \"#fdca26\", \"#fdcb26\", \"#fccd25\", \"#fcce25\", \"#fcd025\", \"#fcd225\", \"#fbd324\", \"#fbd524\", \"#fbd724\", \"#fad824\", \"#fada24\", \"#f9dc24\", \"#f9dd25\", \"#f8df25\", \"#f8e125\", \"#f7e225\", \"#f7e425\", \"#f6e626\", \"#f6e826\", \"#f5e926\", \"#f5eb27\", \"#f4ed27\", \"#f3ee27\", \"#f3f027\", \"#f2f227\", \"#f1f426\", \"#f1f525\", \"#f0f724\", \"#f0f921\"],\n    \"viridis\": [\"#440154\", \"#440256\", \"#450457\", \"#450559\", \"#46075a\", \"#46085c\", \"#460a5d\", \"#460b5e\", \"#470d60\", \"#470e61\", \"#471063\", \"#471164\", \"#471365\", \"#481467\", \"#481668\", \"#481769\", \"#48186a\", \"#481a6c\", \"#481b6d\", \"#481c6e\", \"#481d6f\", \"#481f70\", \"#482071\", \"#482173\", \"#482374\", \"#482475\", \"#482576\", \"#482677\", \"#482878\", \"#482979\", \"#472a7a\", \"#472c7a\", \"#472d7b\", \"#472e7c\", \"#472f7d\", \"#46307e\", \"#46327e\", \"#46337f\", \"#463480\", \"#453581\", \"#453781\", \"#453882\", \"#443983\", \"#443a83\", \"#443b84\", \"#433d84\", \"#433e85\", \"#423f85\", \"#424086\", \"#424186\", \"#414287\", \"#414487\", \"#404588\", \"#404688\", \"#3f4788\", \"#3f4889\", \"#3e4989\", \"#3e4a89\", \"#3e4c8a\", \"#3d4d8a\", \"#3d4e8a\", \"#3c4f8a\", \"#3c508b\", \"#3b518b\", \"#3b528b\", \"#3a538b\", \"#3a548c\", \"#39558c\", \"#39568c\", \"#38588c\", \"#38598c\", \"#375a8c\", \"#375b8d\", \"#365c8d\", \"#365d8d\", \"#355e8d\", \"#355f8d\", \"#34608d\", \"#34618d\", \"#33628d\", \"#33638d\", \"#32648e\", \"#32658e\", \"#31668e\", \"#31678e\", \"#31688e\", \"#30698e\", \"#306a8e\", \"#2f6b8e\", \"#2f6c8e\", \"#2e6d8e\", \"#2e6e8e\", \"#2e6f8e\", \"#2d708e\", \"#2d718e\", \"#2c718e\", \"#2c728e\", \"#2c738e\", \"#2b748e\", \"#2b758e\", \"#2a768e\", \"#2a778e\", \"#2a788e\", \"#29798e\", \"#297a8e\", \"#297b8e\", \"#287c8e\", \"#287d8e\", \"#277e8e\", \"#277f8e\", \"#27808e\", \"#26818e\", \"#26828e\", \"#26828e\", \"#25838e\", \"#25848e\", \"#25858e\", \"#24868e\", \"#24878e\", \"#23888e\", \"#23898e\", \"#238a8d\", \"#228b8d\", \"#228c8d\", \"#228d8d\", \"#218e8d\", \"#218f8d\", \"#21908d\", \"#21918c\", \"#20928c\", \"#20928c\", \"#20938c\", \"#1f948c\", \"#1f958b\", \"#1f968b\", \"#1f978b\", \"#1f988b\", \"#1f998a\", \"#1f9a8a\", \"#1e9b8a\", \"#1e9c89\", \"#1e9d89\", \"#1f9e89\", \"#1f9f88\", \"#1fa088\", \"#1fa188\", \"#1fa187\", \"#1fa287\", \"#20a386\", \"#20a486\", \"#21a585\", \"#21a685\", \"#22a785\", \"#22a884\", \"#23a983\", \"#24aa83\", \"#25ab82\", \"#25ac82\", \"#26ad81\", \"#27ad81\", \"#28ae80\", \"#29af7f\", \"#2ab07f\", \"#2cb17e\", \"#2db27d\", \"#2eb37c\", \"#2fb47c\", \"#31b57b\", \"#32b67a\", \"#34b679\", \"#35b779\", \"#37b878\", \"#38b977\", \"#3aba76\", \"#3bbb75\", \"#3dbc74\", \"#3fbc73\", \"#40bd72\", \"#42be71\", \"#44bf70\", \"#46c06f\", \"#48c16e\", \"#4ac16d\", \"#4cc26c\", \"#4ec36b\", \"#50c46a\", \"#52c569\", \"#54c568\", \"#56c667\", \"#58c765\", \"#5ac864\", \"#5cc863\", \"#5ec962\", \"#60ca60\", \"#63cb5f\", \"#65cb5e\", \"#67cc5c\", \"#69cd5b\", \"#6ccd5a\", \"#6ece58\", \"#70cf57\", \"#73d056\", \"#75d054\", \"#77d153\", \"#7ad151\", \"#7cd250\", \"#7fd34e\", \"#81d34d\", \"#84d44b\", \"#86d549\", \"#89d548\", \"#8bd646\", \"#8ed645\", \"#90d743\", \"#93d741\", \"#95d840\", \"#98d83e\", \"#9bd93c\", \"#9dd93b\", \"#a0da39\", \"#a2da37\", \"#a5db36\", \"#a8db34\", \"#aadc32\", \"#addc30\", \"#b0dd2f\", \"#b2dd2d\", \"#b5de2b\", \"#b8de29\", \"#bade28\", \"#bddf26\", \"#c0df25\", \"#c2df23\", \"#c5e021\", \"#c8e020\", \"#cae11f\", \"#cde11d\", \"#d0e11c\", \"#d2e21b\", \"#d5e21a\", \"#d8e219\", \"#dae319\", \"#dde318\", \"#dfe318\", \"#e2e418\", \"#e5e419\", \"#e7e419\", \"#eae51a\", \"#ece51b\", \"#efe51c\", \"#f1e51d\", \"#f4e61e\", \"#f6e620\", \"#f8e621\", \"#fbe723\", \"#fde725\"]\n};\n","import Svg from './svg';\nimport chart from './chart';\n\nfunction assign(object, source) {\n    Object.keys(source).forEach(function(key) {\n        object[key] = source[key];\n    });\n}\nvar defaultProperties = {\n    width: 400,\n    height: 300,\n    padding: {left: 0, right: 0, top: 0, bottom: 0},\n}\n\nexport default function layout(arg){\n    \"use strict\";\n\n    /* Private */\n    var viz = this,\n        option = arg || {},\n        container = option.container || document.body,\n        style = option.style || null,\n        layers = [];\n\n    this.width = container.clientWidth || 400;\n    this.height = container.clientHeight || 300;\n\n    if(typeof container == 'string') container = document.getElementById(container);\n    assign(viz, defaultProperties);\n    assign(viz, option);\n\n    this.vmap = option.vmap;\n\n    this.width -= (this.padding.left + this.padding.right);\n    this.height -= (this.padding.top + this.padding.bottom);\n\n\n    /* Public */\n    this.data = option.data || [];\n    this.div = document.createElement(\"div\");\n    if(style !== null) {\n        Object.keys(style).forEach(function(prop){\n            viz.div.style[prop] = style[prop];\n        })\n    }\n\n    this.init = function(){\n        // container = (containerId == \"body\") ? document.body : document.getElementById(containerId);\n\n        this.div.className = option.className || \"p6-viz\";\n        this.div.style.position = 'relative';\n        this.resize(\n            this.width + this.padding.left + this.padding.right,\n            this.height + this.padding.top + this.padding.bottom\n        );\n\n        if(option.style) this.css(option.style);\n\n        container.appendChild(this.div);\n        this.viz();\n        return viz;\n    };\n\n    this.createSVG = function(arg) {\n        var arg = arg || {},\n            width = arg.width || this.width,\n            height = arg.height || this.height,\n            padding = arg.padding || this.padding;\n\n        return new Svg({\n            width: width,\n            height: height,\n            padding: padding,\n            style: {position: 'absolute'}\n        });\n    }\n\n    var canvas = option.canvas,\n        svg = this.createSVG(),\n        vmap = option.vmap,\n        chartPadding = this.padding || {left: 0, right: 0, top: 0, bottom: 0},\n        domain = option.domain || {x: [0, 1000], y: [0, 1]},\n        scales = option.scales || {x: 'linear', y: 'linear'};\n\n    var backSVG = this.createSVG(),\n        frontSVG = this.createSVG();\n\n    this.set = function(props) {\n        assign(viz, props);\n    };\n\n    this.addProperty = function(obj, prop) {\n        assign(obj, prop);\n        return obj;\n    }\n\n    this.viz = function() {\n        viz.div.appendChild(backSVG.svg);\n        viz.div.appendChild(canvas);\n        viz.div.appendChild(frontSVG.svg);\n        return viz;\n    };\n\n    this.render = this.viz;\n\n    this.css = function(style){\n        for(var key in style){\n            this.div.style[key] = style[key];\n        }\n        return this;\n    };\n\n    this.resize = function(w,h){\n        this.div.style.width = w + \"px\";\n        this.div.style.height = h + \"px\";\n    };\n\n    this.destroy = function() {\n        this._super.destroy();\n        container.removeChild(this.div);\n        div = null;\n    };\n\n    this.hide = function() {\n        this.div.style.display = 'none';\n    }\n\n    this.show = function() {\n        this.div.style.display = 'block';\n    }\n\n    this.innerWidth = function() {\n        return this.width;\n    }\n\n    this.innerHeight = function() {\n        return this.height;\n    }\n\n    this.addChart = function(options) {\n        return chart(frontSVG, backSVG, options)\n    };\n\n    this.exportImage = function(beforeExport) {\n        var imageCanvas = document.createElement(\"canvas\");\n        imageCanvas.width = this.width;\n        imageCanvas.height = this.height;\n        return new Promise(function(resolve, reject) {\n\n            var ctx = imageCanvas.getContext(\"2d\");\n            var svgString = new XMLSerializer().serializeToString(frontSVG.svg);\n\n            var DOMURL = self.URL || self.webkitURL || self;\n            var svgBlob = new Blob([svgString], {type: \"image/svg+xml;charset=utf-8\"});\n            var svgURL = DOMURL.createObjectURL(svgBlob);\n\n            var canvasLayer = new Image();\n            var svgLayer = new Image();\n            canvasLayer.onload = function() {\n                ctx.drawImage(canvasLayer, 0, 0);\n                svgLayer.src = svgURL;\n                svgLayer.onload = function() {\n                    ctx.drawImage(svgLayer, 0, 0);\n                    var png = imageCanvas.toDataURL(\"image/png\");\n                    DOMURL.revokeObjectURL(png);\n                    resolve(png);\n                };\n            };\n\n            canvasLayer.onerror = function() {\n                reject(Error(\"Canvas Output Error!\"));\n            }\n\n            svgLayer.onerror = function() {\n                reject(Error(\"SVG Output Error!\"));\n            }\n            beforeExport();\n            canvasLayer.src = canvas.toDataURL(\"image/png\");\n        });\n\n    }\n\n    return viz.init();\n};\n","import Svg from './svg';\nimport Axis from './axis';\nimport printformat from './format';\n\nconst defaultColors = ['white', 'steelblue'];\nconst defaultSize = 20;\nvar gradID = 0;\n\nexport default function color(arg){\n  var gradientID = gradID++;\n\n  var option = arg || {},\n    container = option.container || null,\n    width = option.width || null,\n    height = option.height || null,\n    pos = option.pos ||[0, 0],\n    dim = option.dim || 'x',\n    padding = option.padding || {left: 0, right: 0, top: 0, bottom: 0},\n    label = option.label || false,\n    colors = option.colors || defaultColors,\n    domain = option.domain || ['min', 'max'],\n    format = option.format || printformat('.3s');\n\n\n  if(colors.length < 2) colors = defaultColors;\n  width -= padding.left + padding.right;\n  height -= padding.top + padding.bottom;\n\n  var legend = (container === null)\n    ? new Svg({width: width, height: height, padding: padding})\n    : container.append('g');\n\n  var gradDirection;\n  if(dim == 'x') {\n    gradDirection = {x1: 0, x2: 1, y1: 0, y2: 0};\n    if(height === null) height = defaultSize;\n  } else {\n    gradDirection = {x1: 0, x2: 0, y1: 0, y2: 1};\n    if(width === null) width = defaultSize;\n  }\n\n  function linearGradient(colors) {\n    var gradient = legend.append('defs')\n      .append('linearGradient')\n        .attr('id', 'gradlegend'+gradientID)\n        .attr(gradDirection);\n\n    colors.forEach(function(c, i){\n      gradient.append('stop')\n        .attr('offset', i / (colors.length-1))\n        .attr('stop-color', colors[colors.length-i-1]);\n    });\n    return gradient;\n  }\n\n  var grad = linearGradient(colors);\n\n  var rect = legend.append('g');\n\n  var colorScale = rect.append('rect')\n    .attr('width', width-padding.left)\n    .attr('height', height)\n    .style('fill','url(#gradlegend' + gradientID + ')');\n\n  var domainLabel = legend.append('text');\n  if(label) {\n    label.append('text')\n      .attr('x', pos[0] - 5)\n      .attr('y', pos[1] + height/2 + 5)\n      .style('fill', '#222')\n      .style('text-anchor', 'end')\n      .text(printformat('2s')(domain[0]));\n\n    legend.append('text')\n      .attr('x', pos[0] + width - padding.left + 5)\n      .attr('y', pos[1] + height/2 + 5)\n      .style('fill', '#222')\n      .style('text-anchor', 'begin')\n      // .style('font-size', '.9em')\n      .text(printformat('2s')(domain[1]));\n  }\n\n  if(option.title) {\n    legend.append('g')\n      .append('text')\n      .attr('y', pos[1] - padding.top)\n      .attr('x', pos[0] + width/2)\n      .attr('dy', '1em')\n      .style('text-anchor', 'middle')\n      .text(option.title);\n  }\n\n  if(dim == 'x') {\n    new Axis({\n      dim: 'x',\n      domain: domain,\n      container: legend,\n      align: 'bottom',\n      ticks: Math.floor(width / 30),\n      height: height,\n      width: width,\n      labelPos: {x: 0, y: -20},\n      format: format,\n    });\n  } else {\n    new Axis({\n      dim: 'y',\n      domain: domain,\n      container: legend,\n      align: 'right',\n      ticks: Math.floor(height / 30),\n      height: height,\n      width: width,\n      labelPos: {x: 10, y: -5},\n      tickPosition: [5, 0],\n      format: format,\n    });\n  }\n\n\n  // legend.appendChild(xAxis);\n\n  legend.translate(pos[0]+padding.left, pos[1]+padding.top);\n\n  // legend.update = function(newDomain, newColors) {\n  //\n  //     legend.removeChild(xAxis);\n  //     xAxis = new Axis({\n  //         dim: 'x',\n  //         domain: newDomain,\n  //         container: legend,\n  //         align: 'bottom',\n  //         ticks: 4,\n  //         // tickInterval: 10000000,\n  //         labelPos: {x: -5, y: -20},\n  //          padding: padding,\n  //         width: width-padding.left,\n  //         format: format,\n  //     }).show();\n  //\n  //     if(typeof(newColors) != 'undefined') {\n  //         grad.remove();\n  //         grad = linearGradient(newColors);\n  //         colorScale.css('fill','url(#gradlegend' + gradientID + ')');\n  //\n  //     }\n  //     // legend.appendChild(xAxis);\n  //\n  //     return legend;\n  // }\n\n  return legend;\n}\n","import {seqFloat} from '../utils';\nexport default function reveal($p) {\n    $p.uniform('uRevealMode', 'int', 1)\n        .framebuffer(\"offScreenFBO\", \"float\", $p.viewport)\n        .framebuffer(\"visStats\", \"float\", [1, 1]);\n\n    var aViewX = new Float32Array($p.viewport[0]).map((d, i) => i);\n    var aViewY = new Float32Array($p.viewport[1]).map((d, i) => i);\n\n    $p.attribute(\"aViewX\", \"float\", aViewX);\n    $p.attribute(\"aViewY\", \"float\", aViewY);\n    $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aViewX.location, 0);\n    $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aViewY.location, 1);\n\n    var vs = $p.shader.vertex(function(){\n        var i, j;\n        i = (this.aViewX+0.5) / this.uViewDim.x;\n        j = (this.aViewY+0.5) / this.uViewDim.y;\n        this.vColorRGBA = texture2D(this.offScreenFBO, vec2(i, j));\n        gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n    });\n\n    var fs = $p.shader.fragment(function() {\n        gl_FragColor = this.vColorRGBA;\n    });\n\n    $p.program(\"post-processing\", vs, fs);\n\n    var vs2 = $p.shader.vertex(function () {\n         gl_Position = vec4(this._square, 0, 1);\n    });\n\n    var fs2 = $p.shader.fragment(function() {\n        var x, y, a;\n        var value = new Vec4();\n        x = (gl_FragCoord.x+0.5) / this.uViewDim.x;\n        y = (gl_FragCoord.y+0.5) / this.uViewDim.y;\n        value = texture2D(this.offScreenFBO, vec2(x, y));\n\n        if(value.a == 0.0) discard;\n        // a = pow(((value.a - this.uDefaultAlpha) / (this.uMaxRGBA.a -this.uDefaultAlpha)), 0.33) * 0.85 + 0.15;\n        a = pow((value.a / this.uMaxRGBA.a), 0.33) * 0.9 + 0.1;\n        // a = value.a / this.uMaxRGBA.a;\n\n        if(this.uRevealMode == 0) {\n            gl_FragColor = vec4(this.uDefaultColor*a, a);\n        } else {\n            gl_FragColor = vec4(texture2D(this.tColorGradient, vec2(1.-a, 1.0)).rgb*this.uDefaultAlpha, this.uDefaultAlpha);\n        }\n    });\n\n    $p.program(\"vis-render\", vs2, fs2);\n\n    let isFBOAllocatedFBO = false;\n\n    return function(options) {\n        var gl,\n            viewIndex = options.viewIndex,\n            viewDim = options.dim,\n            offset = options.offset || [0, 0],\n            padding = options.padding || {left: 0, right: 0, left: 0, right:0};\n\n        if(!$p._update) {\n\n            if(!isFBOAllocatedFBO) {\n                isFBOAllocatedFBO = true;\n                $p.framebuffer(\"visStats\", \"float\", [1, $p.views.length]);\n            }\n\n            let vOffset = [\n                offset[0] + padding.left,\n                $p.viewport[1] - viewDim[1] + padding.bottom - offset[1],\n            ]\n            let vDim = [\n                viewDim[0] - padding.left - padding.right,\n                viewDim[1] - padding.top - padding.bottom\n            ]\n\n            $p.attribute.aViewX = seqFloat(vOffset[0], vOffset[0] + vDim[0] - 1);\n            $p.attribute.aViewY = seqFloat(vOffset[1], vOffset[1] + vDim[1] - 1);\n            gl = $p.program(\"post-processing\");\n\n            $p.framebuffer.enableRead(\"offScreenFBO\");\n            $p.bindFramebuffer(\"visStats\");\n\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute._square.location, 0);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aViewX.location, 0);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aViewY.location, 1);\n            // gl.clearColor( 0.0, 0.0, 0.0, 0.0 );\n            // gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );\n            gl.disable(gl.CULL_FACE);\n            gl.disable(gl.DEPTH_TEST);\n            gl.enable( gl.BLEND );\n            gl.blendFunc( gl.ONE, gl.ONE );\n            gl.blendEquation(gl.MAX_EXT);\n            gl.viewport(0, viewIndex, 1, 1);\n            gl.ext.drawArraysInstancedANGLE(\n                gl.POINTS,\n                0,\n                vDim[0],\n                vDim[1]);\n\n            var max = new Float32Array(4);\n            gl.readPixels(0, viewIndex, 1, 1, gl.RGBA, gl.FLOAT, max);\n            // if(max[3] == 0) {\n            //     max[3] = Math.sqrt($p.dataSize) * Math.log2($p.dataSize);\n            // }\n            // console.log(offset, viewDim);\n            $p.views[viewIndex].maxRGBA = max;\n        }\n\n        $p.uniform.uMaxRGBA = $p.views[viewIndex].maxRGBA;\n\n        $p.bindFramebuffer(null);\n        gl = $p.program(\"vis-render\");\n        gl.ext.vertexAttribDivisorANGLE($p.attribute._square.location, 0);\n        $p.framebuffer.enableRead(\"offScreenFBO\");\n\n        gl.viewport(\n            offset[0] + padding.left,\n            // offset[1] + padding.bottom,\n            $p.viewport[1] - viewDim[1] + padding.bottom - offset[1],\n            viewDim[0] - padding.left - padding.right,\n            viewDim[1] - padding.top - padding.bottom\n        );\n        // gl.blendEquation(gl.FUNC_ADD);\n        gl.disable( gl.BLEND );\n        // gl.clearColor( 0.0, 0.0, 0.0, 0.0 );\n        // gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n    }\n}\n","export default function scale(arg) {\n    var option = arg || {},\n        align = option.align || 'center',\n        type = option.type || 'linear',\n        domain = option.domain || [0,1],\n        margin = option.margin || 0,\n        exponent = option.exponent || 1,\n        range = option.range || [0,1];\n\n    function getInterpolateFunction() {\n        //intercepts and slopes for domain and range\n        var d0 = -domain[0] / (domain[1] - domain[0]),\n            d1 = 1 / (domain[1] - domain[0]),\n            r0 = range[0],\n            r1 = range[1] - range[0];\n\n        if(type == \"linear\") {\n            return function(v) { return r0 + (d0 + v * d1) * r1 };\n        } else if(type == \"power\") {\n            d0 = -Math.pow(-d0, exponent);\n            d1 = Math.pow(d1, exponent);\n            return function(v) { return r0 + (d0 + Math.pow(v, exponent) * d1) * r1 };\n        } else if (type == \"log\") {\n            exponent = option.exponent || 10;\n            d0 = -(Math.log(-d0) / Math.log(exponent));\n            d1 = (Math.log(d1) / Math.log(exponent));\n\n            return function(v) { return r0 + (d0 + Math.log(v) / Math.log(exponent) * d1) * r1 };\n\n        } else if(type == \"ordinal\" || type == \"categorical\") {\n            return function(v) {\n                if(align == 'outer')\n                    return r0 + (domain.indexOf(v)+0.5) / (domain.length-1) * r1;\n                else\n                    return r0 + (domain.indexOf(v)+0.5) / domain.length * r1;\n            };\n        } else {\n            return function(v) { return v };\n        }\n    }\n\n    var scale = getInterpolateFunction();\n\n    scale.interval = function(ticks) {\n        if (type == \"ordinal\" || type == \"categorical\") {\n            return (1 / domain.length * Math.abs(range[1] - range[0]));\n        } else {\n            var s = Math.pow(10, Math.floor(Math.log10(Math.abs(range[1] - range[0])))-1);\n            return Math.floor( Math.abs(range[1] - range[0]) / (ticks * s) )  * s;\n        }\n    };\n\n    scale.domainLength = function() {\n        if(type == \"linear\")\n            return Math.abs(domain[1] - domain[0]);\n        else if(type == \"ordinal\" || type == \"categorical\")\n            return domain.length;\n    };\n\n    scale.rangeLength = function() {\n        return Math.abs(range[1] - range[0]);\n    };\n\n    scale.invert = function(r) {\n        if(type == \"linear\") {\n            return domain[0] + (r - range[0]) / (range[1] - range[0]) * (domain[1] - domain[0]);\n        } else if(type == \"ordinal\" || type == \"categorical\") {\n            var intv = intv = r / scale.rangeLength();\n            return domain[Math.min(Math.floor(intv * (domain.length)), domain.length-1)];\n        }\n    }\n\n    scale.domain = function() {\n        return domain;\n    }\n\n    return scale;\n};\n","import Renderer from './Renderer.gl'\n\nexport default class Instanced extends Renderer{\n    constructor(arg) {\n        super(arg)        \n    }\n\n    vertexShader () {\n        var i, j, posX, posY, color, alpha, size;\n        var rgb = new Vec3();\n\n        i = (this.aDataIdx + 0.5) / this.uDataDim.x;\n        j = (this.aDataIdy + 0.5) / this.uDataDim.y;\n\n        if (this.uFilterFlag == 1) {\n            this.vResult = texture2D(this.fFilterResults, vec2(i, j)).a;\n        } else {\n            this.vResult = this.uVisLevel;\n        }\n\n        posX = this.visMap(0, i, j, this.aDataValx, this.aDataValy, 0.0);\n        posY = this.visMap(1, i, j, this.aDataValx, this.aDataValy, 0.0);\n        color = this.visMap(2, i, j, this.aDataValx, this.aDataValy, -1.0);\n        alpha = this.visMap(3, i, j, this.aDataValx, this.aDataValy, this.uDefaultAlpha);\n        size = this.visMap(6, i, j, this.aDataValx, this.aDataValy, 1.0);\n\n        if(this.uIsXYCategorical[0] == 1) {\n            var width = this.uFieldWidths[0];\n            posX = 0.5 / width + posX * (width - 1.0) / width;\n        }\n        if(this.uIsXYCategorical[1] == 1) {\n            var height = this.uFieldWidths[1];\n            posY = 0.5 / height + posY * (height - 1.0) / height;\n        }\n\n        posX = posX * 2.0 - 1.0;\n        posY = posY * 2.0 - 1.0;\n\n        rgb = this.mapColorRGB(this.uVisualEncodings[2], color);\n        if (this.uDropZeros == 1 && color == 0.0) {\n            alpha = 0.0;\n          }\n        gl_PointSize = size * this.uMarkSize;\n        this.vColorRGBA = vec4(rgb, alpha);\n        gl_Position = vec4(posX, posY, 0.0, 1.0);\n    }\n\n    fragmentShader() {\n        var valid = new Bool();\n        valid = this.vResult <= this.uVisLevel + 0.01 && this.vResult >= this.uVisLevel - 0.01;\n        if (this.uVisMark == 1) { // for circles \n            var dist = length(gl_PointCoord.xy - vec2(0.5, 0.5));\n            if (dist > 0.5) discard;\n            var delta = 0.15;\n            var alpha = this.vColorRGBA.a - smoothstep(0.5 - delta, 0.5, dist);\n            if (valid) {\n                gl_FragColor = vec4(this.vColorRGBA.rgb * alpha, alpha);\n            } else {\n                discard;\n            }\n        } else {\n            if (valid) {\n                gl_FragColor = vec4(this.vColorRGBA.rgb * this.vColorRGBA.a, this.vColorRGBA.a);\n            } else {\n                discard;\n            }\n        }\n    }\n\n    render(primitive) {\n        let $p = this.gl;\n        $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdx.location, 0);\n        $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataValx.location, 0);\n        $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdy.location, 1);\n        $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataValy.location, 1);\n        $p.ctx.ext.drawArraysInstancedANGLE(primitive, 0, $p.dataDimension[0], $p.dataDimension[1]);\n\n    }\n}","import Renderer from './Renderer.gl'\n\nexport default class Instanced extends Renderer{\n    constructor(arg) {\n        super(arg)        \n    }\n\n    vertexShader () {\n      var i, j;\n      var rgb = new Vec3();\n      var posX, posY, size, color, alpha;\n      gl_PointSize = this.uMarkSize;\n      i = (mod(this.aDataItemId, this.uDataDim.x) + 0.5) / this.uDataDim.x;\n      j = (floor(this.aDataItemId / this.uDataDim.x) + 0.5) / this.uDataDim.y;\n  \n      this.vResult = this.uVisLevel;\n      if(this.uFilterFlag == 1) {\n          this.vResult = texture2D(this.fFilterResults, vec2(i, j)).a;\n      }\n      if(this.uInterleaveX == 1) {\n          posX = this.aDataFieldId.y / float(this.uFeatureCount-1);\n          posY = this.getEncodingByFieldId(int(this.aDataFieldId.x), i, j);\n      } else {\n          posY = 1.0 - this.aDataFieldId.y / float(this.uFeatureCount-1);\n          posX = this.getEncodingByFieldId(int(this.aDataFieldId.x), i, j);\n      }\n      color = this.visMap(2, i, j, i, j, -1.0);\n      alpha = this.visMap(3, i, j, i, j, this.uDefaultAlpha);\n  \n      posX = posX * 2.0 - 1.0;\n      posY = posY * 2.0 - 1.0;\n  \n      rgb = this.mapColorRGB(this.uVisualEncodings[2], color);\n      this.vColorRGBA = vec4(rgb*alpha, alpha);\n      gl_Position = vec4(posX, posY, 0.0, 1.0);\n    }\n\n    updateInstancedAttribute(vm) {\n      let $p = this.gl;\n      if(Array.isArray(vm)){\n          let fv = new Float32Array(vm.length*2);\n          vm.forEach(function(f, i) {\n              fv[i*2] = $p.fields.indexOf(f);\n              fv[i*2+1] = i;\n          });\n          $p.attribute.aDataFieldId = fv;\n          $p.uniform.uFeatureCount = vm.length;\n      }\n    }\n\n    render(primitive) {\n      let $p = this.gl;\n      $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataFieldId.location, 0);\n      $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataItemId.location, 1);\n      let count = $p.attribute.aDataFieldId.data.length / $p.attribute.aDataFieldId.size;\n      $p.ctx.ext.drawArraysInstancedANGLE(primitive, 0, count, $p.dataSize);\n    }\n}","import Renderer from './Renderer.gl'\n\nexport default class Polygon extends Renderer{\n  constructor (arg) {\n    super(arg);\n  }\n\n  vertexShader () {\n    var i, j;\n    var rgb = new Vec3();\n    var posX, posY, color, alpha, width, height, size;\n    i = (mod(this.aDataItemId, this.uDataDim.x) + 0.5) / this.uDataDim.x;\n    j = (floor(this.aDataItemId / this.uDataDim.x) + 0.5) / this.uDataDim.y;\n\n    this.vResult = this.uVisLevel;\n\n    if (this.uFilterFlag == 1) {\n      this.vResult = texture2D(this.fFilterResults, vec2(i, j)).a;\n    }\n    var val0, val1;\n    val0 = this.aDataItemVal0;\n    val1 = this.aDataItemVal1;\n    posX = this.visMap(0, i, j, val0, val1, 0.0);\n    posY = this.visMap(1, i, j, val0, val1, 0.0);\n    color = this.visMap(2, i, j, val0, val1, -1.0);\n    alpha = this.visMap(3, i, j, val0, val1, this.uDefaultAlpha);\n    width = this.visMap(4, i, j, val0, val1, this.uDefaultWidth);\n    height = this.visMap(5, i, j, val0, val1, this.uDefaultHeight);\n    size = this.visMap(6, i, j, val0, val1, this.uMarkSize);\n    posX = posX * (this.uFieldWidths[this.uVisualEncodings[0]] - 1.0) / this.uFieldWidths[this.uVisualEncodings[0]];\n    posY = posY * (this.uFieldWidths[this.uVisualEncodings[1]] - 1.0) / this.uFieldWidths[this.uVisualEncodings[1]];\n\n    width *= 1.0 - this.uMarkSpace.x * 2.0;\n    height *= 1.0 - this.uMarkSpace.y * 2.0;\n    posX += this.uMarkSpace.x * width;\n    posY += this.uMarkSpace.y * height;\n\n    if (this.aVertexId == 0.0 || this.aVertexId == 3.0) {\n      posX = posX * 2.0 - 1.0;\n      posY = posY * 2.0 - 1.0;\n    } else if (this.aVertexId == 1.0) {\n      posX = posX * 2.0 - 1.0;\n      posY = (posY + height) * 2.0 - 1.0;\n    } else if (this.aVertexId == 2.0 || this.aVertexId == 5.0) {\n      posX = (posX + width) * 2.0 - 1.0;\n      posY = (posY + height) * 2.0 - 1.0;\n    } else if (this.aVertexId == 4.0) {\n      posX = (posX + width) * 2.0 - 1.0;\n      posY = posY * 2.0 - 1.0;\n    } else {\n      posX = posX * 2.0 - 1.0;\n      posY = posY * 2.0 - 1.0;\n    }\n\n    rgb = this.mapColorRGB(this.uVisualEncodings[2], color);\n    if (this.uDropZeros == 1 && color == 0.0) {\n      alpha = 0.0;\n    }\n    this.vColorRGBA = vec4(rgb * alpha, alpha);\n    gl_Position = vec4(posX, posY, 0.0, 1.0);\n  }\n\n  fragmentShader() {\n    if (this.vResult <= this.uVisLevel + 0.01 && this.vResult >= this.uVisLevel - 0.01)\n      gl_FragColor = this.vColorRGBA;\n    else\n      discard;\n  }\n\n  render() {\n    let $p = this.gl;\n    let primitive = $p.ctx.TRIANGLES;\n    let val0 = new Float32Array($p.dataSize);\n    let val1 = new Float32Array($p.dataSize);\n    for(var y = 0; y < $p.dataDimension[1]; y++) {\n      for(var x = 0; x < $p.dataDimension[0]; x++) {\n        val0[y*$p.dataDimension[0] + x] = $p.attribute.aDataValx.data[x];\n        val1[y*$p.dataDimension[0] + x] = $p.attribute.aDataValy.data[y];\n      }\n    }\n    $p.attribute.aDataItemVal0 = val0;\n    $p.attribute.aDataItemVal1 = val1;\n    $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aVertexId.location, 0);\n    $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataItemId.location, 1);\n    $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataItemVal0.location, 1);\n    $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataItemVal1.location, 1);\n    $p.ctx.ext.drawArraysInstancedANGLE(primitive, 0, 6, $p.dataSize);\n  }\n}","export default class Renderer {\n  constructor({context, name}) {\n    this.gl = context;\n    this.name = name;\n    this.gl.program(\n      name,\n      this.gl.shader.vertex(this.vertexShader),\n      this.gl.shader.fragment(this.fragmentShader)\n    )\n  }\n\n  vertexShader () {\n    gl_Position = vec4(this._square, 0.0, 1.0);\n  }\n\n  fragmentShader () {\n    if(this.vResult <= this.uVisLevel + 0.01 && this.vResult >= this.uVisLevel - 0.01) {\n      gl_FragColor = this.vColorRGBA;\n    } else {\n      discard;\n    }\n  }\n\n  load () {\n    return this.gl.program(this.name);\n  }\n\n  render () {\n    let gl = this.gl.ctx;\n    gl.disable( gl.BLEND );\n    gl.drawArrays(primitive || gl.TRIANGLES, 0, 6);\n  }\n}","export default {\n    visMap({\n        channelId = 'int',\n        addrX = 'float',\n        addrY = 'float',\n        indexedValue0 = 'float',\n        indexedValue1 = 'float',\n        defaultValue = 'float'\n    }) {\n        var value;\n        var d = new Vec2();\n        var fieldId = new Int();\n        fieldId = this.uVisualEncodings[channelId];\n        if (fieldId > -1) {\n            if (fieldId >= this.uIndexCount) {\n                value = this.getNonIndexedData(fieldId, addrX, addrY);\n            } else if (fieldId < this.uIndexCount) {\n                value = (fieldId == 0) ? indexedValue0 : indexedValue1;\n            }\n            d = this.uVisDomains[fieldId];\n\n            value = (value - d.x) / (d.y - d.x);\n            if (this.uScaleExponents[channelId] != 0.0) {\n                value = pow(value, this.uScaleExponents[channelId]);\n            }\n\n            if (this.uGeoProjection == 1 && channelId == 1) {\n                value = log(tan((value / 90.0 + 1.0) * 3.14159 / 4.0)) * 180.0 / 3.14159;\n            }\n        } else {\n            value = defaultValue;\n        }\n\n        return value;\n    },\n\n    getEncodingByFieldId({\n        fieldId = 'int',\n        addrX = 'float',\n        addrY = 'float'\n    }) {\n        var value;\n        if (fieldId >= this.uIndexCount) {\n            value = this.getNonIndexedData(fieldId, addrX, addrY);\n        } else if (fieldId < this.uIndexCount) {\n            value = (fieldId == 0) ? addrX : addrY;\n        }\n        var d = new Vec2();\n        d = this.uVisDomains[fieldId];\n        value = (value - d.x) / (d.y - d.x);\n        return value;\n    }\n}","function setAttr(elem, attr) {\n    for( var key in attr ){\n        var value = attr[key],\n            c = key.match(/[A-Z]/);\n        if(c !== null) key = key.replace(c[0], \"-\"+c[0].toLowerCase())\n        elem.setAttribute(key, value);\n    }\n}\n\nfunction setStyle(elem, style) {\n    for( var key in style ){\n        var value = style[key],\n            c = key.match(/[A-Z]/);\n        if(c !== null) key = key.replace(c[0], \"-\"+c[0].toLowerCase())\n        elem.style[key] = value;\n    }\n}\n\nexport default function Svg(arg){\n\n    var self = (this instanceof Svg) ? this: {},\n        option = arg || {},\n        type = option.type || 'svg',\n        svgNS = 'http://www.w3.org/2000/svg',\n        svg = document.createElementNS(svgNS, type),\n        width = option.width || 400,\n        height = option.height || 300,\n        parent = option.parent || option.container || this.parent,\n        attr = option.attr || {},\n        style = option.style || {},\n        padding = option.padding || {left: 0, right: 0, top: 0, bottom: 0};\n\n    if(type === 'svg') {\n        var defaultAttr = {\n            width   : width + padding.left + padding.right,\n            height  : height + padding.top + padding.bottom,\n            viewBox : [0, 0, width + padding.left + padding.right , height + padding.top + padding.bottom].join(' '),\n            preserveAspectRatio: 'none'\n        };\n        setAttr(svg, defaultAttr);\n    }\n\n    self.innerWidth = function() {\n        return width;\n    }\n\n    self.innerHeight = function() {\n        return height;\n    }\n\n    self.padding = function() {\n        return padding;\n    }\n\n    if(style) setStyle(svg, style);\n    if(attr) setAttr(svg, attr);\n\n    if(parent) {\n        parent = (typeof parent == \"string\") ? document.getElementById(parent) : parent;\n        parent.appendChild(svg);\n    }\n\n    self.svg = svg;\n    self.parent = parent;\n\n    self.node = () => svg;\n\n    if(self instanceof Svg) {\n        publicMethods(Svg.prototype);\n    } else {\n        publicMethods(self);\n    }\n\n    return self;\n};\n\nfunction publicMethods(context) {\n    context.append = function(type, attr, style) {\n        var options = {};\n        options.parent = this.svg;\n        options.type = type;\n        options.attr = attr;\n        options.style = style;\n        return new Svg(options);\n    };\n\n    context.remove = function() {\n        if(this.svg && this.svg.parentNode === this.parent){\n            this.parent.removeChild(this.svg);\n        }\n    };\n\n    context.attr = function(a, v) {\n        if(typeof(a) == \"object\")\n            setAttr(this.svg, a);\n        else\n            this.svg.setAttribute(a, v);\n\n        return this;\n    }\n\n    context.Attr =  function(a, v) {\n        setAttr(this.svg, a);\n        return this;\n    }\n\n    context.Style =  function(a, v) {\n        setStyle(this.svg, a);\n        return this;\n    }\n\n    context.style = function(a, v) {\n        if(typeof(a) == \"object\")\n            setStyle(this.svg, a);\n        else\n            this.svg.style[a] = v;\n\n        return this;\n    }\n\n    context.css = context.style;\n\n    context.text = function(str){\n        this.svg.appendChild(document.createTextNode(str));\n        return this;\n    };\n\n    context.translate = function(x, y) {\n        var p = this.svg.getAttribute(\"transform\") || \"\";\n        this.svg.setAttribute(\"transform\", p + \"translate(\" + [x,y].join(\",\") + \") \");\n        return this;\n    };\n\n    context.on = function(event, callback) {\n        this.svg.addEventListner(event, callback);\n        return this;\n    }\n\n    return context;\n}\n","import colors from './color';\nimport reveal from './reveal';\nimport {encode, EncodingChannels} from './encode';\nimport extend from './extend';\nimport interpolate from './shaders/interpolate.gl'\n\nimport Layout from './layout';\nimport Instanced from './shaders/Instanced.gl'\nimport Polygon from './shaders/Polygon.gl'\nimport Interleaved from './shaders/Interleaved.gl'\n\nconst userActions = ['click', 'hover', 'brush', 'zoom', 'pan'];\nconst visMarks = ['dot', 'circle', 'line', 'rect'];\n\nexport default function visualize($p) {\n\n    let colorManager = colors($p);\n    let chartPadding = $p.padding || {left: 0, right: 0, top: 0, bottom: 0};\n    let viewport = $p.viewport;\n\n    let vis = new Layout({\n        container: $p.container,\n        width: viewport[0] + chartPadding.left + chartPadding.right,\n        height: viewport[1] + chartPadding.top + chartPadding.bottom,\n        canvas: $p.canvas,\n        padding: chartPadding\n    });\n    \n    $p.uniform('uVisualEncodings',  'int',   new Array(EncodingChannels.length).fill(-1))\n        .uniform('uScaleExponents', 'float',   new Array(EncodingChannels.length).fill(1.0))\n        .uniform('uViewDim',        'vec2',  $p.viewport)\n        .uniform('uVisMark',        'int',   1)\n        .uniform('uInterleaveX',    'int',   0)\n        .uniform('uVisDomains',     'vec2',  $p.fieldDomains.map(d=>d.slice()))\n        .uniform('uVisScale',       'vec2',  [1.0, 1.0])\n        .uniform('uPosOffset',      'vec2',  [0.0, 0.0])\n        .uniform('uFeatureCount',   'int',   0)\n        .uniform('uMarkSize',       'float', 16.0)\n        .uniform('uMarkSpace',      'vec2',  [0.02, 0.02])\n        .uniform('uDefaultAlpha',   'float', 1.0)\n        .uniform('uDefaultWidth',   'float', 1.0 / $p.viewport[0])\n        .uniform('uDefaultHeight',  'float', 1.0 / $p.viewport[1])\n        .uniform('uMaxRGBA',        'vec4',  [0, 0, 0, 0])\n        .uniform('uDefaultColor',   'vec3',  [0.8, 0, 0])\n        .uniform('uGeoProjection',   'int',  0)\n        .uniform('uDropZeros',   'int',  0)\n        .uniform('uColorMode',      'int',   1)\n        .uniform('uIsXYCategorical','ivec2', [0, 0])\n        .varying('vColorRGBA',      'vec4'   );\n\n    let enhance = reveal($p);\n\n    $p.framebuffer('offScreenFBO', 'float', $p.viewport);\n    // $p.framebuffer('visStats', 'float', [1, 1]);\n    // $p.framebuffer(\"visStats\", \"float\", [$p.views.length, 1]);\n    // $p.framebuffer.enableRead('offScreenFBO');\n    $p.bindFramebuffer('offScreenFBO');\n    $p.ctx.clearColor( 1.0, 1.0, 1.0, 0.0 );\n    $p.ctx.clear( $p.ctx.COLOR_BUFFER_BIT | $p.ctx.DEPTH_BUFFER_BIT );\n    $p.bindFramebuffer(null);\n    $p.subroutine('visMap', 'float', interpolate.visMap);\n    $p.subroutine('getEncodingByFieldId', 'float', interpolate.getEncodingByFieldId);\n    \n    let renderers = {\n        instanced: new Instanced({context: $p, name: 'instanced'}),\n        polygon: new Polygon({context: $p, name: 'polygon'}),\n        interleave: new Interleaved({context: $p, name: 'interleave'})\n    }\n\n    return function(options) {\n        $p.revealDensity = false;\n        let renderer = 'instanced';\n        let vmap = options.vmap || {};\n        let mark = options.mark || vmap.mark || 'circle';\n        let viewIndex = options.viewIndex;\n\n        let visDomain = {};\n        let visDimension = vmap.viewport || [$p.views[viewIndex].width, $p.views[viewIndex].height] || viewport;\n        let width = visDimension[0];\n        let height =  visDimension[1];\n        let padding = vmap.padding || $p.views[viewIndex].padding || chartPadding;\n        let offset = vmap.offset || $p.views[viewIndex].offset || [0, 0];\n        let dimSetting = encode($p, vmap, colorManager);\n\n        let pv = $p.views[viewIndex];\n        let colorInfo = (typeof(vmap.colors) === 'object') ? vmap.colors : pv.color;\n    \n        let colorMode = 1;\n        let colorMap;\n        \n        let viewSetting = {\n            domain: visDomain,\n            fields: $p.fields,\n            vmap: vmap,\n            // onclick: interaction,\n            strLists: $p.strLists,\n            padding: padding,\n            left: offset[0],\n            top:  offset[1],\n            colors: colorManager.getColors(),\n        };\n\n        viewSetting = Object.assign(viewSetting, dimSetting);\n        viewSetting = Object.assign(viewSetting, $p.views[viewIndex]);\n\n        if(!$p._update){\n            $p.fields.forEach(function(f, i){\n                visDomain[f] = $p.fieldDomains[i].slice();\n            });\n            if(vmap.zero) {\n                if($p.fields.indexOf(vmap.width) > -1) {\n                    visDomain[vmap.width][0] = 0;\n                }\n                if($p.fields.indexOf(vmap.height) > -1) {\n                    visDomain[vmap.height][0] = 0;\n                }\n                if($p.fields.indexOf(vmap.y) > -1) {\n                    visDomain[vmap.y][0] = 0;\n                }\n            } \n\n            // pv.domains = Object.keys(visDomain).map(f=>visDomain[f]);\n            pv.domains = visDomain;\n            // $p.uniform.uVisDomains.data = pv.domains;\n            if((vmap.append !== true ) && pv.hasOwnProperty('chart')) {\n                pv.chart.svg.remove();\n                pv.chart.removeAxis();\n            }\n            pv.chart = vis.addChart(viewSetting);\n            pv.svg = pv.chart.svg.node();\n            if(typeof(colorInfo) === 'object') {\n                if(Array.isArray(colorInfo)) {\n                    colorMap = colorInfo;\n                } else {\n                    if(colorInfo.hasOwnProperty('interpolate')) {\n                        colorMode = (colorInfo.interpolate) ? 1 : 0;\n                    }\n                    colorMap = colorInfo.range || colorInfo.values; \n                }\n            }\n\n            colorManager.updateColors(colorMap, colorMode);\n            \n        } else {\n            // $p.uniform.uVisDomains.data = pv.domains;\n            if(pv.updateDomain === true) {\n                pv.chart.updateAxisX(pv.domains[vmap.x]);\n                pv.chart.updateAxisY(pv.domains[vmap.y]);\n            }\n        }\n        $p.uniform.uVisDomains.data = Object.keys(pv.domains).map(f=>pv.domains[f]);\n        $p.uniform.uVisMark.data = visMarks.indexOf(mark);\n        $p.uniform.uGeoProjection.data = (vmap.project) ? 1 : 0;\n        $p.uniform.uDropZeros.data = (vmap.dropZeros) ? 1 : 0;\n\n        //Check if need interleaving data attributes(e.g.,parallel coordinates)\n        if(Array.isArray(vmap.x) || Array.isArray(vmap.y)) {\n            renderer = 'interleave';\n            if(Array.isArray(vmap.x)){\n                // vmap.x = vmap.x.reverse();\n                $p.uniform.uInterleaveX = 0;\n            } else if(Array.isArray(vmap.y)) {\n                $p.uniform.uInterleaveX = 1;\n            }\n            renderers[renderer].updateInstancedAttribute(vmap.x);\n            renderers[renderer].updateInstancedAttribute(vmap.y);\n        } else if(vmap.mark && ['rect', 'bar'].indexOf(vmap.mark) !== -1) {\n            renderer = 'polygon';\n        }\n\n        let gl = renderers[renderer].load();\n        $p.framebuffer.enableRead('fFilterResults');\n        $p.framebuffer.enableRead('fDerivedValues');\n        $p.framebuffer.enableRead(vmap.in || 'fGroupResults');\n\n        if($p.revealDensity) {\n            $p.bindFramebuffer('offScreenFBO');\n            gl.clearColor( 1.0, 1.0, 1.0, 0.0 );\n            gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );\n            gl.blendFunc(gl.ONE, gl.ONE );\n        } else {\n            $p.bindFramebuffer(null);\n            // gl.clearColor( 1.0, 1.0, 1.0, 0.0 );\n            gl.blendFunc( gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n            // gl.blendFunc(gl.SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);\n        }\n        gl.viewport(\n            offset[0] + padding.left,\n            viewport[1] - height + padding.bottom - offset[1],\n            width - padding.left - padding.right,\n            height - padding.top - padding.bottom\n        );\n        gl.disable(gl.CULL_FACE);\n        gl.disable(gl.DEPTH_TEST);\n        gl.enable(gl.BLEND);\n        gl.blendEquation(gl.FUNC_ADD);\n\n        let primitive = gl.POINTS;\n\n        if(mark == 'line') {\n            primitive = gl.LINE_STRIP;\n            gl.lineWidth(vmap.size || 1.0);\n        }\n\n        extend($p, vmap, viewIndex, visDomain);\n\n        if($p.skipRender || vmap.project) {\n            pv.chart.removeAxis();\n            if($p.fields.indexOf(vmap.color)!==-1) pv.chart.removeLegend();\n        }\n\n        if(!$p.skipRender) {\n            renderers[renderer].render(primitive);\n        } else {\n            if(!$p._update) {\n                gl.clearColor( 0.0, 0.0, 0.0, 0.0 );\n                gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );\n            }\n        }\n        $p.skipRender = false;\n        if($p.revealDensity) enhance({\n            viewIndex: viewIndex,\n            dim: [width, height],\n            offset: offset,\n            padding: padding\n        });\n        $p.bindFramebuffer(null);\n\n        if(!$p._update) {\n            let actions = Object.keys(vmap)\n                .filter(function(act){ return userActions.indexOf(act) !== -1});\n\n            actions.forEach(function(action) {\n                let response = {};\n                let viewId = vmap.id || $p.views[viewIndex].id;\n                response[viewId] = vmap[action];\n                let interactOptions = Object.assign({\n                    event: action,\n                    from: viewId,\n                    response: response,\n                }, vmap[action])\n                $p.interactions.push(interactOptions)\n            })\n        }\n    }\n}\n","import { randomJSONs, randomArrays } from './utils';\n\nlet educations = ['High School', 'Some College', 'AA/AS', 'Bachelor', 'Master', 'Doctorate']\nlet races = ['White', 'Asian', 'Black', 'Mixed'];\n\nlet dataProps = [\n    {name: 'BabyMonth', dtype: 'int', dist: 'uniform', min: 1, max: 12},\n    {name: 'BabyGender', dtype: 'string', values: ['F', 'M']},\n    {name: 'BabyWeight', dtype: 'float', dist: 'normal', min: 2, max: 20, mean: 7, std: 2},\n    {name: 'MotherAge', dtype: 'int', dist: 'normal', min: 16, max: 70, mean: 30, std: 10},\n    {name: 'MotherRace', dtype: 'string', values: races},\n    {name: 'MotherStatus', dtype: 'string', values: ['Married', 'Unmarried']},\n    {name: 'MotherEdu', dtype: 'string', values: educations},\n    {name: 'MotherHeight', dtype: 'int', dist: 'normal', min: 120, max: 220, mean: 168, std: 20},\n    {name: 'MotherWeight', dtype: 'float', dist: 'normal', min: 50, max: 290, mean: 100, std: 50},\n    {name: 'MotherWgtGain', dtype: 'float', dist: 'normal', min: 0, max: 100, mean: 30, std: 10},\n    {name: 'FatherAge', dtype: 'int', dist: 'normal', min: 15, max: 90, mean: 32, std: 10},\n    {name: 'FatherRace', dtype: 'string', values: races},\n    {name: 'FatherEdu', dtype: 'string', values: educations}\n];\n\nlet schema = {};\nfor(let prop of dataProps) {\n    schema[prop.name] = prop.dtype;\n}\n\nfunction Babies(arg) {\n    let dataSize = (Number.isInteger(arg)) ? arg : arg.size;\n    let props = arg.props || dataProps;\n    let type = arg.type || 'json';\n    let data = (type === 'json') ? randomJSONs({props: props, size: dataSize}): randomArrays({props: props, size: dataSize});\n    return { data, schema };\n}\n\nBabies.schema = schema;\n\nexport default Babies;","import { randomJSONs, randomArrays } from './utils';\r\n\r\nlet dataProps = [\r\n    {name: 'ApparentMagnitude', dtype: 'float', dist: 'normal', min: -27, max: 27, mean: 12, std: 3},\r\n    {name: 'GroundLongtitude', dtype: 'float', dist: 'uniform', min: 65.0, max: 85.0},\r\n    {name: 'GroundLatitude', dtype: 'float', dist: 'uniform', min: 5.0, max: 25.0},   \r\n    {name: 'RightAscension', dtype: 'float', dist: 'uniform', min: 279.62749, max: 301.82369},\r\n    {name: 'Decline', dtype: 'float', dist: 'uniform', min: 36.55995, max: 52.47462},   \r\n]\r\n\r\nlet schema = {};\r\nfor(let prop of dataProps) {\r\n    schema[prop.name] = prop.dtype;\r\n}\r\n\r\nfunction Kepler(arg) {\r\n    let dataSize = (Number.isInteger(arg)) ? arg : arg.size;\r\n    let props = arg.props || dataProps;\r\n    let type = arg.type || 'json';\r\n    let data = (type === 'json') ? randomJSONs({props: props, size: dataSize}): randomArrays({props: props, size: dataSize});\r\n    return { data, schema };\r\n}\r\n\r\nKepler.schema = schema;\r\n\r\nexport default Kepler;","import {boundedRandom} from './utils';\r\n\r\nexport default function ({\r\n  timesteps = 128,\r\n  series = 8,\r\n  interval = 1,\r\n  props,\r\n  label = {time: 'timestamp', series: 'sid'}\r\n}) {\r\n  let dsize = timesteps * series;\r\n  let data = new Array(dsize);\r\n  for(let i = 0; i < timesteps; i++) {\r\n    for(let j = 0; j < series; j++) {\r\n      let record = {};\r\n      record[label.time] = i * interval;\r\n      record[label.series] = j;\r\n      for(let prop of props) {\r\n          if(prop.hasOwnProperty('values')){\r\n              let vid = parseInt( Math.round( Math.random() * (prop.values.length - 1) ) );\r\n              record[prop.name] = prop.values[vid];\r\n          } else {\r\n              let value = boundedRandom(prop);\r\n              record[prop.name] = (prop.dtype == 'float') ? parseFloat(value) : Math.round(value);\r\n          }\r\n      }\r\n      data[i * series + j] = record;\r\n    }\r\n  }\r\n\r\n  let schema = {};\r\n  schema[label.time] = 'int';\r\n  schema[label.series] = 'float';\r\n  for(let prop of props) {\r\n      schema[prop.name] = prop.dtype;\r\n  }\r\n\r\n  return {\r\n    data,\r\n    schema\r\n  }\r\n}","\nimport {assert} from 'chai';\nimport {normal} from 'jStat';\nimport cstore from '../src/cstore'\nimport * as ctypes from '../src/ctypes'\n\nlet equal = assert.equal;\nlet closeTo = assert.closeTo;\nlet hasAllKeys = assert.hasAllKeys;\nlet normalDist = normal.sample;\n\nexport function boundedRandom(p) {\n    let min = p.min || 0;\n    let max = p.max || p.values.length || 1;\n    let value = min - 1;\n    let rand = (p.dist == 'normal') \n        ? function() { return normalDist(p.mean, p.std); }\n        : function() { return min + (max - min) * Math.random(); }\n    while ( value < min || value > max) {\n        // value = normalDist(p.mean, p.std);\n        value = rand(p);\n    }\n    if(p.hasOwnProperty('values')){\n        value = parseInt(value) ;\n    }\n    return value;\n}\n\nexport function randomColumns(arg) {\n    let options = arg || {};\n    let size = options.size || 0;\n    let props = options.props || [];\n    let db = cstore({});\n    props.forEach(function(prop) {\n        let dtype = p6.ctypes[prop.dtype] || Uint16Array;\n        let tuples = new dtype(size);\n        for(let i = 0; i < size; i++) {\n            tuples[i] = boundedRandom(prop);\n        }\n        db.addColumn({\n            data: tuples,\n            name: prop.name,\n            dtype: prop.dtype || 'string',\n            values: prop.values\n        });\n    })\n    return db;\n}\n\nexport function randomJSONs(arg) {\n    let options = arg || {};\n    let size = options.size || 0;\n    let props = options.props || [];\n    let data = new Array(size);\n    for(let i = 0; i < size; i++) {\n        data[i] = {};\n        props.forEach(function(prop) {\n            if(prop.hasOwnProperty('values')){\n                let vid = parseInt( Math.round( Math.random() * (prop.values.length - 1) ) );\n                data[i][prop.name] = prop.values[vid];\n            } else {\n                let value = boundedRandom(prop);\n                data[i][prop.name] = (prop.dtype == 'float') ? parseFloat(value) : Math.round(value);\n            }\n        });\n    }\n    return data;\n}\n\nexport function randomArrays(arg) {\n    let options = arg || {};\n    let size = options.size || 0;\n    let props = options.props || [];\n    let data = new Array(size);\n    for(let i = 0; i < size; i++) {\n        data[i] = [];\n        props.forEach(function(prop, pi) {\n            if(prop.hasOwnProperty('values')){\n                let vid = parseInt( Math.round( Math.random() * (prop.values.length - 1) ) );\n                data[i][pi] = prop.values[vid];\n            } else {\n                let value = boundedRandom(prop);\n                data[i][pi] = (prop.dtype == 'float') ? parseFloat(value) : Math.round(value);\n            }\n        });\n    }\n    return data;\n}\n\nexport function randomTypedColumns(arg) {\n    let options = arg || {};\n    let size = options.size || 0;\n    let props = options.props || [];\n    let data = new Array(props.length);\n\n    props.forEach(function(prop, pi) {\n        let column = new ctypes[prop.dtype](size);\n        for(let i = 0; i < size; i++) {\n            if(prop.hasOwnProperty('values')){\n                let vid = parseInt( Math.round( Math.random() * (prop.values.length - 1) ) );\n                column[i] = prop.values[vid];\n            } else {\n                let value = boundedRandom(prop);\n                column[i] = (prop.dtype == 'float') ? parseFloat(value) : Math.round(value);\n            }\n        }\n        data[pi] = column;\n    });\n\n    return data;\n}\n\nexport function validate(actual, expected, _delta) {\n    let delta = _delta || 1e-5;\n    let count = actual.length; \n\n    equal(count, actual.length, 'the size of the result should be ' + count);\n\n    for(let i = 0; i < count; i++) {\n        let keys = Object.keys(actual[i]);\n        hasAllKeys(expected[i], keys, 'result should have all the keys');\n        \n        for(let j = 0, l = keys.length; j < l; j++) {\n            if(typeof(actual[i][keys[j]]) == 'number') {\n                closeTo(actual[i][keys[j]], expected[i][keys[j]], expected[i][keys[j]]*delta);\n            } else {\n                equal(actual[i][keys[j]], expected[i][keys[j]]);\n            }\n        }\n    }\n\n}","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","import fs from 'fs'\nexport default class Csv {\n  constructor({\n    path,\n    chunkSize = 4 * 1024 * 1024,\n    offset = 0,\n    delimiter = ','\n  }) {\n    this.filePath = path\n    this.offset = offset\n    this.chunkSize = chunkSize\n    this.delimiter = delimiter\n    this.leftOver = ''\n    this.rows = []\n  }\n\n  fetch (nrows = 1000) {\n    if (nrows > this.rows.length) {\n      return this.loadFromFile().then(rows => {\n        this.rows = this.rows.concat(rows)\n        return this.fetch(nrows)\n      })\n    } else {\n      this.leftOver = ''\n      return new Promise ((resolve, reject) => {\n        resolve(this.rows.slice(0, nrows))\n        this.rows = this.rows.slice(nrows)\n      })\n    }\n  }\n\n  loadFromFile  () {\n    let data = []\n    this.leftOver = ''\n    console.log(this.offset)\n    return new Promise ((resolve, reject) => {\n      fs.open(this.filePath, 'r', (err, fd) => {\n        let buffer = new Buffer(this.chunkSize)\n        fs.read(fd, buffer, 0, this.chunkSize, this.offset, (err, nread) => {\n          if (err) {\n            reject(err)\n            fs.close()\n          }\n          if (nread === 0) fs.close()\n        \n          if (nread < this.chunkSize) {\n              data = buffer.slice(0, nread)\n          } else {\n              data = buffer\n          }\n          let text = this.leftOver + data.toString('utf8')\n          let rows = text.split('\\n')\n          this.leftOver = rows.pop()\n          data = rows.map(row => row.split(this.delimiter))\n          this.offset += this.chunkSize\n\n          resolve(data)\n        })\n      })\n    })\n  }\n}","import {datasets} from 'p4';\n\nlet dataModels = {\n  TimeSeries: {\n    timesteps: 1,\n    series: 512,\n    interval: 100,\n    props: [\n        {name: 'traffic', dtype: 'int',  dist: 'normal', min: 0, max: 10000, mean: 500, std: 180},\n        {name: 'sattime', dtype: 'float',  dist: 'normal', min: 0, max: 10000, mean: 500, std: 180}\n    ]\n  },\n  Babies: {}\n}\n\nexport default class Models {\n  constructor({\n    name = 'Babies',\n    prop = {}\n  }) {\n    if (Object.keys(dataModels).indexOf(name) === -1) {\n      throw Error('No data model found for ' + name)\n    }\n    this.model = name\n    this.prop = prop\n  }\n\n  fetch (nrows = 1000) {\n    let modelProps = Object.assign(this.prop, dataModels[this.model])\n    modelProps.size = nrows\n    modelProps.timesteps = nrows\n    modelProps.type = 'array'\n    let dataset = datasets[this.model](modelProps)\n    return new Promise((resolve, reject) => {\n      resolve(dataset.data)\n    })\n  }\n}\n","import mysql from 'mysql'\n\nexport default class Rdb {\n    constructor({\n        host = 'localhost',\n        user,\n        password,\n        database,\n        query\n    }) {\n        this.source = { host, user, password, database};\n        this.query = query || 'select * from ' + database\n        this.loaded = 0\n    }\n\n    fetch (numRows = 1000, offset) {\n        let db = mysql.createConnection(this.source)\n        let start = offset || this.loaded\n        db.connect()\n        return new Promise ((resolve, reject) => {\n            db.query(this.query + ' limit ' + [start, numRows].join(','), (error, results, fields) => {\n                if (error) reject(error);\n                resolve(results)\n                db.end()\n                this.loaded += numRows\n            })\n        })\n    }\n}","import express from 'express'\nimport http from 'http'\n\nlet app = express()\nlet server = http.Server(app)\nlet port = process.env.PORT || 7000\nlet host = process.env.HOST || \"localhost\"\nlet WebSocketServer = require('ws').Server\nlet wss = new WebSocketServer({ server })\n\napp.use('/dist', express.static('dist'))\napp.use('/test', express.static('test'))\napp.use('/demos', express.static('demos'))\n\nwss.on('connection', function connection (ws) {\n  console.log('new connection');\n  ws.on('message', function incoming (msg) {\n    console.log(msg)\n  })\n})\n\nimport Mysql from './loaders/Mysql'\nimport datasets from '../test/datasets.json'\nimport Csv from './loaders/Csv'\nimport Model from './loaders/Model'\n\nfunction Dataset (dsName) {\n  let dataset = datasets[dsName]\n  if(dataset.type === 'mysql') {\n    return {\n      schema: dataset.schema,\n      source: new Mysql(dataset.source)\n    }\n  } else if(dataset.type === 'file') {\n    return {\n      schema: dataset.schema,\n      source: new Csv(dataset.source)\n    }\n  } else if(dataset.type === 'synthetic' || dataset.type === 'model') {\n    return {\n      schema: dataset.schema,\n      source: new Model(dataset.source)\n    }\n  }\n}\n\nlet selectedDataset = null\n\napp.get('/data/:dataset', function (req, res) {\n  let dataset = req.params.dataset\n  let start = req.query.start\n  let nrows = req.query.nrows || 10000\n  if (selectedDataset === null) selectedDataset = Dataset(dataset)\n  \n  selectedDataset.source.fetch(nrows, start).then(result => {\n    res.json({\n      schema: selectedDataset.schema,\n      data: result\n    })\n  })\n})\n\napp.get('/testdata', function (req, res) {\n  res.json({data: 'test'})\n})\n\nserver.listen(port, host, function() {\n  console.log(\"server started, listening\", host, port)\n})\n","module.exports = require(\"chai\");","module.exports = require(\"express\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"jStat\");","module.exports = require(\"mysql\");","module.exports = require(\"p3.js\");","module.exports = require(\"ws\");"],"sourceRoot":""}